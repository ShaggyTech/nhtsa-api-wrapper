{"version":3,"file":"iife.js","sources":["../../src/utils/getTypeof.ts","../../src/utils/makeQueryString.ts","../../src/api/Fetch.ts","../../src/api/actions/DecodeVin.ts","../../src/api/actions/DecodeVinValues.ts","../../src/api/actions/DecodeVinExtended.ts","../../src/api/actions/DecodeVinValuesExtended.ts","../../src/api/actions/DecodeWMI.ts","../../src/api/actions/GetWMIsForManufacturer.ts","../../src/api/actions/GetAllMakes.ts","../../src/api/actions/GetParts.ts","../../src/api/actions/GetAllManufacturers.ts","../../src/api/actions/GetManufacturerDetails.ts","../../src/api/actions/GetMakeForManufacturer.ts","../../src/api/actions/GetMakesForManufacturerAndYear.ts","../../src/api/actions/GetMakesForVehicleType.ts","../../src/api/actions/GetVehicleTypesForMake.ts","../../src/api/actions/GetVehicleTypesForMakeId.ts","../../src/api/NHTSA.ts","../../src/utils/isValidType.ts","../../src/utils/isValidVin.ts"],"sourcesContent":["/**\r\n * @module getTypeof\r\n * @category Utils\r\n */\r\n\r\n/**\r\n * Returns the typeof of a given value using Object.prototype.toString.call(value)\r\n * @param {any} value what value to get the type of\r\n * @returns {string} Type of value, normalized to a lowercase string\r\n */\r\n\r\nexport function getTypeof(value: any): string {\r\n  const type = Object.prototype.toString\r\n    .call(value)\r\n    .toLowerCase(); /* ex: => [object string] */\r\n  return type.slice(8, type.length - 1);\r\n}\r\n","/**\r\n * @memberof module:makeQueryString\r\n * @category Utils\r\n *\r\n * @description Object containing Key:Value pairs to build the URL query string with.<br>\r\n * Parameter values may be either strings or numbers. <br>\r\n * ---\r\n * ```javascript\r\n *  Example\r\n *  {\r\n *    format: 'json',\r\n *    modelYear: 2009,\r\n *    whatever: 'something'\r\n *  }\r\n * ```\r\n */\r\nexport interface QueryStringParameters {\r\n  [propName: string]: string | number | undefined;\r\n}\r\n\r\n/**\r\n * @module makeQueryString\r\n * @category Utils\r\n */\r\n\r\n/**\r\n * @async\r\n * @description Utility method to generate a query string.<br>\r\n *   Prepend it to an API URL string. <br>\r\n *   ---\r\n *\r\n * @param {object} params Object of Type [QueryStringParameters](module-makeQueryString.QueryStringParameters.html)\r\n *\r\n * @returns {Promise<string>|Error} An API query string <br>\r\n *  - On resolve: `Promise(<string>)`<br>\r\n *  - On reject: `new Error(<string>)` - if parameters are not of type 'object'\r\n *\r\n * @example <caption>Single Param:</caption>\r\n * const qs = await genQueryString({\r\n *   format: 'json'\r\n * }).catch(error => error)\r\n * //  qs = \"format=json\"\r\n *\r\n * @example <caption>Multiple Params:</caption>\r\n * const qs = await genQueryString({\r\n *   format: 'json',\r\n *   modelYear: 2006,\r\n *   page: \"2\"\r\n * }).catch(error => error)\r\n * // qs = \"?format=json&modelYear=2006&page=2\"\r\n *\r\n * @example <caption>Empty Params Object:</caption>\r\n * const qs = await genQueryString({}).catch(error => error)\r\n * // qs = \"\"\r\n *\r\n */\r\n\r\nexport function makeQueryString(\r\n  params: QueryStringParameters = {}\r\n): Promise<string | Error> {\r\n  // Error message begins with\r\n  const errorBase =\r\n    'queryString(params) - expected params in the form of an object , got:';\r\n\r\n  // Type guard params argument, must be of type object\r\n  if (Object.prototype.toString.call(params) !== '[object Object]') {\r\n    return Promise.reject(new Error(`${errorBase} ${params}`));\r\n  }\r\n\r\n  // Setup QueryString for Array mapping\r\n  const entries = Object.entries(params);\r\n  const paramsLength = entries.length;\r\n\r\n  // Return an empty string if params are an empty object\r\n  if (paramsLength < 1) return Promise.resolve('');\r\n\r\n  // Used to check if we've already prepended a valid query param\r\n  let isPrepended = false;\r\n\r\n  // Map [key]:value entries to \"key=value\" strings in an array\r\n  const queryStringArray = entries.map(([key, value], index) => {\r\n    let prepend = '';\r\n    let append = '';\r\n\r\n    const typeofValue = typeof value;\r\n\r\n    if (value && typeofValue === 'number') {\r\n      value = value.toString();\r\n    }\r\n\r\n    // skip any invalid values, only string or number types are valid\r\n    if (value && (typeofValue === 'string' || typeofValue === 'number')) {\r\n      // if this is the first param we need to prepend the '?' char\r\n      if (value !== '' && !isPrepended) {\r\n        prepend = '?';\r\n        isPrepended = true;\r\n      }\r\n      // if there is another param coming after this one we need to append the '&' char\r\n      if (index < paramsLength - 1) {\r\n        append = '&';\r\n      }\r\n\r\n      // map the completed partial query string to queryStringArray\r\n      return `${prepend}${key}=${value}${append}`;\r\n    }\r\n    return;\r\n  });\r\n\r\n  // Join and return the completed query string anfter URI encoding\r\n  return Promise.resolve(encodeURI(queryStringArray.join('')));\r\n}\r\n","/* Module Dependencies */\r\nimport fetch from 'cross-fetch';\r\n\r\n/* Utilities */\r\nimport { getTypeof, makeQueryString, QueryStringParameters } from '../utils';\r\n\r\n/* Types */\r\nimport { FetchConfig, FetchResponse, NhtsaResponse } from './index';\r\n\r\n/* Constants */\r\nexport const BASE_URL = 'https://vpic.nhtsa.dot.gov/api/vehicles';\r\nexport const DEFAULT_CONFIG: FetchConfig = {\r\n  apiResponseFormat: 'json',\r\n  baseUrl: BASE_URL\r\n};\r\n\r\nexport class Fetch {\r\n  apiResponseFormat?: string;\r\n  baseUrl?: string;\r\n  config?: FetchConfig;\r\n\r\n  constructor(userConfig?: FetchConfig) {\r\n    let finalConfig: FetchConfig;\r\n\r\n    if (getTypeof(userConfig) === 'object') {\r\n      finalConfig = { ...DEFAULT_CONFIG, ...userConfig };\r\n    } else {\r\n      finalConfig = { ...DEFAULT_CONFIG };\r\n    }\r\n\r\n    this.apiResponseFormat = 'json';\r\n    this.baseUrl = finalConfig.baseUrl;\r\n    this.config = finalConfig;\r\n  }\r\n\r\n  public async buildQueryString(\r\n    params: QueryStringParameters\r\n  ): Promise<string | Error> {\r\n    /*\r\n     * Make sure we're always using 'format=json' in the url Query parameters\r\n     * If the user provides a 'format' key in the params, during class instantiation we want to override it to 'json'\r\n     * Support for the other formats (CSV and XML) can be added at a later date by configuring the fetch request\r\n     */\r\n    if (!params || getTypeof(params) !== 'object') {\r\n      params = {\r\n        format: this.apiResponseFormat\r\n      };\r\n    } else {\r\n      params = { ...params, format: this.apiResponseFormat };\r\n    }\r\n\r\n    return await makeQueryString(params);\r\n  }\r\n\r\n  public async get(url: string): Promise<FetchResponse | Error> {\r\n    if (getTypeof(url) !== 'string') {\r\n      return Promise.reject(\r\n        new Error('Fetch.get(url) - url argument must be of type string')\r\n      );\r\n    }\r\n\r\n    const response: Response = await fetch(url)\r\n      .then(result => {\r\n        if (!result?.status || result.status >= 400) {\r\n          throw new Error(\r\n            `Bad response from server, code: ${result?.status}, text: ${result?.statusText}, headers: ${result?.headers}`\r\n          );\r\n        }\r\n\r\n        return result;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`Fetch.get() http error: ${err}`))\r\n      );\r\n\r\n    const json: NhtsaResponse = await response.json();\r\n\r\n    const finalResult: FetchResponse = {\r\n      ...json,\r\n      Response: {\r\n        headers: response.headers,\r\n        ok: response.ok,\r\n        redirected: response.redirected,\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        url: response.url\r\n      }\r\n    };\r\n\r\n    return Promise.resolve(finalResult);\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class DecodeVin extends Fetch {\r\n  /**\r\n   * The DecodeVin API Action will decode the VIN and the decoded output will be made available in the format of Key-value pairs.\r\n   * The IDs (VariableID and ValueID) represent the unique ID associated with the Variable/Value.\r\n   * In case of text variables, the ValueID is not applicable.\r\n   * Model Year in the request allows for the decoding to specifically be done in the current,\r\n   * or older (pre-1980), model year ranges. It is recommended to always send in the model year.\r\n   * This API also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   * In this case, the VIN will be decoded partially with the available characters.\r\n   * In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   * The 9th digit is not necessary.\r\n   */\r\n  async DecodeVin(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'DecodeVin';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class DecodeVinValues extends Fetch {\r\n  /**\r\n   * The DecodeVinValues API Action will decode the VIN and the decoded output will be made available in a flat file format.\r\n   * Model Year in the request allows for the decoding to specifically be done in the current,\r\n   * or older (pre-1980), model year ranges. It is recommended to always send in the model year.\r\n   * This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   * In this case, the VIN will be decoded partially with the available characters.\r\n   * In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   */\r\n  async DecodeVinValues(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'DecodeVinValues';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class DecodeVinExtended extends Fetch {\r\n  /**\r\n   * This is exactly like the DecodeVin method but provides additional information on variables\r\n   * related to other NHTSA programs like NCSA etc.\r\n   * This will decode the VIN and the decoded output will be made available\r\n   * in the format of Key-value pairs.\r\n   * The IDs (VariableID and ValueID) represent the unique ID associated with the Variable/Value.\r\n   * In case of text variables, the ValueID is not applicable.\r\n   * Model Year in the request allows for the decoding to specifically be done in the current,\r\n   * or older (pre-1980), model year ranges. It is recommended to always send in the model year.\r\n   * This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   * In this case, the VIN will be decoded partially with the available characters.\r\n   * In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   * The 9th digit is not necessary.\r\n   */\r\n  async DecodeVinExtended(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'DecodeVinExtended';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class DecodeVinValuesExtended extends Fetch {\r\n  /**\r\n   * This is exactly like the DecodeVinValues (flat format) method but provides additional information\r\n   * on variables related to other NHTSA programs like NCSA etc.\r\n   * This will decode the VIN and the decoded output will be made available in a flat file format.\r\n   * Model Year in the request allows for the decoding to specifically be done in the current,\r\n   * or older (pre-1980), model year ranges. It is recommended to always send in the model year.\r\n   * This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   * In this case, the VIN will be decoded partially with the available characters.\r\n   * In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   */\r\n  async DecodeVinValuesExtended(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'DecodeVinValuesExtended';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class DecodeWMI extends Fetch {\r\n  /**\r\n   * This provides information on the World Manufacturer Identifier for a specific WMI code.\r\n   * WMIs may be put in as either 3 characters representing VIN position 1-3 or 6 characters\r\n   * representing VIN positions 1-3 & 12-14. Example \"JTD\", \"1T9131\".\r\n   */\r\n  async DecodeWMI(WMI: string): Promise<NhtsaResponse | Error> {\r\n    const action = 'DecodeWMI';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(WMI) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, WMI argument is required and must be a string, got: ${WMI}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${WMI}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetWMIsForManufacturer extends Fetch {\r\n  /**\r\n   * Provides information on the all World Manufacturer Identifier (WMI) for a specified Manufacturer.\r\n   * Only WMI registered in vPICList are displayed.\r\n   */\r\n  async GetWMIsForManufacturer(\r\n    manufacturer: string\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetWMIsForManufacturer';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(manufacturer) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetAllMakes extends Fetch {\r\n  /**\r\n   * This provides a list of all the Makes available in vPIC Dataset.\r\n   */\r\n  public async GetAllMakes(): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetAllMakes';\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetParts extends Fetch {\r\n  /**\r\n   * This provides a list of ORGs with letter date in the given range of the dates and with specified Type of ORG.\r\n   * Up to 1000 results will be returned at a time, get the next page by incrementing the \"page\" parameter.\r\n   */\r\n  async GetParts(\r\n    params: {\r\n      type?: string | number;\r\n      fromDate?: string;\r\n      toDate?: string;\r\n      page?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetParts';\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { RequestManufacturerType, NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetAllManufacturers extends Fetch {\r\n  /**\r\n   * This provides a list of all the Manufacturers available in vPIC Dataset.\r\n   * Parameter \"manufacturerType\" allows to filter the list based on manufacturer type,\r\n   * (Incomplete Vehicles, Completed Vehicle Manufacturer, Incomplete Vehicle Manufacturer,\r\n   * Intermediate Manufacturer, Final-Stage Manufacturer, Alterer, or any part of it), optional.\r\n   * You can get a list of all manufacturer types with this API call:\r\n   * \"/api/vehicles/getvehiclevariablevalueslist/Manufacturer Type\"\r\n   * Results are provided in pages of 100 items.\r\n   * Use parameter \"page\" to specify 1-st (default), 2nd, 3rd, ...Nth ... page.\r\n   */\r\n  async GetAllManufacturers(\r\n    params: {\r\n      manufacturerType?: RequestManufacturerType;\r\n      page?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetAllManufacturers';\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetManufacturerDetails extends Fetch {\r\n  /**\r\n   * This provides the details for a specific manufacturer that is requested.\r\n   * If supplied manufacturer is a number - method will do exact match on Manufacturer's Id.\r\n   * If supplied manufacturer is a string - it will look for manufacturers whose name is LIKE the provided name,\r\n   * (it accepts a partial manufacturer name as an input).\r\n   * Multiple results are returned in case of multiple matches.\r\n   */\r\n  public async GetManufacturerDetails(\r\n    manufacturer: string | number\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetManufacturerDetails';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string or number, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetMakeForManufacturer extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified manufacturer that is requested.\r\n   * If supplied manufacturer is a number - method will do exact match on Manufacturer's Id.\r\n   * If supplied manufacturer is a string - it will look for manufacturers whose name is LIKE the provided name\r\n   * (it accepts a partial manufacturer name as an input).\r\n   * Multiple results are returned in case of multiple matches.\r\n   * Manufacturer name can be a partial name, or a full name for more specificity\r\n   * (e.g., \"988\", \"HONDA\", \"HONDA OF CANADA MFG., INC.\", etc.)\r\n   */\r\n  async GetMakeForManufacturer(\r\n    manufacturer: string | number\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetMakeForManufacturer';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string or number, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetMakesForManufacturerAndYear extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified manufacturer,\r\n   * and whose Year From and Year To range cover the specified year.\r\n   * If supplied manufacturer is a number - method will do exact match on Manufacturer's Id.\r\n   * If supplied manufacturer is a string - it will look for manufacturers whose name is LIKE the provided name\r\n   * (it accepts a partial manufacturer name as an input).\r\n   * Multiple results are returned in case of multiple matches.\r\n   * Manufacturer can be idenfitied by Id, a partial name, or a full name\r\n   * (e.g., \"988\", \"HONDA\", \"HONDA OF CANADA MFG., INC.\", etc.)\r\n   */\r\n  public async GetMakesForManufacturerAndYear(\r\n    manufacturer: string | number,\r\n    params: {\r\n      year: string | number;\r\n    } = { year: undefined as any }\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetMakesForManufacturerAndYear';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, please provide a valid manufacturer arg, either a number or string, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n    if (!params.year) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, please provide a valid year parameter, either a number or string, got params.year: ${params.year}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetMakesForVehicleType extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified vehicle type,\r\n   * whose name is LIKE the vehicle type name in vPIC Dataset.\r\n   * Vehicle Type name can be a partial name, or a full name for more specificity\r\n   * (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.).\r\n   */\r\n  async GetMakesForVehicleType(\r\n    typeName: string\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetMakesForVehicleType';\r\n\r\n    if (getTypeof(typeName) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, typeName is required and must be a string, got: ${typeName}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${typeName}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetVehicleTypesForMake extends Fetch {\r\n  /**\r\n   * This returns all the Vehicle Types in the vPIC dataset for a specified Make,\r\n   * whose name is LIKE the make name in vPIC Dataset.\r\n   * Make name can be a partial name, or a full name for more specificity\r\n   * (e.g., \"Merc\", \"Mercedes Benz\", etc.).\r\n   */\r\n  async GetVehicleTypesForMake(\r\n    makeName: string\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetVehicleTypesForMake';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeName) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeName is required and must be a string, got: ${makeName}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${makeName}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetVehicleTypesForMakeId extends Fetch {\r\n  /**\r\n   * This returns all the Vehicle Types in the vPIC dataset for a specified Make\r\n   * whose ID equals the make ID in vPIC Dataset.\r\n   */\r\n  async GetVehicleTypesForMakeId(\r\n    makeID: number\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetVehicleTypesForMakeId';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeID) !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeID is required and must be a number, got: ${makeID}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${makeID}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from './Fetch';\r\n\r\n/* API Actions */\r\nimport {\r\n  DecodeVin,\r\n  DecodeVinValues,\r\n  DecodeVinExtended,\r\n  DecodeVinValuesExtended,\r\n  DecodeWMI,\r\n  GetWMIsForManufacturer,\r\n  GetAllMakes,\r\n  GetParts,\r\n  GetAllManufacturers,\r\n  GetManufacturerDetails,\r\n  GetMakeForManufacturer,\r\n  GetMakesForManufacturerAndYear,\r\n  GetMakesForVehicleType,\r\n  GetVehicleTypesForMake,\r\n  GetVehicleTypesForMakeId\r\n} from './actions';\r\n\r\n/* Types */\r\nimport { FetchConfig } from './index';\r\n\r\nclass NHTSA extends Fetch\r\n  implements\r\n    DecodeVin,\r\n    DecodeVinValues,\r\n    DecodeVinExtended,\r\n    DecodeVinValuesExtended,\r\n    DecodeWMI,\r\n    GetAllMakes,\r\n    GetParts,\r\n    GetAllManufacturers,\r\n    GetManufacturerDetails,\r\n    GetMakeForManufacturer,\r\n    GetWMIsForManufacturer,\r\n    GetMakesForManufacturerAndYear,\r\n    GetMakesForVehicleType,\r\n    GetVehicleTypesForMake,\r\n    GetVehicleTypesForMakeId {\r\n  constructor(userConfig?: FetchConfig) {\r\n    super(userConfig);\r\n  }\r\n\r\n  DecodeVin = DecodeVin.prototype.DecodeVin;\r\n\r\n  DecodeVinValues = DecodeVinValues.prototype.DecodeVinValues;\r\n\r\n  DecodeVinExtended = DecodeVinExtended.prototype.DecodeVinExtended;\r\n\r\n  DecodeVinValuesExtended =\r\n    DecodeVinValuesExtended.prototype.DecodeVinValuesExtended;\r\n\r\n  DecodeWMI = DecodeWMI.prototype.DecodeWMI;\r\n\r\n  GetWMIsForManufacturer =\r\n    GetWMIsForManufacturer.prototype.GetWMIsForManufacturer;\r\n\r\n  GetAllMakes = GetAllMakes.prototype.GetAllMakes;\r\n\r\n  GetParts = GetParts.prototype.GetParts;\r\n\r\n  GetAllManufacturers = GetAllManufacturers.prototype.GetAllManufacturers;\r\n\r\n  GetManufacturerDetails =\r\n    GetManufacturerDetails.prototype.GetManufacturerDetails;\r\n\r\n  GetMakeForManufacturer =\r\n    GetMakeForManufacturer.prototype.GetMakeForManufacturer;\r\n\r\n  GetMakesForManufacturerAndYear =\r\n    GetMakesForManufacturerAndYear.prototype.GetMakesForManufacturerAndYear;\r\n\r\n  GetMakesForVehicleType =\r\n    GetMakesForVehicleType.prototype.GetMakesForVehicleType;\r\n\r\n  GetVehicleTypesForMake =\r\n    GetVehicleTypesForMake.prototype.GetVehicleTypesForMake;\r\n\r\n  GetVehicleTypesForMakeId =\r\n    GetVehicleTypesForMakeId.prototype.GetVehicleTypesForMakeId;\r\n}\r\n\r\nexport { NHTSA };\r\n\r\nexport const Client = new NHTSA();\r\n","/**\r\n * @memberof module:isValidType\r\n * @category Utils\r\n *\r\n * @description Options argument object provided to utils/isValidType()\r\n *\r\n * ```javascript\r\n *  {\r\n *    type: <string>,\r\n *    value: <any>\r\n *  }\r\n * ```\r\n */\r\ninterface IsValidTypeOptions {\r\n  type: string;\r\n  value: any;\r\n}\r\n\r\n/**\r\n * @module isValidType\r\n * @category Utils\r\n */\r\n\r\n/**\r\n * @async\r\n * @description Validate types and existence of various input values.<br>\r\n * Note: Uses `Object.prototype.toString.call(value)` under the hood\r\n *\r\n * ---\r\n *\r\n * Returns `true` if:\r\n *   - type of value is equal to provided type\r\n *\r\n * ---\r\n *\r\n * Returns `false` if:\r\n *   - 'options.value is not of type options.type\r\n *   - 'options.type' is missing from options object\r\n *   - 'options.type' is not of type 'string'\r\n *   - 'options.value' is falsey or not provided\r\n *\r\n * @param {object} options Object of Type [IsValidTypeOptions](module-isValidType.IsValidTypeOptions.html)\r\n * @param {string} options.type What type are you expecting the value to be?\r\n * @param {any} options.value What value are we testing against?\r\n * @returns {Promise<Boolean>}\r\n *\r\n * @example <caption>Verify type string</caption>\r\n * const isValid = await isValidType({\r\n *   type: 'string',\r\n *   value: 'this is a string'\r\n * }).catch(error => error)\r\n * //  isValid = \"true\"\r\n *\r\n * @example <caption>Verify type object</caption>\r\n * const isValid = await isValidType({\r\n *   type: 'object',\r\n *   value: { someKey: 'some value' }\r\n * }).catch(error => error)\r\n * //  isValid = \"true\"\r\n *\r\n * @example <caption>Returns false if type is not valid</caption>\r\n * const isValid = await isValidType({\r\n *   type: 'array',\r\n *   value: 'this is not an array'\r\n * }).catch(error => error)\r\n * //  isValid = \"false\"\r\n */\r\n\r\nexport async function isValidType(opts: IsValidTypeOptions): Promise<boolean> {\r\n  // Gatekeeping\r\n  if (typeof opts?.type !== 'string' || !opts.value) {\r\n    return Promise.resolve(false);\r\n  }\r\n\r\n  // normalize type\r\n  const type_ = opts.type.toLowerCase();\r\n\r\n  const expected = `[object ${type_}]`;\r\n  const actual = Object.prototype.toString.call(opts.value).toLowerCase();\r\n\r\n  return Promise.resolve(expected === actual);\r\n}\r\n","/**\r\n * @module isValidVin\r\n * @category Utils\r\n */\r\n\r\n/**\r\n * @async\r\n *\r\n * @description Provides **offline** validation of Vehicle Identification Numbers (VINs) using the\r\n * [VIN Check Algorithm](https://en.wikibooks.org/wiki/Vehicle_Identification_Numbers_(VIN_codes)/Check_digit)\r\n *\r\n * @param {string} vin Vehicle Identification Number\r\n *\r\n * @returns {Promise<boolean>} true | false\r\n *\r\n * @example <caption>When loaded from a bundle via html script tags</caption>\r\n * // <script type=\"text/javascript\" src=\"https://www.npmjs.com/package/@shaggytools/nhtsa-api-wrapper\"></script>\r\n * const isValid = await NHTSA.isValidVin('3VWD07AJ5EM388202').catch(error => error)\r\n * // isValid = true\r\n *\r\n * @example <caption>When loaded as a module</caption>\r\n * import { isValidVin } from '@shaggytools/nhtsa-api-wrapper'\r\n * const isValid = await isValidVin('3VWD07AJ5EM388202').catch(error => error)\r\n * // isValid = true\r\n */\r\nexport async function isValidVin(vin: string): Promise<boolean> {\r\n  /* A valid VIN must be a string and is always exactly 17 digits */\r\n  if (typeof vin !== 'string' || vin.length != 17) {\r\n    return Promise.resolve(false);\r\n  }\r\n\r\n  /* Normalize the vin to all uppercase letters */\r\n  vin = vin.toUpperCase();\r\n\r\n  /* split the vin digits into an array */\r\n  const vinArray: string[] = vin.split('');\r\n\r\n  /* checkDigit will be tested against the checkSum later */\r\n  const checkDigit: string = vinArray[8];\r\n\r\n  /*\r\n   * In a valid VIN, the checkDigit can either be:\r\n   * a number, 0-9 inclusive OR the character 'X'\r\n   */\r\n  if (isNaN(parseInt(checkDigit)) && checkDigit !== 'X') {\r\n    return Promise.resolve(false);\r\n  }\r\n\r\n  /*\r\n   * The checkValue must be a digit and 'X' is the only valid alphabetic check value.\r\n   * As per the algorithm, a checkDigit of 'X' is equal to a checkValue of `10` and needs\r\n   * to be converted as such.\r\n   */\r\n  const checkValue: number = checkDigit === 'X' ? 10 : parseInt(checkDigit);\r\n\r\n  /*\r\n   * There will need to be some way to translate vin digits that are alphabetic\r\n   * into their number value in the VIN algorithm transliteration table.\r\n   * Later, during the creation of the checkusm variable, those digits will be\r\n   * multiplied against their corresponding weight (by index) in the weightsArray.\r\n   * This transliteration table is a key part of the VIN validation algorithm.\r\n   */\r\n  const transliterationTable: object = {\r\n    A: 1,\r\n    B: 2,\r\n    C: 3,\r\n    D: 4,\r\n    E: 5,\r\n    F: 6,\r\n    G: 7,\r\n    H: 8,\r\n    J: 1,\r\n    K: 2,\r\n    L: 3,\r\n    M: 4,\r\n    N: 5,\r\n    P: 7,\r\n    R: 9,\r\n    S: 2,\r\n    T: 3,\r\n    U: 4,\r\n    V: 5,\r\n    W: 6,\r\n    X: 7,\r\n    Y: 8,\r\n    Z: 9\r\n  };\r\n\r\n  /*\r\n   * Later, during the creation of the 'checksum' variable, these weights will be\r\n   * multilplied by the value of their mirrored index vin digits.\r\n   * The array index of each weight corresponds to the same index of each\r\n   * digit in the 'vin'.\r\n   */\r\n  const weightsArray: number[] = [\r\n    8,\r\n    7,\r\n    6,\r\n    5,\r\n    4,\r\n    3,\r\n    2,\r\n    10,\r\n    0,\r\n    9,\r\n    8,\r\n    7,\r\n    6,\r\n    5,\r\n    4,\r\n    3,\r\n    2\r\n  ];\r\n\r\n  /*\r\n   * Maps the vinArray and converts any values (digits) that are alphabetic,\r\n   * into numbers, using the above transliteration table.\r\n   * Then these numbers are multiplied against their corresponding weight\r\n   * in the weights array, matched by index position.\r\n   * All 17 of those digitValues are then added together and divided by 11.\r\n   * The remainder, or % modulo, of that division will be the final 'checksum'.\r\n   */\r\n  const checksum =\r\n    vinArray\r\n      .map((digit, index) => {\r\n        let digitValue: number;\r\n        isNaN(parseInt(digit))\r\n          ? (digitValue = transliterationTable[digit])\r\n          : (digitValue = parseInt(digit));\r\n\r\n        const weight: number = weightsArray[index];\r\n        return digitValue * weight;\r\n      })\r\n      .reduce((acc, currValue) => acc + currValue, 0) % 11;\r\n\r\n  /*\r\n   * The checksum is compared against the checkValue we set earlier (the 9th digit of the VIN)\r\n   * As per the algorithm, if they are equal to each other, then the VIN must be valid and\r\n   * we return true, otherwise the VIN is invalid and we return false.\r\n   */\r\n  return Promise.resolve(checksum === checkValue);\r\n}\r\n"],"names":["getTypeof","value","type","Object","prototype","toString","call","toLowerCase","slice","length","makeQueryString","params","Promise","reject","Error","errorBase","entries","paramsLength","resolve","isPrepended","queryStringArray","map","_a","index","key","prepend","append","typeofValue","encodeURI","join","DEFAULT_CONFIG","apiResponseFormat","baseUrl","userConfig","finalConfig","this","config","Fetch","format","url","fetch","then","result","status","statusText","headers","catch","err","response","json","finalResult","Response","ok","redirected","__extends","DecodeVin","vin","action","buildQueryString","queryString","get","DecodeVinValues","DecodeVinExtended","DecodeVinValuesExtended","DecodeWMI","WMI","GetWMIsForManufacturer","manufacturer","GetAllMakes","GetParts","GetAllManufacturers","GetManufacturerDetails","GetMakeForManufacturer","GetMakesForManufacturerAndYear","year","undefined","GetMakesForVehicleType","typeName","GetVehicleTypesForMake","makeName","GetVehicleTypesForMakeId","makeID","_super","_this","Client","NHTSA","opts","type_","expected","actual","toUpperCase","vinArray","split","checkDigit","isNaN","parseInt","checkValue","transliterationTable","A","B","C","D","E","F","G","H","J","K","L","M","N","P","R","S","T","U","V","W","X","Y","Z","weightsArray","checksum","digit","reduce","acc","currValue"],"mappings":"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"}