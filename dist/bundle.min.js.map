{"version":3,"file":"bundle.min.js","sources":["../src/utils/getTypeof.ts","../src/utils/makeQueryString.ts","../src/api/Fetch.ts","../src/api/actions/DecodeVin.ts","../src/api/actions/DecodeVinExtended.ts","../src/api/actions/DecodeVinValues.ts","../src/api/actions/DecodeVinValuesExtended.ts","../src/api/actions/DecodeWMI.ts","../src/api/actions/GetAllMakes.ts","../src/api/actions/GetAllManufacturers.ts","../src/api/actions/GetCanadianVehicleSpecifications.ts","../src/api/actions/GetEquipmentPlantCodes.ts","../src/api/actions/GetMakeForManufacturer.ts","../src/api/actions/GetMakesForManufacturerAndYear.ts","../src/api/actions/GetMakesForVehicleType.ts","../src/api/actions/GetManufacturerDetails.ts","../src/api/actions/GetModelsForMake.ts","../src/api/actions/GetModelsForMakeId.ts","../src/api/actions/GetModelsForMakeIdYear.ts","../src/api/actions/GetModelsForMakeYear.ts","../src/api/actions/GetParts.ts","../src/api/actions/GetVehicleTypesForMake.ts","../src/api/actions/GetVehicleTypesForMakeId.ts","../src/api/actions/GetVehicleVariableList.ts","../src/api/actions/GetVehicleVariableValuesList.ts","../src/api/actions/GetWMIsForManufacturer.ts","../src/api/NHTSA.ts","../src/utils/isValidVin.ts"],"sourcesContent":["/**\r\n * @module utils/getTypeof\r\n * @category Utils\r\n */\r\n\r\n/**\r\n * Gets type of `value` using `Object.prototype.toString.call(value)`.\r\n *\r\n * @param {any} value - Any kind of value (string, object, array, function, etc).\r\n *\r\n * @returns {string} - Type of value, normalized to a lowercase string.\r\n */\r\nexport function getTypeof(value: any): string {\r\n  const toString: string = Object.prototype.toString\r\n    .call(value)\r\n    .toLowerCase(); /* ex: => '[object string]' or '[object array], etc. */\r\n  return toString.slice(8, toString.length - 1);\r\n}\r\n","import { getTypeof } from '../utils';\r\n\r\n/**\r\n * @module utils/makeQueryString\r\n * @category Utils\r\n */\r\n\r\n/**\r\n * Utility method to generate a query string compatible with the NHSTA API, for use in an API URL string.\r\n *\r\n * @async\r\n *\r\n * @param {object} params - Object of Type [QueryStringParameters](module-makeQueryString.QueryStringParameters.html).\r\n * @param {boolean} [allowEmptyStringValues=false] - Set to `true` to add empty parameter values to the returned query string.\r\n * - Given params of `{ paramName: \"\" }` , setting this to true will use 'paramName=' in the final query string.\r\n * - GetCanadianVehicleSpecifications is the only API Action that requires this functionality.\r\n *\r\n * @returns {Promise<string>|Error} A query string of search parameters for use in a final Fetch.get URL.\r\n *\r\n * @example <caption>When loaded from the browser via html script tags</caption>\r\n * // <script type=\"text/javascript\" src=\"https://www.npmjs.com/package/@shaggytools/nhtsa-api-wrapper\"></script>\r\n * const qs = await NHTSA.makeQueryString({ modelYear: 2010 }).catch(error => error)\r\n * console.log(qs) // \"?modelYear=2010\"\r\n *\r\n * @example <caption>When loaded as a module</caption>\r\n * import { makeQueryString } from '@shaggytools/nhtsa-api-wrapper'\r\n * const qs = await makeQueryString({ modelYear: 2010 }).catch(error => error)\r\n * console.log(qs) // \"?modelYear=2010\"\r\n *\r\n * @example <caption>Single Param:</caption>\r\n * const qs = await makeQueryString({\r\n *   modelYear: 2019\r\n * }).catch(error => error)\r\n * console.log(qs) // \"?modelYear=2019\"\r\n *\r\n * @example <caption>Multiple Params:</caption>\r\n * const qs = await makeQueryString({\r\n *   whatever: 'some value',\r\n *   modelYear: 2006,\r\n *   page: \"2\"\r\n * }).catch(error => error)\r\n *\r\n * console.log(qs) // \"?whatever=some%20value&modelYear=2006&page=2\"\r\n *\r\n * @example <caption>Empty Params Object:</caption>\r\n * const qs = await makeQueryString({}).catch(error => error)\r\n *\r\n * console.log(qs) // \"\"\r\n *\r\n * @example <caption>Using allowEmptyStringValues option:</caption>\r\n * const qs = await makeQueryString({\r\n *   year: 2016,\r\n *   vehicleType: '',\r\n *   make: 'Audi'\r\n * }, true).catch(error => error)\r\n *\r\n * console.log(qs) // \"?year=2016&vehicleType=&make=Audi\"\r\n *\r\n */\r\nexport function makeQueryString(\r\n  params: import('./types').QueryStringParameters = {},\r\n  allowEmptyStringValues = false\r\n): Promise<string | Error> {\r\n  /* Beginning of error message string */\r\n  const errorBase =\r\n    'queryString(params) - expected params in the form of an object, got:';\r\n\r\n  /* Runtime type guard params argument, must be of type object */\r\n  if (Object.prototype.toString.call(params) !== '[object Object]') {\r\n    return Promise.reject(new Error(`${errorBase} ${params}`));\r\n  }\r\n\r\n  /* Setup QueryString for Array mapping */\r\n  const entries = Object.entries(params);\r\n  const paramsLength = entries.length;\r\n\r\n  /* Return an empty string if params are an empty object */\r\n  if (paramsLength < 1) return Promise.resolve('');\r\n\r\n  /* Used to check if we've already prepended a valid query param */\r\n  let isPrepended = false;\r\n\r\n  /* Map [key]:value entries to \"key=value\" strings in an array */\r\n  const queryStringArray = entries.map(([key, value], index) => {\r\n    let prepend = '';\r\n    let append = '';\r\n\r\n    const typeofValue = getTypeof(value);\r\n\r\n    /* Convert any number values to a string */\r\n    if (value && typeofValue === 'number') {\r\n      value = value.toString();\r\n    }\r\n\r\n    /* Skip any invalid values, only string and number value types are valid */\r\n    if (\r\n      (value || allowEmptyStringValues) &&\r\n      (typeofValue === 'string' || typeofValue === 'number')\r\n    ) {\r\n      /* if this is the first param we need to prepend the '?' char */\r\n      if (!isPrepended) {\r\n        prepend = '?';\r\n        isPrepended = true;\r\n      }\r\n      /* if there is another param coming after this one we need to append the '&' char */\r\n      if (index < paramsLength - 1) {\r\n        append = '&';\r\n      }\r\n\r\n      /* Add the completed partial query string to queryStringArray */\r\n      return `${prepend}${key}=${value}${append}`;\r\n    }\r\n    return;\r\n  });\r\n\r\n  /* Join and return the completed query string after URI encoding */\r\n  return Promise.resolve(encodeURI(queryStringArray.join('')));\r\n}\r\n","/**\r\n * @module api/Fetch\r\n */\r\n\r\n/* Module Dependencies */\r\nimport fetch from 'cross-fetch';\r\n/* Utilities */\r\nimport { getTypeof, makeQueryString } from '../utils';\r\n\r\n/**\r\n * @constant {string} BASE_URL Default Fetch base URL string\r\n * @default 'https://vpic.nhtsa.dot.gov/api/vehicles'\r\n */\r\nexport const BASE_URL = 'https://vpic.nhtsa.dot.gov/api/vehicles';\r\n\r\n/**\r\n * @constant {module:api/types.FetchConfig} DEFAULT_CONFIG Default Fetch configuration options\r\n * @property {string} apiResponseFormat=json\r\n * @property {string} baseUrl=BASE_URL\r\n */\r\nexport const DEFAULT_CONFIG: import('./types').FetchConfig = {\r\n  apiResponseFormat: 'json',\r\n  baseUrl: BASE_URL\r\n};\r\n\r\n/**\r\n * Class wrapper containing API wrapper HTTP Fetch logic.\r\n *\r\n * @param {module:api/types.FetchConfig} [userConfig] - User configuration options to construct the class with.\r\n */\r\nexport class Fetch {\r\n  apiResponseFormat?: string;\r\n  baseUrl?: string;\r\n  config?: import('./types').FetchConfig;\r\n\r\n  constructor(userConfig?: import('./types').FetchConfig) {\r\n    let finalConfig: import('./types').FetchConfig;\r\n\r\n    if (getTypeof(userConfig) === 'object') {\r\n      finalConfig = { ...DEFAULT_CONFIG, ...userConfig };\r\n    } else {\r\n      finalConfig = { ...DEFAULT_CONFIG };\r\n    }\r\n\r\n    /** @private */\r\n    this.apiResponseFormat = 'json';\r\n    /** @private */\r\n    this.baseUrl = finalConfig.baseUrl;\r\n    /** @private */\r\n    this.config = finalConfig;\r\n  }\r\n\r\n  /**\r\n   * Builds a query string from QueryStringParameters.\r\n   *\r\n   * @param {module:utils/types.QueryStringParameters} params - Object of query string search parameters.\r\n   * @param {boolean} [allowEmptyStringValues=false] - Allow empty query string parameters (as an empty string).\r\n   *\r\n   * @returns {(Promise<string | Error>)} A formatted NHSTA.dot.gov Vehicles API query string.\r\n   */\r\n  async buildQueryString(\r\n    params: import('../utils/types').QueryStringParameters,\r\n    allowEmptyStringValues = false\r\n  ): Promise<string | Error> {\r\n    /*\r\n     * Make sure we're always using 'format=json' in the url Query parameters\r\n     * If the user provides a 'format' key in the params, during class instantiation we want to override it to 'json'\r\n     * This package will never provide support for the other formats (CSV and XML)\r\n     */\r\n    if (!params || getTypeof(params) !== 'object') {\r\n      params = {\r\n        format: this.apiResponseFormat\r\n      };\r\n    } else {\r\n      params = { ...params, format: this.apiResponseFormat };\r\n    }\r\n\r\n    /* Return the completed query string */\r\n    return await makeQueryString(params, allowEmptyStringValues);\r\n  }\r\n\r\n  /**\r\n   * Uses the `cross-fetch` npm package to send HTTP requests and retrieve data from an API.\r\n   *\r\n   * @param {string} url - URL to fetch data from.\r\n   *\r\n   * @returns {(Promise<module:api/types.ApiResponse | Error>)} Response from the API.\r\n   */\r\n  async get(url: string): Promise<import('./types').ApiResponse | Error> {\r\n    if (getTypeof(url) !== 'string') {\r\n      return Promise.reject(\r\n        new Error('Fetch.get(url) - url argument must be of type string')\r\n      );\r\n    }\r\n\r\n    /* Use the cross-fetch package to perform an HTTP get request */\r\n    const response: Response = await fetch(url)\r\n      .then(result => {\r\n        if (!result?.status || result.status >= 400) {\r\n          throw new Error(\r\n            `Bad response from server, code: ${result?.status}, text: ${result?.statusText}, headers: ${result?.headers}`\r\n          );\r\n        } else return result;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`Fetch.get() http error: ${err}`))\r\n      );\r\n\r\n    /* Convert the NHTSA API data to JSON */\r\n    const json: import('./types').NhtsaResponse = await response.json();\r\n\r\n    /* Add the fetch response information to the returned NHSTA API data */\r\n    const finalResult: import('./types').ApiResponse = {\r\n      ...json,\r\n      Response: {\r\n        headers: response.headers,\r\n        ok: response.ok,\r\n        redirected: response.redirected,\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        url: response.url\r\n      }\r\n    };\r\n\r\n    /* Return the completed ApiResponse */\r\n    return Promise.resolve(finalResult);\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class DecodeVin\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class DecodeVin extends Fetch {\r\n  /**\r\n   * The DecodeVin API Action will decode the VIN and the decoded output will be made available in the format of Key-value pairs.\r\n   * - The IDs (VariableID and ValueID) represent the unique ID associated with the Variable/Value.\r\n   *   - In case of text variables, the ValueID is not applicable.\r\n   * - Providing `params.modelYear` allows for the decoding to specifically be done in the current,\r\n   *   or older (pre-1980), model year ranges.\r\n   *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding.\r\n   * - This API also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   *   - In this case, the VIN will be decoded partially with the available characters.\r\n   *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   *   - The 9th digit is not necessary.\r\n   *\r\n   * @async\r\n   * @memberof DecodeVin\r\n   *\r\n   * @param {string} vin Vehicle Identification Number (full or partial)\r\n   * @param {object} params={} Query Search Parameters to append to the URL\r\n   * @param {string|number} [params.modelYear] - Optional Model Year search parameter\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async DecodeVin(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'DecodeVin';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class DecodeVinExtended\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class DecodeVinExtended extends Fetch {\r\n  /**\r\n   * This is exactly like the DecodeVin method but provides additional information on variables\r\n   *   related to other NHTSA programs like NCSA etc.\r\n   * - This will decode the VIN and the decoded output will be made available\r\n   *   in the format of Key-value pairs.\r\n   * - In the returned 'Results` object:\r\n   *   - The IDs (VariableID and ValueID) represent the unique ID associated with the Variable/Value.\r\n   *   - In case of text variables, the ValueID is not applicable.\r\n   * - Providing `params.modelYear` allows for the decoding to specifically be done in the current,\r\n   *   or older (pre-1980), model year ranges.\r\n   *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding.\r\n   * - This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   *   - In this case, the VIN will be decoded partially with the available characters.\r\n   *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   *   - The 9th digit is not necessary.\r\n   *\r\n   * @async\r\n   * @memberof DecodeVinExtended\r\n   *\r\n   * @param {string} vin Vehicle Identification Number (full or partial)\r\n   * @param {object} params={} Query Search Parameters to append to the URL\r\n   * @param {string|number} [params.modelYear] - Optional Model Year search parameter\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async DecodeVinExtended(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'DecodeVinExtended';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class DecodeVinValues\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class DecodeVinValues extends Fetch {\r\n  /**\r\n   * The DecodeVinValues API Action will decode the VIN and the decoded output will be made available in a flat file format.\r\n   * - Providing params.modelYear allows for the decoding to specifically be done in the current,\r\n   *   or older (pre-1980), model year ranges.\r\n   *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding.\r\n   * - This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   *   - In this case, the VIN will be decoded partially with the available characters.\r\n   *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   *\r\n   * @async\r\n   * @memberof DecodeVinValues\r\n   *\r\n   * @param {string} vin Vehicle Identification Number (full or partial)\r\n   * @param {object} params={} Query Search Parameters to append to the URL\r\n   * @param {string|number} [params.modelYear] - Optional Model Year search parameter\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async DecodeVinValues(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'DecodeVinValues';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class DecodeVinValuesExtended\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class DecodeVinValuesExtended extends Fetch {\r\n  /**\r\n   * This is exactly like the DecodeVinValues (flat format) method but provides additional information\r\n   * on variables related to other NHTSA programs like NCSA etc.\r\n   * - This will decode the VIN and the decoded output will be made available in a flat file format.\r\n   * - Providing `params.modelYear` allows for the decoding to specifically be done in the current,\r\n   *   or older (pre-1980), model year ranges.\r\n   *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding.\r\n   * - This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   *   - In this case, the VIN will be decoded partially with the available characters.\r\n   *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   *\r\n   * @async\r\n   * @memberof DecodeVinValuesExtended\r\n   *\r\n   * @param {string} vin Vehicle Identification Number (full or partial)\r\n   * @param {object} params={} Query Search Parameters to append to the URL\r\n   * @param {string|number} [params.modelYear] - Optional Model Year search parameter\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async DecodeVinValuesExtended(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'DecodeVinValuesExtended';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class DecodeWMI\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class DecodeWMI extends Fetch {\r\n  /**\r\n   * This provides information on the World Manufacturer Identifier for a specific WMI code.\r\n   * - `WMI` may be put in as either 3 characters representing VIN position 1-3 or 6 characters\r\n   *   representing VIN positions 1-3 & 12-14. Example \"JTD\", \"1T9131\".\r\n   *\r\n   * @async\r\n   * @memberof DecodeWMI\r\n   *\r\n   * @param {string} WMI World Manufacturer Identifier\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async DecodeWMI(\r\n    WMI: string\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'DecodeWMI';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(WMI) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, WMI argument is required and must be a string, got: ${WMI}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${WMI}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetAllMakes\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetAllMakes extends Fetch {\r\n  /**\r\n   * This provides a list of all the Makes available in the vPIC Dataset.\r\n   *\r\n   * @async\r\n   * @memberof GetAllMakes\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  public async GetAllMakes(): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetAllMakes';\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetAllManufacturers\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetAllManufacturers extends Fetch {\r\n  /**\r\n   * This provides a list of all the Manufacturers available in vPIC Dataset.\r\n   * - `params.manufacturerType` allows the user to filter the list based on manufacturer type,\r\n   *   ('Incomplete Vehicles', 'Completed Vehicle Manufacturer', 'Incomplete Vehicle Manufacturer',\r\n   *   'Intermediate Manufacturer', 'Final-Stage Manufacturer', 'Alterer', or any partial match of those strings).\r\n   * - You can get a list of all manufacturer types with the following API Action:\r\n   *   `GetVehicleVariableValuesList('manufacturer type')`\r\n   * - Results are provided in pages of 100 items.\r\n   * - Provide a number value for params.page to specify 1st (default), 2nd, 3rd, Nth, etc page.\r\n   *\r\n   * @async\r\n   * @memberof GetAllManufacturers\r\n   *\r\n   * @param {object} params={} Query Search Parameters to append to the URL\r\n   * @param {string} [params.manufacturerType] see method description\r\n   * @param {string|number} [params.page] Specify the page number (results returned 100 at a time)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetAllManufacturers(\r\n    params: {\r\n      manufacturerType?: string;\r\n      page?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetAllManufacturers';\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetCanadianVehicleSpecifications\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetCanadianVehicleSpecifications extends Fetch {\r\n  /**\r\n   * This returns the Models in the vPIC dataset for a specified Model Year and Make whose name is LIKE the Make in vPIC Dataset.\r\n   * - `params.year` is the only query parameter the user must provide.\r\n   * - `params.makeId` is a number\r\n   * - `params.modelYear` is a number (greater than 1995)\r\n   * - `params.vehicleType` can be a partial name, or a full name for more specificity\r\n   *   (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.)\r\n   * This API action will return a 404 html error if any of the query parameters in params\r\n   *   are missing from the query string. This is the only API action with this behaviour. Therefore,\r\n   *   parameters are inserted into the query string as empty strings, if not provided by the user.\r\n   *\r\n   * @async\r\n   * @memberof GetCanadianVehicleSpecifications\r\n   *\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {number} params.year Model year of the vehicle (required) - Number, >= 1971\r\n   * @param {string} [params.make] Vehicle's make, like \"Honda\", \"Toyota\", etc...\r\n   * @param {string} [params.model] Vehicle's model, like \"Pilot\", \"Focus\". Can also include some other elements like Body Type, Engine Model/size, etc...\r\n   * @param {string} [params.units] \"Metric\" (default), or \"US\" for United States customary units\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetCanadianVehicleSpecifications(\r\n    params: {\r\n      year: number;\r\n      make?: string;\r\n      model?: string;\r\n      units?: string;\r\n    } = {\r\n      year: undefined as any\r\n    }\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetCanadianVehicleSpecifications';\r\n\r\n    /* Runtime gatekeeping */\r\n    if (!params.year) {\r\n      return Promise.reject(\r\n        new Error(`${action}, params.year is required, got: ${params.year}`)\r\n      );\r\n    }\r\n\r\n    /* Set default query parameters to empty strings if not provided by the user */\r\n    if (!params.make) params.make = '';\r\n    if (!params.model) params.model = '';\r\n    if (!params.units) params.units = '';\r\n\r\n    /*\r\n     * Build the 'default' query string to be appended to the URL\r\n     * Additionally, set the allowEmptyStringValues option (2nd argument) to true\r\n     * This API action will return a 404 error if any of the query parameters in params\r\n     * are missing from the query string. This is the only API action with this behaviour.\r\n     * \"year\" is the only param the user must provide.\r\n     */\r\n    const queryString = await this.buildQueryString(\r\n      params,\r\n      true\r\n    ).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetEquipmentPlantCodes\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetEquipmentPlantCodes extends Fetch {\r\n  /**\r\n   * Returns assigned Equipment Plant Codes. Can be filtered by Year, Equipment Type and Report Type.\r\n   * - `params.year`:\r\n   *   - Only years >= 2016 are supported\r\n   * - `params.equipmentType`:\r\n   *   - 1 (Tires)\r\n   *   - 3 (Brake Hoses)\r\n   *   - 13 (Glazing)\r\n   *   - 16 (Retread)\r\n   * - `params.reportType`:\r\n   *   - 'New' (The Equipment Plant Code was assigned during the selected year)\r\n   *   - 'Updated' (The Equipment Plant data was modified during the selected year)\r\n   *   - 'Closed' (The Equipment Plant is no longer Active)\r\n   *   - 'All' (All Equipment Plant Codes regardless of year, including their status (active or closed))\r\n   *\r\n   * @async\r\n   * @memberof GetEquipmentPlantCodes\r\n   *\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {number} params.year Model year of the vehicle - Number, >= 2016\r\n   * @param {string} params.equipmentType number equal to 1, 3, 13, or 16\r\n   * @param {string} params.reportType 'New', 'Updated', 'Closed', or 'All'\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  public async GetEquipmentPlantCodes(\r\n    params: {\r\n      year: number;\r\n      equipmentType: 1 | 3 | 13 | 16;\r\n      reportType: 'New' | 'Updated' | 'Closed' | 'All';\r\n    } = {\r\n      year: undefined as any,\r\n      equipmentType: undefined as any,\r\n      reportType: undefined as any\r\n    }\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetEquipmentPlantCodes';\r\n\r\n    /* Runtime typechecking params*/\r\n    if (!params.year) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, \"year\" parameter is required, got: ${params.year}`\r\n        )\r\n      );\r\n    }\r\n    if (!params.equipmentType) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, \"equipmentType\" parameter is required, got: ${params.equipmentType}`\r\n        )\r\n      );\r\n    }\r\n    if (!params.reportType) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, \"reportType\" parameter is required, got: ${params.reportType}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetMakeForManufacturer\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetMakeForManufacturer extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified manufacturer that is requested.\r\n   * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id.\r\n   * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the provided name\r\n   *   (it accepts a partial manufacturer name as an input).\r\n   * - Mnufacturer name can be a partial name, or a full name for more specificity\r\n   *   (e.g., \"988\", \"HONDA\", \"HONDA OF CANADA MFG., INC.\", etc.)\r\n   * - Multiple results are returned in case of multiple matches.\r\n   *\r\n   * @async\r\n   * @memberof GetMakeForManufacturer\r\n   *\r\n   * @param {string|number} manufacturer Manufacturer Name (string) or Manufacturer ID (number)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetMakeForManufacturer(\r\n    manufacturer: string | number\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetMakeForManufacturer';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string or number, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetMakesForManufacturerAndYear\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetMakesForManufacturerAndYear extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified manufacturer,\r\n   * and whose Year From and Year To range cover the specified year.\r\n   * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id.\r\n   * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the provided name\r\n   *   (it accepts a partial manufacturer name as an input).\r\n   * - Multiple results are returned in case of multiple matches.\r\n   * - Manufacturer can be idenfitied by Id, a partial name, or a full name\r\n   *   (e.g., \"988\", \"HONDA\", \"HONDA OF CANADA MFG., INC.\", etc.)\r\n   *\r\n   * @async\r\n   * @memberof GetMakesForManufacturerAndYear\r\n   *\r\n   * @param {string|number} manufacturer Manufacturer Name (string) or Manufacturer ID (number)\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {string|number} params.year Model year of the vehicle - Number, >= 2016\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  public async GetMakesForManufacturerAndYear(\r\n    manufacturer: string | number,\r\n    params: {\r\n      year: string | number;\r\n    } = { year: undefined as any }\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetMakesForManufacturerAndYear';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, please provide a valid manufacturer arg, either a number or string, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n    if (!params.year) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, please provide a valid year parameter, either a number or string, got params.year: ${params.year}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetMakesForVehicleType\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetMakesForVehicleType extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified vehicle type,\r\n   * whose name is LIKE the vehicle type name in vPIC Dataset.\r\n   * - Vehicle `typeName` can be a partial name, or a full name for more specificity\r\n   *   (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.).\r\n   *\r\n   * @async\r\n   * @memberof GetMakesForVehicleType\r\n   *\r\n   * @param {string} typeName A partial or full vehicle type name\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetMakesForVehicleType(\r\n    typeName: string\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetMakesForVehicleType';\r\n\r\n    if (getTypeof(typeName) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, typeName is required and must be a string, got: ${typeName}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${typeName}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetManufacturerDetails\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetManufacturerDetails extends Fetch {\r\n  /**\r\n   * This provides the details for a specific manufacturer that is requested.\r\n   * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id.\r\n   * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the provided name,\r\n   *   (it accepts a partial manufacturer name as an input).\r\n   * - Multiple results are returned in case of multiple matches.\r\n   *\r\n   * @async\r\n   * @memberof GetManufacturerDetails\r\n   *\r\n   * @param {string|number} manufacturer Manufacturer Name (string) or Manufacturer ID (number)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  public async GetManufacturerDetails(\r\n    manufacturer: string | number\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetManufacturerDetails';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string or number, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetModelsForMake\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetModelsForMake extends Fetch {\r\n  /**\r\n   * This returns the Models in the vPIC dataset for a specified Make whose name is LIKE the Make in vPIC Dataset.\r\n   * - `makeName` can be a partial, or a full for more specificity (e.g., \"Harley\", \"Harley Davidson\", etc.)\r\n   *\r\n   * @async\r\n   * @memberof GetModelsForMake\r\n   *\r\n   * @param {string} makeName Vehicle make name (string)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetModelsForMake(\r\n    makeName: string\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetModelsForMake';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeName) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeName is required and must be a string, got: ${makeName}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${makeName}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetModelsForMakeId\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetModelsForMakeId extends Fetch {\r\n  /**\r\n   * This returns the Models in the vPIC dataset for a specified Make whose Id is EQUAL the MakeId in vPIC Dataset.\r\n   *\r\n   * @async\r\n   * @memberof GetModelsForMakeId\r\n   *\r\n   * @param {number} makeID Vehicle make ID (number)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetModelsForMakeId(\r\n    makeID: number\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetModelsForMakeId';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeID) !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeID is required and must be a number, got: ${makeID}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${makeID}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetModelsForMakeIdYear\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetModelsForMakeIdYear extends Fetch {\r\n  /**\r\n   * This returns the Models in the vPIC dataset for a specified Model Year and Make whose name is LIKE the Make in vPIC Dataset.\r\n   *   - `params.makeId` is a number and is a required query parameter\r\n   *\r\n   * A minimum of one of the following are required (or a combination of both):\r\n   *   - `params.modelYear` is a number (greater than 1995)\r\n   *   - `params.vehicleType` can be a partial name, or a full name for more specificity\r\n   *     (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.)\r\n   *\r\n   * @async\r\n   * @memberof GetModelsForMakeIdYear\r\n   *\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {number} params.makeId Make ID to search\r\n   * @param {number} [params.modelYear] A number representing the model year to search (greater than 1995)\r\n   * @param {string} [params.vehicleType] String representing the vehicle type to search\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetModelsForMakeIdYear(\r\n    params: {\r\n      makeId: number;\r\n      modelYear?: number;\r\n      vehicleType?: string;\r\n    } = {\r\n      makeId: undefined as any\r\n    }\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetModelsForMakeIdYear';\r\n\r\n    /* Required makeId param of type number */\r\n    const typeofMakeId = getTypeof(params.makeId);\r\n    if (!params.makeId || typeofMakeId !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.makeId is required and must be a string, got: ${params.makeId} of type ${typeofMakeId}`\r\n        )\r\n      );\r\n    }\r\n    /* At least one of modelYear or vehicleType params is required */\r\n    if (!params.modelYear && !params.vehicleType) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, one of or both of, params.modelYear or params.vehicleType is required, got params: ${params}`\r\n        )\r\n      );\r\n    }\r\n    /* valid modelYear param of type number */\r\n    const typeofModelYear = getTypeof(params.modelYear);\r\n    if (params.modelYear && typeofModelYear !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.modelYear must be of type number, got type of: ${typeofModelYear}`\r\n        )\r\n      );\r\n    }\r\n    /* valid vehicleType param of type string */\r\n    const typeofVehicleType = getTypeof(params.vehicleType);\r\n    if (params.vehicleType && getTypeof(params.vehicleType) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.vehicleType must be of type string, got type of: ${typeofVehicleType}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the actionUrl */\r\n    let actionUrl = `${action}/makeId/${params.makeId}/`;\r\n\r\n    /* Append params.modelYear and params.vehicleType to the URL, at least one is required by the API */\r\n    if (params.modelYear && params.vehicleType) {\r\n      actionUrl += `modelYear/${params.modelYear}/vehicleType/${params.vehicleType}`;\r\n    } else if (params.modelYear) {\r\n      actionUrl += `modelYear/${params.modelYear}`;\r\n    } else {\r\n      actionUrl += `vehicleType/${params.vehicleType}`;\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${actionUrl}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetModelsForMakeYear\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetModelsForMakeYear extends Fetch {\r\n  /**\r\n   * This returns the Models in the vPIC dataset for a specified Model Year and Make whose name is LIKE the Make in vPIC Dataset.\r\n   *   - `params.make` can be a partial, or a full for more specificity\r\n   *     (e.g., \"Harley\", \"Harley Davidson\", etc.)\r\n   *\r\n   * A minimum of one of the following are required (or a combination of both):\r\n   *   - `params.modelYear` is a number (greater than 1995)\r\n   *   - `params.vehicleType` can be a partial name, or a full name for more specificity\r\n   *     (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.)\r\n   *\r\n   * @async\r\n   * @memberof GetModelsForMakeYear\r\n   *\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {string} params.make Make name to search\r\n   * @param {number} [params.modelYear] A number representing the model year to search (greater than 1995)\r\n   * @param {string} [params.vehicleType] String representing the vehicle type to search\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetModelsForMakeYear(\r\n    params: {\r\n      make: string;\r\n      modelYear?: number;\r\n      vehicleType?: string;\r\n    } = {\r\n      make: undefined as any\r\n    }\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetModelsForMakeYear';\r\n\r\n    /* Required make param of type string */\r\n    const typeofMake = getTypeof(params.make);\r\n    if (!params.make || typeofMake !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.make is required and must be a string, got: ${params.make} of type ${typeofMake}`\r\n        )\r\n      );\r\n    }\r\n    /* At least one of modelYear or vehicleType params is required */\r\n    if (!params.modelYear && !params.vehicleType) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, one of or both of, params.modelYear or params.vehicleType is required, got params: ${params}`\r\n        )\r\n      );\r\n    }\r\n    /* valid modelYear param of type number */\r\n    const typeofModelYear = getTypeof(params.modelYear);\r\n    if (params.modelYear && typeofModelYear !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.modelYear must be of type number, got type of: ${typeofModelYear}`\r\n        )\r\n      );\r\n    }\r\n    /* valid vehicleType param of type string */\r\n    const typeofVehicleType = getTypeof(params.vehicleType);\r\n    if (params.vehicleType && getTypeof(params.vehicleType) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.vehicleType must be of type string, got type of: ${typeofVehicleType}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the actionUrl */\r\n    let actionUrl = `${action}/make/${params.make}/`;\r\n\r\n    /* Append params.modelYear and params.vehicleType to the URL, at least one is required by the API */\r\n    if (params.modelYear && params.vehicleType) {\r\n      actionUrl += `modelYear/${params.modelYear}/vehicleType/${params.vehicleType}`;\r\n    } else if (params.modelYear) {\r\n      actionUrl += `modelYear/${params.modelYear}`;\r\n    } else {\r\n      actionUrl += `vehicleType/${params.vehicleType}`;\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${actionUrl}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetParts\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetParts extends Fetch {\r\n  /**\r\n   * This provides a list of ORGs with letter date in the given range of the dates and with specified `params.type` of ORG.\r\n   * - Up to 1000 results will be returned at a time.\r\n   * - Get the next page by incrementing the `params.page` query parameter.\r\n   * - All query `params` are optional.\r\n   *\r\n   * @async\r\n   * @memberof GetParts\r\n   *\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {string|number} [params.type] Specified type of ORG to search\r\n   * @param {string} [params.fromDate] Start date of search query\r\n   * @param {string} [params.toDate] End date of search query\r\n   * @param {string|number} [params.page] Page number of results to request (100 results per page)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetParts(\r\n    params: {\r\n      type?: string | number;\r\n      fromDate?: string;\r\n      toDate?: string;\r\n      page?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetParts';\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetVehicleTypesForMake\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetVehicleTypesForMake extends Fetch {\r\n  /**\r\n   * This returns all the Vehicle Types in the vPIC dataset for a specified Make, whose name is LIKE the make name in vPIC Dataset.\r\n   * - `makeName` can be a partial name, or a full name for more specificity\r\n   *   (e.g., \"Merc\", \"Mercedes Benz\", etc.).\r\n   *\r\n   * @async\r\n   * @memberof GetVehicleTypesForMake\r\n   *\r\n   * @param {string} makeName Name of the vehicle make to search\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetVehicleTypesForMake(\r\n    makeName: string\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetVehicleTypesForMake';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeName) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeName is required and must be a string, got: ${makeName}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${makeName}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetVehicleTypesForMakeId\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetVehicleTypesForMakeId extends Fetch {\r\n  /**\r\n   * This returns all the Vehicle Types in the vPIC dataset for a specified Make whose ID equals the make ID in vPIC Dataset.\r\n   *\r\n   * @async\r\n   * @memberof GetVehicleTypesForMakeId\r\n   *\r\n   * @param {number} makeID Vehicle make ID\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetVehicleTypesForMakeId(\r\n    makeID: number\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetVehicleTypesForMakeId';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeID) !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeID is required and must be a number, got: ${makeID}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${makeID}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetVehicleVariableList\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetVehicleVariableList extends Fetch {\r\n  /**\r\n   * This provides a list of all the Vehicle related variables that are in vPIC dataset.\r\n   * - Information on the name, description and the type of the variable is provided.\r\n   *\r\n   * @async\r\n   * @memberof GetVehicleVariableList\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  public async GetVehicleVariableList(): Promise<\r\n    import('../types').ApiResponse | Error\r\n  > {\r\n    const action = 'GetVehicleVariableList';\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetVehicleVariableValuesList\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetVehicleVariableValuesList extends Fetch {\r\n  /**\r\n   * This provides a list of all the accepted values for a given variable that are stored in vPIC dataset.\r\n   *\r\n   * This applies to only \"Look up\" type of variables.\r\n   * - `variableValue` can either be a:\r\n   *   - Variable Name (\"battery type\" in first example, please use full name, not just part of it),\r\n   *   - or Variable ID (\"2\" in second example).\r\n   *\r\n   * @async\r\n   * @memberof GetVehicleVariableValuesList\r\n   *\r\n   * @param {string|number} variableValue The variable you want to get a values list of\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetVehicleVariableValuesList(\r\n    variableValue: string | number\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetVehicleVariableValuesList';\r\n\r\n    /* Runtime typechecking */\r\n    if (!variableValue) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, variableValue is required and must be a string or number, got: ${variableValue}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${variableValue}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetWMIsForManufacturer\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetWMIsForManufacturer extends Fetch {\r\n  /**\r\n   * Provides information on the all World Manufacturer Identifier (WMI) for a specified `manufacturer`.\r\n   * - Only WMIs registered in vPICList are displayed.\r\n   *\r\n   * @async\r\n   * @memberof GetWMIsForManufacturer\r\n   *\r\n   * @param {string|number} manufacturer Manufacturer Name (string) or Manufacturer ID (number)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetWMIsForManufacturer(\r\n    manufacturer: string\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetWMIsForManufacturer';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(manufacturer) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from './Fetch';\r\n\r\n/* API Actions */\r\nimport {\r\n  DecodeVin,\r\n  DecodeVinValues,\r\n  DecodeVinExtended,\r\n  DecodeVinValuesExtended,\r\n  DecodeWMI,\r\n  GetWMIsForManufacturer,\r\n  GetAllMakes,\r\n  GetParts,\r\n  GetAllManufacturers,\r\n  GetManufacturerDetails,\r\n  GetMakeForManufacturer,\r\n  GetMakesForManufacturerAndYear,\r\n  GetMakesForVehicleType,\r\n  GetVehicleTypesForMake,\r\n  GetVehicleTypesForMakeId,\r\n  GetEquipmentPlantCodes,\r\n  GetModelsForMake,\r\n  GetModelsForMakeId,\r\n  GetModelsForMakeYear,\r\n  GetModelsForMakeIdYear,\r\n  GetVehicleVariableList,\r\n  GetVehicleVariableValuesList,\r\n  GetCanadianVehicleSpecifications\r\n} from './actions';\r\n\r\n/**\r\n * @class NHTSA\r\n *\r\n * @augments {Fetch}\r\n *\r\n * @implements {DecodeVin}\r\n * @implements {DecodeVinExtended}\r\n * @implements {DecodeVinValues}\r\n * @implements {DecodeVinValuesExtended}\r\n * @implements {DecodeWMI}\r\n * @implements {GetAllMakes}\r\n * @implements {GetAllManufacturers}\r\n * @implements {GetCanadianVehicleSpecifications}\r\n * @implements {GetEquipmentPlantCodes}\r\n * @implements {GetMakeForManufacturer}\r\n * @implements {GetMakesForManufacturerAndYear}\r\n * @implements {GetMakesForVehicleType}\r\n * @implements {GetManufacturerDetails}\r\n * @implements {GetModelsForMake}\r\n * @implements {GetModelsForMakeId}\r\n * @implements {GetModelsForMakeIdYear}\r\n * @implements {GetModelsForMakeYear}\r\n * @implements {GetParts}\r\n * @implements {GetVehicleTypesForMake}\r\n * @implements {GetVehicleTypesForMakeId}\r\n * @implements {GetVehicleVariableList}\r\n * @implements {GetVehicleVariableValuesList}\r\n * @implements {GetWMIsForManufacturer}\r\n */\r\nclass NHTSA extends Fetch\r\n  implements\r\n    DecodeVin,\r\n    DecodeVinExtended,\r\n    DecodeVinValues,\r\n    DecodeVinValuesExtended,\r\n    DecodeWMI,\r\n    GetAllMakes,\r\n    GetAllManufacturers,\r\n    GetCanadianVehicleSpecifications,\r\n    GetEquipmentPlantCodes,\r\n    GetMakeForManufacturer,\r\n    GetMakesForManufacturerAndYear,\r\n    GetMakesForVehicleType,\r\n    GetManufacturerDetails,\r\n    GetModelsForMake,\r\n    GetModelsForMakeId,\r\n    GetModelsForMakeIdYear,\r\n    GetModelsForMakeYear,\r\n    GetParts,\r\n    GetVehicleTypesForMake,\r\n    GetVehicleTypesForMakeId,\r\n    GetVehicleVariableList,\r\n    GetVehicleVariableValuesList,\r\n    GetWMIsForManufacturer {\r\n  constructor(userConfig?: import('./types').FetchConfig) {\r\n    super(userConfig);\r\n  }\r\n\r\n  DecodeVin = DecodeVin.prototype.DecodeVin;\r\n\r\n  DecodeVinValues = DecodeVinValues.prototype.DecodeVinValues;\r\n\r\n  DecodeVinExtended = DecodeVinExtended.prototype.DecodeVinExtended;\r\n\r\n  DecodeVinValuesExtended =\r\n    DecodeVinValuesExtended.prototype.DecodeVinValuesExtended;\r\n\r\n  DecodeWMI = DecodeWMI.prototype.DecodeWMI;\r\n\r\n  GetAllMakes = GetAllMakes.prototype.GetAllMakes;\r\n\r\n  GetAllManufacturers = GetAllManufacturers.prototype.GetAllManufacturers;\r\n\r\n  GetCanadianVehicleSpecifications =\r\n    GetCanadianVehicleSpecifications.prototype.GetCanadianVehicleSpecifications;\r\n\r\n  GetEquipmentPlantCodes =\r\n    GetEquipmentPlantCodes.prototype.GetEquipmentPlantCodes;\r\n\r\n  GetMakeForManufacturer =\r\n    GetMakeForManufacturer.prototype.GetMakeForManufacturer;\r\n\r\n  GetMakesForManufacturerAndYear =\r\n    GetMakesForManufacturerAndYear.prototype.GetMakesForManufacturerAndYear;\r\n\r\n  GetMakesForVehicleType =\r\n    GetMakesForVehicleType.prototype.GetMakesForVehicleType;\r\n\r\n  GetManufacturerDetails =\r\n    GetManufacturerDetails.prototype.GetManufacturerDetails;\r\n\r\n  GetModelsForMake = GetModelsForMake.prototype.GetModelsForMake;\r\n\r\n  GetModelsForMakeId = GetModelsForMakeId.prototype.GetModelsForMakeId;\r\n\r\n  GetModelsForMakeIdYear =\r\n    GetModelsForMakeIdYear.prototype.GetModelsForMakeIdYear;\r\n\r\n  GetModelsForMakeYear = GetModelsForMakeYear.prototype.GetModelsForMakeYear;\r\n\r\n  GetParts = GetParts.prototype.GetParts;\r\n\r\n  GetVehicleTypesForMake =\r\n    GetVehicleTypesForMake.prototype.GetVehicleTypesForMake;\r\n\r\n  GetVehicleTypesForMakeId =\r\n    GetVehicleTypesForMakeId.prototype.GetVehicleTypesForMakeId;\r\n\r\n  GetVehicleVariableList =\r\n    GetVehicleVariableList.prototype.GetVehicleVariableList;\r\n\r\n  GetVehicleVariableValuesList =\r\n    GetVehicleVariableValuesList.prototype.GetVehicleVariableValuesList;\r\n\r\n  GetWMIsForManufacturer =\r\n    GetWMIsForManufacturer.prototype.GetWMIsForManufacturer;\r\n}\r\n\r\nexport { NHTSA };\r\n\r\nexport const Client = new NHTSA();\r\n","/**\r\n * @module utils/isValidVin\r\n * @category Utils\r\n */\r\n\r\n/**\r\n * Provides **offline** validation of Vehicle Identification Numbers (VINs) using the\r\n * [VIN Check Algorithm](https://en.wikibooks.org/wiki/Vehicle_Identification_Numbers_(VIN_codes)/Check_digit).\r\n *\r\n * @param {string} vin - Vehicle Identification Number.\r\n *\r\n * @returns {Promise<boolean>} True for a valid VIN, false for an invalid VIN.\r\n *\r\n * @example <caption>When loaded from the browser via html script tags</caption>\r\n * // <script type=\"text/javascript\" src=\"https://www.npmjs.com/package/@shaggytools/nhtsa-api-wrapper\"></script>\r\n * const isValid = await NHTSA.isValidVin('3VWD07AJ5EM388202').catch(error => error)\r\n * console.log(isValid) // true\r\n *\r\n * @example <caption>When loaded as a module</caption>\r\n * import { isValidVin } from '@shaggytools/nhtsa-api-wrapper'\r\n * const isValid = await isValidVin('3VWD07AJ5EM388202').catch(error => error)\r\n * console.log(isValid) // true\r\n *\r\n */\r\nexport async function isValidVin(vin: string): Promise<boolean> {\r\n  /* A valid VIN must be a string and is always exactly 17 digits */\r\n  if (typeof vin !== 'string' || vin.length != 17) {\r\n    return Promise.resolve(false);\r\n  }\r\n\r\n  /* Normalize the vin to all uppercase letters */\r\n  vin = vin.toUpperCase();\r\n\r\n  /* split the vin digits into an array */\r\n  const vinArray: string[] = vin.split('');\r\n\r\n  /* checkDigit will be tested against the checkSum later */\r\n  const checkDigit: string = vinArray[8];\r\n\r\n  /*\r\n   * In a valid VIN, the checkDigit can either be:\r\n   * a number, 0-9 inclusive OR the character 'X'\r\n   */\r\n  if (isNaN(parseInt(checkDigit)) && checkDigit !== 'X') {\r\n    return Promise.resolve(false);\r\n  }\r\n\r\n  /*\r\n   * The checkValue must be a digit and 'X' is the only valid alphabetic check value.\r\n   * As per the algorithm, a checkDigit of 'X' is equal to a checkValue of `10` and needs\r\n   * to be converted as such.\r\n   */\r\n  const checkValue: number = checkDigit === 'X' ? 10 : parseInt(checkDigit);\r\n\r\n  /*\r\n   * There will need to be some way to translate vin digits that are alphabetic\r\n   * into their number value in the VIN algorithm transliteration table.\r\n   * Later, during the creation of the checkusm variable, those digits will be\r\n   * multiplied against their corresponding weight (by index) in the weightsArray.\r\n   * This transliteration table is a key part of the VIN validation algorithm.\r\n   */\r\n  const transliterationTable: object = {\r\n    A: 1,\r\n    B: 2,\r\n    C: 3,\r\n    D: 4,\r\n    E: 5,\r\n    F: 6,\r\n    G: 7,\r\n    H: 8,\r\n    J: 1,\r\n    K: 2,\r\n    L: 3,\r\n    M: 4,\r\n    N: 5,\r\n    P: 7,\r\n    R: 9,\r\n    S: 2,\r\n    T: 3,\r\n    U: 4,\r\n    V: 5,\r\n    W: 6,\r\n    X: 7,\r\n    Y: 8,\r\n    Z: 9\r\n  };\r\n\r\n  /*\r\n   * Later, during the creation of the 'checksum' variable, these weights will be\r\n   * multilplied by the value of their mirrored index vin digits.\r\n   * The array index of each weight corresponds to the same index of each\r\n   * digit in the 'vin'.\r\n   */\r\n  const weightsArray: number[] = [\r\n    8,\r\n    7,\r\n    6,\r\n    5,\r\n    4,\r\n    3,\r\n    2,\r\n    10,\r\n    0,\r\n    9,\r\n    8,\r\n    7,\r\n    6,\r\n    5,\r\n    4,\r\n    3,\r\n    2\r\n  ];\r\n\r\n  /*\r\n   * Maps the vinArray and converts any values (digits) that are alphabetic,\r\n   * into numbers, using the above transliteration table.\r\n   * Then these numbers are multiplied against their corresponding weight\r\n   * in the weights array, matched by index position.\r\n   * All 17 of those digitValues are then added together and divided by 11.\r\n   * The remainder, or % modulo, of that division will be the final 'checksum'.\r\n   */\r\n  const checksum: number =\r\n    vinArray\r\n      .map((digit: string, index: number) => {\r\n        let digitValue: number;\r\n        /* Use the transliteration table to convert any Not a Number(NaN) values to numbers */\r\n        isNaN(parseInt(digit))\r\n          ? (digitValue = transliterationTable[digit])\r\n          : (digitValue = parseInt(digit));\r\n\r\n        /* Convert the digitValue to a weighted number corresponding to it's position, by index, in the weightsArray. */\r\n        const weight: number = weightsArray[index];\r\n\r\n        /* The final step for each digit is to multiply it by it's corresponding weight */\r\n        return digitValue * weight;\r\n      })\r\n      /* Then get the sum of all digits and divide by 11, the remainder of that operation is the checksum */\r\n      .reduce((acc, currValue) => acc + currValue, 0) % 11;\r\n\r\n  /*\r\n   * The checksum is compared against the checkValue we set earlier (the 9th digit of the VIN)\r\n   * As per the algorithm, if they are equal to each other, then the VIN must be valid and\r\n   * we return true, otherwise the VIN is invalid and we return false.\r\n   */\r\n  return Promise.resolve(checksum === checkValue);\r\n}\r\n"],"names":["getTypeof","value","toString","Object","prototype","call","toLowerCase","slice","length","makeQueryString","params","allowEmptyStringValues","Promise","reject","Error","errorBase","entries","paramsLength","resolve","isPrepended","queryStringArray","map","_a","index","key","prepend","append","typeofValue","encodeURI","join","DEFAULT_CONFIG","apiResponseFormat","baseUrl","userConfig","finalConfig","this","config","Fetch","format","url","fetch","then","result","status","statusText","headers","catch","err","response","json","finalResult","Response","ok","redirected","__extends","DecodeVin","vin","action","buildQueryString","queryString","get","DecodeVinExtended","DecodeVinValues","DecodeVinValuesExtended","DecodeWMI","WMI","GetAllMakes","GetAllManufacturers","GetCanadianVehicleSpecifications","year","undefined","make","model","units","GetEquipmentPlantCodes","equipmentType","reportType","GetMakeForManufacturer","manufacturer","GetMakesForManufacturerAndYear","GetMakesForVehicleType","typeName","GetManufacturerDetails","GetModelsForMake","makeName","GetModelsForMakeId","makeID","GetModelsForMakeIdYear","makeId","typeofMakeId","modelYear","vehicleType","typeofModelYear","typeofVehicleType","actionUrl","GetModelsForMakeYear","typeofMake","GetParts","GetVehicleTypesForMake","GetVehicleTypesForMakeId","GetVehicleVariableList","GetVehicleVariableValuesList","variableValue","GetWMIsForManufacturer","_super","_this","Client","NHTSA","toUpperCase","vinArray","split","checkDigit","isNaN","parseInt","checkValue","transliterationTable","A","B","C","D","E","F","G","H","J","K","L","M","N","P","R","S","T","U","V","W","X","Y","Z","weightsArray","checksum","digit","reduce","acc","currValue"],"mappings":"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"}