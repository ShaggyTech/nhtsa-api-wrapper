(function(y,r){typeof exports=="object"&&typeof module<"u"?r(exports):typeof define=="function"&&define.amd?define(["exports"],r):(y=typeof globalThis<"u"?globalThis:y||self,r(y.NHTSA={}))})(this,function(y){"use strict";const r=async e=>Promise.reject(Error(e));function u(e){const t=Object.prototype.toString.call(e).toLowerCase();return t.slice(8,t.length-1)}const G={A:1,B:2,C:3,D:4,E:5,F:6,G:7,H:8,J:1,K:2,L:3,M:4,N:5,P:7,R:9,S:2,T:3,U:4,V:5,W:6,X:7,Y:8,Z:9},w=[8,7,6,5,4,3,2,10,0,9,8,7,6,5,4,3,2];function Y(e){if(typeof e!="string"||e.length!=17)return!1;e=e.toUpperCase();const t=e.split(""),n=t[8];if(isNaN(parseInt(n))&&n!=="X")return!1;const i=n==="X"?10:parseInt(n);return t.map((o,s)=>{let g;isNaN(parseInt(o))?g=G[o]:g=parseInt(o);const $=w[s];return g*$}).reduce((o,s)=>o+s,0)%11===i}const d="https://vpic.nhtsa.dot.gov/api/vehicles",V="json";function l(e,t=!1){const n={format:V};let i={};!e||u(e)!=="object"?i={...n}:i={...e,...n};const c=Object.entries(i),o=c.length;if(o<1)return Promise.resolve("");let s=!1;const g=c.map(([$,f],b)=>{let M="",h="";const q=u(f);if(f&&q==="number"&&(f=f.toString()),(f||t)&&(q==="string"||q==="number"))return s||(M="?",s=!0),b<o-1&&(h="&"),`${M}${$}=${f}${h}`});return Promise.resolve(encodeURI(g.join("")))}const a=()=>({get:async(t,n={})=>await fetch(t,n).then(async c=>{var g;const s=((g=c.headers.get("content-type"))==null?void 0:g.includes("application/json"))?await c.json():null;if(!c.ok){const $=s&&s.Message||c.status;return Promise.reject($)}return s}).catch(c=>Promise.reject(Error(`Error fetching data: ${c}`)))}),k=async(e,t)=>{const n="DecodeVin",i=u(e);if(!e||i!=="string")return r(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=u(t);if(t&&c!=="object")return r(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const o=u(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&o!=="number")return r(`${n}, "params.modelYear" must be of type string or number, got: <${o}> ${t.modelYear}`);const s=await l(t).catch($=>r(`${n}, error building query string: ${$}`)),g=`${d}/${n}/${e}${s}`;return await a().get(g).then($=>$).catch($=>r(`${n}, error fetching data: ${$}`))},m=async(e,t)=>{const n="DecodeVinExtended",i=u(e);if(!e||i!=="string")return r(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=u(t);if(t&&c!=="object")return r(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const o=u(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&o!=="number")return r(`${n}, "params.modelYear" must be of type number or string, got: <${o}> ${t.modelYear}`);const s=await l(t).catch($=>r(`${n}, error building query string: ${$}`)),g=`${d}/${n}/${e}${s}`;return await a().get(g).then($=>$).catch($=>r(`${n}, error fetching data: ${$}`))},S=async(e,t)=>{const n="DecodeVinValues",i=u(e);if(!e||i!=="string")return r(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=u(t);if(t&&c!=="object")return r(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const o=u(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&o!=="number")return r(`${n}, "params.modelYear" must be of type number or string, got: <${o}> ${t.modelYear}`);const s=await l(t).catch($=>r(`${n}, error building query string: ${$}`)),g=`${d}/${n}/${e}${s}`;return await a().get(g).then($=>$).catch($=>r(`${n}, error fetching data: ${$}`))},j=async e=>{const t="DecodeVinValuesBatch",n=u(e);if(!e||n!=="string")return r(`${t}, "inputString" argument is required and must be of type string, got: <${n}> ${e}`);const i=`${d}/${t}/`,c=encodeURI(`DATA=${e}&format=${V}`);return await a().get(i,{method:"POST",headers:{"content-type":"application/x-www-form-urlencoded"},body:c}).then(o=>o).catch(o=>r(`${t}, error fetching data: ${o}`))},F=async(e,t)=>{const n="DecodeVinValuesExtended",i=u(e);if(!e||i!=="string")return r(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=u(t);if(t&&c!=="object")return r(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const o=u(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&o!=="number")return r(`${n}, "params.modelYear" must be of type number or string, got: <${o}> ${t.modelYear}`);const s=await l(t).catch($=>r(`${n}, error building query string: ${$}`)),g=`${d}/${n}/${e}${s}`;return await a().get(g).then($=>$).catch($=>r(`${n}, error fetching data: ${$}`))},D=async e=>{const t="DecodeWMI",n=u(e);if(n!=="string")return r(`${t}, "WMI" argument is required and must be of type string, got <${n}> ${e}`);const i=await l().catch(o=>r(`${t}, error building query string: ${o}`)),c=`${d}/${t}/${e}${i}`;return await a().get(c).then(o=>o).catch(o=>r(`${t}, error fetching data: ${o}`))},P=async()=>{const e="GetAllMakes",t=await l().catch(i=>r(`${e}, error building query string: ${i}`)),n=`${d}/${e}${t}`;return await a().get(n).then(i=>i).catch(i=>r(`${e}, error fetching data: ${i}`))},I=async e=>{const t="GetAllManufacturers",n=u(e);if(e&&n!=="object")return r(`${t}, "params" argument must be of type object, got: <${n}> ${e}`);const i=u(e==null?void 0:e.manufacturerType);if(e!=null&&e.manufacturerType&&i!=="string")return r(`${t}, params.manufacturerType" argument must be of type string, got: <${i}> ${e.manufacturerType}`);const c=u(e==null?void 0:e.page);if(e!=null&&e.page&&c!=="number | string")return r(`${t}, "params.page" argument must be of type number or string, got: <${c}> ${e.page}`);const o=await l(e).catch(g=>r(`${t}, error building query string: ${g}`)),s=`${d}/${t}${o}`;return await a().get(s).then(g=>g).catch(g=>r(`${t}, error fetching data: ${g}`))},A=async e=>{const t="GetCanadianVehicleSpecifications",n=u(e);if(!e||e&&n!=="object")return r(`${t}, "params" argument is required and must be of type object, got: <${n}> ${e}`);const i=u(e==null?void 0:e.year);if(!(e!=null&&e.year)||i!=="number")return r(`${t}, "params.year" argument is required and must be of type number or string, got: <${i}> ${e.year}`);const c=u(e.make);if(e!=null&&e.make&&c!=="string")return r(`${t}, "params.make" argument must be of type string, got: <${c}> ${e.make}`);const o=u(e.model);if(e.model&&o!=="string")return r(`${t}, "params.model" argument must be of type string, got: <${o}> ${e.model}`);const s=u(e.units);if(e.units&&s!=="string")return r(`${t}, "params.units" argument must be of type string, got: <${s}> ${e.units}`);const g=e.make||"",$=e.model||"",f=e.units||"",b={year:e.year,make:g,model:$,units:f},M=await l(b,!0).catch(T=>r(`${t}, error building query string: ${T}`)),h=`${d}/${t}/${M}`;return await a().get(h).then(T=>T).catch(T=>r(`${t}, error fetching data: ${T}`))},E=async e=>{const t="GetEquipmentPlantCodes",n=u(e);if(!e||n!=="object")return r(`${t}, "params" argument must be of type object, got: <${n}> ${e}`);const i=u(e.year);if(i!=="number")return r(`${t}, "params.year" argument is required and must be of type number or string, got: <${i}> ${e.year}`);const c=u(e.equipmentType);if(c!=="number")return r(`${t}, "params.equipmentType" argument is required and must be of type number or string, got: <${c}> ${e.equipmentType}`);const o=u(e.reportType);if(o!=="string")return r(`${t}, "params.reportType" argument is required and must be of type string, got: <${o}> ${e.reportType}`);const s=await l(e).catch($=>r(`${t}, error building query string: ${$}`)),g=`${d}/${t}${s}`;return await a().get(g).then($=>$).catch($=>r(`${t}, error fetching data: ${$}`))},p=async e=>{const t="GetMakeForManufacturer",n=u(e);if(!e||n!=="number")return r(`${t}, "manufacturer" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await l().catch(o=>r(`${t}, error building query string: ${o}`)),c=`${d}/${t}/${e}${i}`;return await a().get(c).then(o=>o).catch(o=>r(`${t}, error fetching data: ${o}`))},R=async(e,t)=>{const n="GetMakesForManufacturerAndYear",i=u(e);if(!e||i!=="number")return r(`${n}, "manufacturer" argument is required and must be of type number or string, got <${i}> ${e}`);const c=u(t);if(!t||t&&c!=="object")return r(`${n}, "params" argument is required and must be of type object, got: <${c}> ${t}`);const o=u(t.year);if(!t.year||o!=="number")return r(`${n}, "params.year" is required and must be of type number or string, got: <${o}> ${t.year}`);const s=await l(t).catch($=>r(`${n}, error building query string: ${$}`)),g=`${d}/${n}/${e}${s}`;return await a().get(g).then($=>$).catch($=>r(`${n}, error fetching data: ${$}`))},L=async e=>{const t="GetMakesForVehicleType",n=u(e);if(n!=="string")return r(`${t}, "typeName" argument is required and must be of type string, got <${n}> ${e}`);const i=await l().catch(o=>r(`${t}, error building query string: ${o}`)),c=`${d}/${t}/${e}${i}`;return await a().get(c).then(o=>o).catch(o=>r(`${t}, error fetching data: ${o}`))},v=async e=>{const t="GetManufacturerDetails",n=u(e);if(!e||n!=="number")return r(`${t}, "manufacturer" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await l().catch(o=>r(`${t}, error building query string: ${o}`)),c=`${d}/${t}/${e}${i}`;return await a().get(c).then(o=>o).catch(o=>r(`${t}, error fetching data: ${o}`))},N=async e=>{const t="GetModelsForMake",n=u(e);if(n!=="string")return r(`${t}, "makeName" argument is required and must be of type string, got <${n}> ${e}`);const i=await l().catch(o=>r(`${t}, error building query string: ${o}`)),c=`${d}/${t}/${e}${i}`;return await a().get(c).then(o=>o).catch(o=>r(`${t}, error fetching data: ${o}`))},C=async e=>{const t="GetModelsForMakeId",n=u(e);if(!e||n!=="number")return r(`${t}, "makeId" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await l().catch(o=>r(`${t}, error building query string: ${o}`)),c=`${d}/${t}/${e}${i}`;return await a().get(c).then(o=>o).catch(o=>r(`${t}, error fetching data: ${o}`))},W=async e=>{const t="GetModelsForMakeIdYear",n=e==null?void 0:e.makeId,i=e==null?void 0:e.modelYear,c=e==null?void 0:e.vehicleType,o=u(e);if(!e||e&&o!=="object")return r(`${t}, "params" argument is required and must be of type object, got: <${o}> ${e}`);const s=u(n);if(!n||s!=="number")return r(`${t}, "params.makeId" is required and must be of type number or string, got: <${s}> ${n}`);if(!i&&!c)return r(`${t}, must provide either "params.modelYear" or "params.vehicleType", got: { modelYear: ${i}, vehicleType: ${c} }`);const g=u(i);if(e!=null&&e.modelYear&&g!=="number")return r(`${t}, "params.modelYear" must be of type number or string, got: <${g}> ${i}`);const $=u(c);if(c&&$!=="string")return r(`${t}, "params.vehicleType" must be of type string, got: <${$}> ${c}`);let f=`${t}/makeId/${n}/`;i&&c?f+=`modelYear/${i}/vehicleType/${c}`:i?f+=`modelYear/${i}`:f+=`vehicleType/${c}`;const b=await l().catch(h=>r(`${t}, error building query string: ${h}`)),M=`${d}/${f}${b}`;return await a().get(M).then(h=>h).catch(h=>r(`${t}, error fetching data: ${h}`))},U=async e=>{const t="GetModelsForMakeYear",n=e==null?void 0:e.make,i=e==null?void 0:e.modelYear,c=e==null?void 0:e.vehicleType,o=u(e);if(!e||e&&o!=="object")return r(`${t}, "params" argument is required and must be of type object, got: <${o}> ${e}`);const s=u(n);if(!n||s!=="string")return r(`${t}, "params.make" is required and must be of type string, got: <${s}> ${n}`);if(!i&&!c)return r(`${t}, must provide either "params.modelYear" or "params.vehicleType" or both, got: { modelYear: ${i}, vehicleType: ${c} }`);const g=u(i);if(e!=null&&e.modelYear&&g!=="number")return r(`${t}, "params.modelYear" must be of type number or string, got: <${g}> ${i}`);const $=u(c);if(c&&$!=="string")return r(`${t}, "params.vehicleType" must be of type string, got: <${$}> ${c}`);let f=`${t}/make/${n}/`;i&&c?f+=`modelYear/${i}/vehicleType/${c}`:i?f+=`modelYear/${i}`:f+=`vehicleType/${c}`;const b=await l().catch(h=>r(`${t}, error building query string: ${h}`)),M=`${d}/${f}${b}`;return await a().get(M).then(h=>h).catch(h=>r(`${t}, error fetching data: ${h}`))},_=async e=>{const t="GetParts",n=e==null?void 0:e.type,i=e==null?void 0:e.fromDate,c=e==null?void 0:e.toDate,o=e==null?void 0:e.page,s=u(e);if(e&&s!=="object")return r(`${t}, "params" argument must be of type object, got: <${s}> ${e}`);const g=u(n);if(n&&g!=="number")return r(`${t}, "params.type" argument must be of type number or string, got: <${g}> ${n}`);const $=u(i);if(i&&$!=="string")return r(`${t}, "params.fromDate" argument must be of type string, got: <${$}> ${i}`);const f=u(c);if(c&&f!=="string")return r(`${t}, "params.toDate" argument must be of type string, got: <${f}> ${c}`);const b=u(o);if(o&&b!=="number")return r(`${t}, "params.page" argument must be of type number or string, got: <${b}> ${o}`);const M=await l(e).catch(q=>r(`${t}, error building query string: ${q}`)),h=`${d}/${t}${M}`;return await a().get(h).then(q=>q).catch(q=>r(`${t}, error fetching data: ${q}`))},O=async e=>{const t="GetVehicleTypesForMake",n=u(e);if(!e||n!=="string")return r(`${t}, "makeName" argument is required and must be of type string, got <${n}> ${e}`);const i=await l().catch(o=>r(`${t}, error building query string: ${o}`)),c=`${d}/${t}/${e}${i}`;return await a().get(c).then(o=>o).catch(o=>r(`${t}, error fetching data: ${o}`))},B=async e=>{const t="GetVehicleTypesForMakeId",n=u(e);if(!e||n!=="number")return r(`${t}, "makeId" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await l().catch(o=>r(`${t}, error building query string: ${o}`)),c=`${d}/${t}/${e}${i}`;return await a().get(c).then(o=>o).catch(o=>r(`${t}, error fetching data: ${o}`))},H=async()=>{const e="GetVehicleVariableList",t=await l().catch(i=>r(`${e}, error building query string: ${i}`)),n=`${d}/${e}${t}`;return await a().get(n).then(i=>i).catch(i=>r(`${e}, error fetching data: ${i}`))},J=async e=>{const t="GetVehicleVariableValuesList",n=u(e);if(!e||!["number","string"].includes(n))return r(`${t}, "variableValue" argument is required and must be of type number or string, got <${n}> ${e}`);e=encodeURI(String(e));const i=await l().catch(o=>r(`${t}, error building query string: ${o}`)),c=`${d}/${t}/${e}${i}`;return await a().get(c).then(o=>o).catch(o=>r(`${t}, error fetching data: ${o}`))},X=async(e,t)=>{const n="GetWMIsForManufacturer",i=t==null?void 0:t.vehicleType;if(!e&&!i)return r(`${n}, "manufacturer" and "params.vehicleType" arguments are optional but at least 1 is required, got: manufacturer: ${e} and vehicleType: ${i}`);const c=u(e);if(e&&!["number","string"].includes(c))return r(`${n}, "manufacturer" must be of type number or string, got <${c}> ${e}`);const o=u(t);if(t&&o!=="object")return r(`${n}, "params" must be of type object, got: <${o}> ${t}`);const s=u(t==null?void 0:t.vehicleType);if(t!=null&&t.vehicleType&&!["number","string"].includes(s))return r(`${n}, "params.vehicleType" must be of type number or string, got: <${s}> ${t.vehicleType}`);const g=await l(t).catch(f=>r(`${n}, error building query string: ${f}`)),$=`${d}/${n}/${e||""}${g}`;return await a().get($).then(f=>f).catch(f=>r(`${n}, error fetching data: ${f}`))};y.DecodeVin=k,y.DecodeVinExtended=m,y.DecodeVinValues=S,y.DecodeVinValuesBatch=j,y.DecodeVinValuesExtended=F,y.DecodeWMI=D,y.GetAllMakes=P,y.GetAllManufacturers=I,y.GetCanadianVehicleSpecifications=A,y.GetEquipmentPlantCodes=E,y.GetMakeForManufacturer=p,y.GetMakesForManufacturerAndYear=R,y.GetMakesForVehicleType=L,y.GetManufacturerDetails=v,y.GetModelsForMake=N,y.GetModelsForMakeId=C,y.GetModelsForMakeIdYear=W,y.GetModelsForMakeYear=U,y.GetParts=_,y.GetVehicleTypesForMake=O,y.GetVehicleTypesForMakeId=B,y.GetVehicleVariableList=H,y.GetVehicleVariableValuesList=J,y.GetWMIsForManufacturer=X,y.isValidVin=Y,Object.defineProperty(y,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=nhtsa-api-wrapper.umd.js.map
