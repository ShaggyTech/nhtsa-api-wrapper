{"version":3,"file":"nhtsa-api-wrapper.js","sources":["../src/utils/argHandler.ts","../src/utils/errorHandler.ts","../src/utils/getTypeof.ts","../src/utils/isValidVin.ts","../src/constants.ts","../src/utils/queryString.ts","../src/api/endpoints/DecodeVin.ts","../src/api/endpoints/DecodeVinExtended.ts","../src/api/endpoints/DecodeVinValues.ts","../src/api/endpoints/DecodeVinValuesBatch.ts","../src/api/endpoints/DecodeVinValuesExtended.ts","../src/api/endpoints/DecodeWMI.ts","../src/api/endpoints/GetAllMakes.ts","../src/api/endpoints/GetAllManufacturers.ts","../src/api/endpoints/GetCanadianVehicleSpecifications.ts","../src/api/endpoints/GetEquipmentPlantCodes.ts","../src/api/endpoints/GetMakeForManufacturer.ts","../src/api/endpoints/GetMakesForManufacturerAndYear.ts","../src/api/endpoints/GetMakesForVehicleType.ts","../src/api/endpoints/GetManufacturerDetails.ts","../src/api/endpoints/GetModelsForMake.ts","../src/api/endpoints/GetModelsForMakeId.ts","../src/api/endpoints/GetModelsForMakeIdYear.ts","../src/api/endpoints/GetModelsForMakeYear.ts","../src/api/endpoints/GetParts.ts","../src/api/endpoints/GetVehicleTypesForMake.ts","../src/api/endpoints/GetVehicleTypesForMakeId.ts","../src/api/endpoints/GetVehicleVariableList.ts","../src/api/endpoints/GetVehicleVariableValuesList.ts","../src/api/endpoints/GetWMIsForManufacturer.ts","../src/api/useNHTSA.ts"],"sourcesContent":["import { getTypeof } from '@/utils'\nimport type { AtLeastOne } from '@/types'\n\nexport type IArgToValidate = {\n  name: string\n  value: unknown\n} & AtLeastOne<{\n  required?: boolean\n  types?: string[]\n}>\n\n/**\n * Catches invalid arguments passed to functions and throws an error with a message detailing the\n * invalid argument(s) and what was expected.\n *\n * At least one of `required` or `types` must be provided for each arg to validate against or it\n * will validate nothing and return true for that arg value as if it was valid.\n *\n * Under the hood it loops through the args and calls `validateArgument` to validate each arg.\n * `validateArgument` will throw an error if any of the arguments are invalid based on the provided\n * options in each arg. See the description for `validateArgument` for more details on how\n * validation logic works and how to override the default error throwing behavior.\n *\n * @param {Object} options - options object\n * @param {IArgToValidate[]} options.args - array of IArgToValidate objects\n * @param {boolean} [options.mode=default] - 'default' or 'atLeast' - 'default' will validate all\n * args, 'atLeast' will validate at least one arg in in the array has a defined value\n * @returns {boolean} - true if validation passes, throws error in the case of validation failure\n */\nexport const catchInvalidArguments = ({\n  args,\n  mode = 'default',\n}: {\n  args: IArgToValidate[]\n  mode?: 'default' | 'atLeast'\n}) => {\n  if (getTypeof(args) !== 'array' && !args.length) {\n    throw Error(\n      `catchInvalidArguments requires \"args\" that must be an array of IArgToValidate objects`\n    )\n  }\n\n  if (mode === 'default') {\n    args.forEach((arg) => {\n      validateArgument(arg)\n    })\n  } else if (mode === 'atLeast') {\n    const providedArg = args.find((arg) => !!arg.value)\n    if (!providedArg) {\n      throw Error(\n        `must provide at least one of the following arguments: ${args\n          .map((arg) => arg.name)\n          .join(', ')}`\n      )\n    }\n  }\n}\n\n/**\n * Will validate a single argument based on the provided options and throws an error with a message\n * detailing the invalid argument(s) and what was expected.\n *\n * There are two modes for this function:\n * - 'error' - (default) - Throws an error if the argument fails validation.\n * - 'boolean' - Returns false if the argument fails validation, does not throw an error.\n *\n * Both modes return true if the argument passes validation.\n *\n * The logic is the same for both modes, the only difference is the return value.\n *\n * `error` mode is useful for validating arguments supplied to a function and throwing an\n * error if the arguments are invalid. Can also be used to validate existence and type of any\n * value matches an array of type names you provide. It will throw an error if the argument is\n * invalid and return true if the argument is valid.\n *\n * `boolean` mode is useful for validating arguments in a function that returns a boolean value,\n * such as in Array.filter() or 'if' statements. It will return false if the argument is invalid\n * and true if the argument is valid.\n *\n * ### Options\n *\n * The main purpose for this function is to throw a helpful Error message to the user when they\n * are using the endpoint functions in a way that would cause the NHTSA API to return an error.\n * In default mode, it uses the `options.name` and `options.types` array (if provided) to build the\n * error message in the case of validation failure.\n *\n * - `options.name` and `options.value` are required in each arg object. It's ok to pass undefined\n * as the value, i.e. { value: someVarThatMightBeUndefined }, but you must provide a name for the\n * argument. If you didn't provide a name then the error message would not be as helpful.\n * - `options.required` and `options.types` are optional.\n *\n * At least one of `options.required` or `options.types` must be provided as part of each arg\n * object. At least one of these options must be provided for each arg object, otherwise it will\n * always return true. You probably don't need to validate that arg if you don't provide at least\n * one of these options.\n *\n * ### Validation Logic\n *\n * If both `required` is true and `types` are provided, it will validate the value is defined and\n * that the typeof value is one of the provided strings in the `types` array.\n *\n * If `required` is true and no `types` are provided, it will only validate value is defined.\n *\n * - If `types` is provided but it is not `required`, it will only validate value is one of the\n * type strings in the `types` array.\n * - If `types` is provided but it is not `required` and value is 'undefined' it will skip\n * validation as there is no value to validate against and user would mark it required if they\n * wanted to validate against a defined value. If the value is not required and you give types of\n * ['string', 'number'] for example, it will validate that the value is either a string or a number.\n * - If neither `required` nor `types` are provided, it will not peerform validation and will\n * simply return true.\n *\n * @param options - options object\n * @param {string} options.name - name of the argument\n * @param {unknown} options.value - value of the argument\n * @param {boolean} [options.required] - if true, will validate that value is defined\n * @param {(string[])} [options.types] - array of strings to validate value against\n * @param {(\"error\"|\"boolean\")} [options.errorMode='error'] - 'error' or 'boolean' - 'error' will\n * throw an error if the argument is invalid, 'boolean' will return false if the argument is invalid\n * @returns {(Error|boolean)} - true if validation passes, mode 'error' throws Error in the case of\n * validation failure, mode 'boolean' returns false in the case of validation failure\n */\nexport const validateArgument = ({\n  name,\n  value,\n  required,\n  types,\n  errorMode = 'error',\n}: IArgToValidate & { errorMode?: 'error' | 'boolean' }): boolean => {\n  if (getTypeof(name) !== 'string') {\n    throw Error(`'name', is required and must be of type string`)\n  }\n\n  let error = ''\n  const typeofValue = getTypeof(value)\n  const errorPrepend = `error validating argument named \"${name}\",`\n  const errorAppend = `received value: ${value} - of type: <${typeofValue}>`\n\n  if (types && getTypeof(types) !== 'array' && !types.length) {\n    throw Error(`${errorPrepend} 'types' must be an array of strings`)\n  }\n\n  /* ex: if types = ['string', 'number'] then you'll get '<string | number>' */\n  const joinedTypes = types ? `<${types.join(' | ')}>` : ''\n\n  /* argument validation logic */\n  if (required && !types) {\n    if (!value) {\n      error = `${errorPrepend} is required, ${errorAppend}`\n    }\n  } else if (types && !required) {\n    /* if value is not defined and is not required then we don't need to validate the type */\n    if (value !== undefined && !types.includes(typeofValue)) {\n      error = `${errorPrepend} must be of type(s) ${joinedTypes}, ${errorAppend}`\n    }\n  } else if (required && types) {\n    if (!value || !types.includes(typeofValue)) {\n      error = `${errorPrepend} is required and must be of type(s) ${joinedTypes}, ${errorAppend}`\n    }\n  }\n\n  if (error.length) {\n    if (errorMode === 'boolean') return false\n    else throw Error(error)\n  }\n\n  return true\n}\n","import { getTypeof } from '@/utils'\n\nexport const isError = (error: unknown): boolean => {\n  return getTypeof(error) === 'error'\n}\n\nexport const handleError = (error: unknown): Error => {\n  let message = 'an unknown error occurred.'\n  if (isError(error)) {\n    return error as Error\n  }\n  if (getTypeof(error) === 'string') {\n    message = error as string\n  }\n  return Error(message)\n}\n\nexport const rejectWithError = async (error: unknown): Promise<never> => {\n  if (!isError(error)) {\n    error = handleError(error)\n  }\n  return Promise.reject(error)\n}\n","/**\n * @module utils/getTypeof\n * @category Utils\n */\n\n/**\n * Gets type of `value` using `Object.prototype.toString.call(value)`.\n *\n * Why? Because `typeof` is not reliable for all types of values.\n *\n * Object.prototype.toString gives more accurate results in the case someone has used an object wrapper\n * for primitive data types such as `new Number()` or `new String()`.\n * It will also accurately recognize any Error types, Error, TypeError, etc., as 'error'.\n *\n * @param {any} value - Any kind of value (string, object, array, function, etc).\n * @returns {string} - Type of value, normalized to a lowercase string.\n */\nexport const getTypeof = (value: unknown): string => {\n  const toString: string = Object.prototype.toString\n    .call(value)\n    .toLowerCase() /* ex: => '[object string]' or '[object array], etc. */\n\n  /* return only the type, ex: 'string' or 'array' */\n  return toString.slice(8, toString.length - 1)\n}\n","/**\n * @module utils/isValidVin\n * @category Utils\n */\n\n/**\n * There will need to be some way to translate vin digits that are alphabetic into their number\n * value in the VIN algorithm transliteration table. Later, during the creation of the checksum\n * variable, those digits will be multiplied against their corresponding weight (by index) in the\n * WEIGHTS_ARRAY. This transliteration table is a key part of the VIN validation algorithm.\n */\nconst TRANSLITERATION_TABLE: Record<string, number> = {\n  A: 1,\n  B: 2,\n  C: 3,\n  D: 4,\n  E: 5,\n  F: 6,\n  G: 7,\n  H: 8,\n  J: 1,\n  K: 2,\n  L: 3,\n  M: 4,\n  N: 5,\n  P: 7,\n  R: 9,\n  S: 2,\n  T: 3,\n  U: 4,\n  V: 5,\n  W: 6,\n  X: 7,\n  Y: 8,\n  Z: 9,\n}\n\n/**\n * During the creation of the 'checksum' variable, these weights will be multiplied by the value of\n * their mirrored index vin digits. The array index of each weight corresponds to the same index of\n * each digit in the 'vin'.\n */\nconst WEIGHTS_ARRAY: number[] = [\n  8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2,\n]\n\n/**\n * Provides **offline** validation of Vehicle Identification Numbers (VINs) using the\n * [VIN Check Algorithm](https://en.wikibooks.org/wiki/Vehicle_Identification_Numbers_(VIN_codes)/Check_digit).\n *\n * If you need to test that the algorithm is working correctly, you can use 17 zeros `0` as\n * the VIN and it should return `true` as the result.\n *\n * @example <caption>Browser via html script tags</caption>\n * const isValid = NHTSA.isValidVin('3VWD07AJ5EM388202')\n * console.log(isValid) // true\n *\n * @example <caption>Imported as a module</caption>\n * import { isValidVin } from '@shaggytools/nhtsa-api-wrapper'\n * const isValid = isValidVin('3VWD07AJ5EM388202')\n * console.log(isValid) // true\n *\n * @param {string} vin - Vehicle Identification Number.\n * @returns {boolean} True for a valid VIN, false for an invalid VIN.\n */\nexport function isValidVin(vin: string): boolean {\n  /* A valid VIN must be a string and is always exactly 17 digits */\n  if (typeof vin !== 'string' || vin.length != 17) {\n    return false\n  }\n\n  /* Normalize the vin to all uppercase letters */\n  vin = vin.toUpperCase()\n  /* split the vin digits into an array */\n  const vinArray: string[] = vin.split('')\n  /* checkDigit will be tested against the checkSum later */\n  const checkDigit: string = vinArray[8]\n\n  /*\n   * In a valid VIN, the checkDigit can either be:\n   * a number, 0-9 inclusive OR the character 'X'\n   */\n  if (isNaN(parseInt(checkDigit)) && checkDigit !== 'X') {\n    return false\n  }\n\n  /*\n   * The checkValue must be a digit and 'X' is the only valid alphabetic check value.\n   * As per the algorithm, a checkDigit of 'X' is equal to a checkValue of `10` and needs to be\n   * converted as such.\n   */\n  const checkValue: number = checkDigit === 'X' ? 10 : parseInt(checkDigit)\n\n  /*\n   * Maps the vinArray and converts any values (digits) that are alphabetic, into numbers, using the\n   * TRANSLITERATION_TABLE. Then these numbers are multiplied against their corresponding weight in\n   * the WEIGHTS_ARRAY, matched by index position. All 17 of those digitValues are then added\n   * together and divided by 11. The remainder, or % modulo, of that division will be the final\n   * 'checksum'.\n   */\n  const checksum: number =\n    vinArray\n      .map((digit: string, index: number) => {\n        let digitValue: number\n        /* Use the transliteration table to convert any Not a Number(NaN) values to numbers */\n        isNaN(parseInt(digit))\n          ? (digitValue = TRANSLITERATION_TABLE[digit])\n          : (digitValue = parseInt(digit))\n\n        /* Convert the digitValue to a weighted number corresponding to it's position, by index */\n        const weight: number = WEIGHTS_ARRAY[index]\n\n        /* The final step for each digit is to multiply the digit by it's corresponding weight */\n        return digitValue * weight\n      })\n      /* Finally, get the sum of all digits and divide by 11, the modulo of that is the checksum */\n      .reduce((acc, currValue) => acc + currValue, 0) % 11\n\n  /*\n   * The checksum is compared against the checkValue we set earlier (the 9th digit of the VIN). As\n   * per the algorithm, if they are equal to each other, then the VIN must be valid and we return\n   * true, otherwise the VIN is invalid and we return false.\n   */\n  return checksum === checkValue\n}\n","export const NHTSA_BASE_URL = 'https://vpic.nhtsa.dot.gov/api/vehicles'\nexport const NHTSA_RESPONSE_FORMAT = 'json'\n","/**\n * @module utils/createQueryString\n * @category Internal Utility Functions\n */\n\nimport { NHTSA_RESPONSE_FORMAT } from '@/constants'\nimport { validateArgument } from '@/utils'\n\n/** Valid URI component types */\nexport type QueryStringTypes = string | number | boolean\n/** Object to build the query string with */\nexport type QueryStringParams = Record<string, QueryStringTypes>\n/** Object returned by encodeQueryStringParams() */\nexport type QueryStringParamsEncoded<T> = { [key in keyof T]: string }\n\n/**\n * `useQueryString` is a composable function that returns an object containing methods for creating\n * and handling query strings.\n *\n * The exported methods are:\n * - `createString()` - Creates a query string from an object of search parameters.\n * - `encodeParams()` - Encodes all params in an object into URI component encoded strings and\n *   returns a new object with the encoded params. Silently filters out any params that are not\n *   strings, numbers, or booleans.\n *\n * @example\n * // Create a query string from an object of search parameters\n * const params = { param1: 'value1', param2: 'value with spaces' }\n * const queryString = useQueryString().createString(params)\n * // queryString === '?param1=value1&param2=value%20with%20spaces&format=json'\n * // format=json is hardcoded and is always included in the query string for this package.\n *\n * @example\n * // Same params and return value but using destructure syntax\n * const { createString } = useQueryString()\n * const queryString = createString(params)\n *\n * @example\n * // Encode query string params values into URI component encoded strings and return a new object\n * const params = {  param1: 'value1', param2: true, param3: ['array will be filtered']  }\n * const encodedParams = useQueryString().encodeParams(params)\n * // encodedParams === { param1: 'value1', param2: 'true' }\n *\n * @returns {object} - Object containing methods for creating and handling query strings.\n */\nexport const useQueryString = () => {\n  return {\n    createString: createQueryString,\n    encodeParams: encodeQueryStringParams,\n  }\n}\n\n/**\n * Utility function to generate a query string conforming to URI component standards. Takes an an\n * optional object of search parameters and returns an encoded query string.\n *\n * The paramater { format: 'json' } is hardcoded and cannot be overridden, this package provides\n * no support for CSV or XML formats at this time. The default query string will be \"?format=json\"\n * even if no `params` are provided by user.\n *\n * - Ignores parameters that are not strings, numbers, or booleans, and also ignores empty strings\n *   by default.\n * - If first argument is not an object then it will be ignored.\n * - If second argument `allowEmptyParams` is set to `true`, the function will include keys with\n *   empty string values, e.g. 'emptyKey='\n *\n * @internal This function is not exported by the package, but is used internally by other\n * functions. However, it _is_ exported by the package as part of the composable function\n * `useQueryString`, and renamed to `createString` for less verbose use.\n *\n * @param {QueryStringParams} params - An object of search parameters to be converted to a query\n * string.\n * @param {boolean} [allowEmptyParams=false] - Set to `true` to include keys with empty string\n * values, e.g. 'emptyKey='.\n * @returns {string} - A query string of search parameters for use in a final fetch URL.\n */\nexport const createQueryString = <T extends QueryStringParams>(\n  params = {} as T,\n  allowEmptyParams = false\n): string => {\n  /* Validate user provided params is an object */\n  validateArgument({\n    name: 'params',\n    value: params,\n    types: ['object'],\n  })\n\n  /* Merge with valid user params but override with static params */\n  const _params = encodeQueryStringParams({\n    ...params,\n    format: NHTSA_RESPONSE_FORMAT,\n  })\n\n  /* Create query string from params, default: ?format=json */\n  return (\n    '?' +\n    Object.entries(_params)\n      .map(([key, value], index, array) => {\n        return value.length || (allowEmptyParams && value === '')\n          ? `${key}=${value}${index < array.length - 1 ? '&' : ''}`\n          : ''\n      })\n      .join('')\n  )\n}\n\n/**\n * Utility function to perform URI component encoding on all values in an object, for use in URL\n * query strings.\n *\n * - Returns an object of valid URI encoded parameters with same keys as the original object.\n * - Will silently filter out parameters with values that are not type `string`, `number`, or\n *   `boolean`.\n * - It filters invalid key/values so that encodeURIComponent() does not throw an error.\n *\n * In it's current implementation, this function assumes that invalid types have already been\n * filtered out, and that all values are valid. If you need to be sure that all keys are present\n * in the returned object, you can use the `validateArgument()` function to check the types of all\n * values are valid before calling this function.\n *\n * @internal This function is not exported by the package, but is used internally by other\n * functions. However, it _is_ exported by the package as part of the composable function\n * `useQueryString`, and renamed to `encodeParams` for less verbose use.\n *\n * @param {QueryStringParams} params - An object of search parameters to be encoded.\n * @returns {QueryStringParamsEncoded} - A new object of same keys as the original object with\n * values converted to URI component strings. Any keys with values not a string, number, or\n * boolean are filtered out of final object.\n */\nexport const encodeQueryStringParams = <T extends QueryStringParams>(\n  params: T\n): QueryStringParamsEncoded<T> => {\n  const _params = Object.entries(params)\n    .filter(([key, value]) =>\n      validateArgument({\n        name: key,\n        types: ['string', 'number', 'boolean'],\n        value,\n        errorMode: 'boolean',\n      })\n    )\n    .reduce((acc, [key, value]) => {\n      /* can expect only strings, numbers, and booleans after filtering */\n      acc[key as keyof T] = encodeURIComponent(value)\n      return acc\n    }, {} as QueryStringParamsEncoded<T>)\n\n  return _params\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `DecodeVin` decodes a Vehicle Identification Number (VIN) and returns useful information about\n * the vehicle.\n *\n * In the return object, `Results` will be an array with multiple objects containing 'key:value'\n * results. Each object will contain:\n * - \"Variable\" (variable name) and \"Value\" (variable value)\n * - \"VariableID\" and \"ValueID\" (unique ID associated with the variable/value)\n * - In case of text variables, the \"ValueID\" is not applicable\n *\n * Providing `params.modelYear` allows for the decoding to specifically be done in the current, or\n * older (pre-1980), model year ranges. It is recommended to always provide `params.modelYear` if\n * the model year is known at the time of decoding, but it is not required.\n *\n * This endpoint also supports partial VIN decoding (VINs that are less than 17 characters).\n *   - Ex: 5UXWX7C5*BA\n *   - In this case, the VIN will be decoded partially with the available characters\n *   - In case of partial VINs, a `*` could be used to indicate the unavailable characters\n *   - The 9th digit is not necessary\n *\n * NOTE: Unless you have a specific need to obtain \"ValueID\" or \"VariableID\" for each variable\n * in a decoded VIN, this package recommends using one of the `DecodeVinValues*` endpoints\n * instead. This is because they will return a single flat format object of key/value pairs,\n * where key is the name of the variable. `DecodeVinValuesBatch` will return multple flat format\n * objects, one for each VIN you search. The flat format is more efficient and easier to work with\n * as you won't have to iterate through a bunch of objects just to get all variable names/values.\n *\n * @param {string} vin - Vehicle Identification Number (full or partial)\n * @param [params] - Object of Query Search names and values to append to the URL as a query string\n * @param {(string|number)} [params.modelYear] - Optional Model Year search parameter\n * @returns {(Promise<NhtsaResponse<DecodeVinResults>>)} - Api Response object\n */\nexport const DecodeVin = async (\n  vin: string,\n  params?: {\n    modelYear?: string | number\n  }\n): Promise<NhtsaResponse<DecodeVinResults>> => {\n  const endpointName = 'DecodeVin'\n\n  try {\n    const args: IArgToValidate[] = [\n      { name: 'vin', value: vin, required: true, types: ['string'] },\n      { name: 'params', value: params, types: ['object'] },\n      {\n        name: 'modelYear',\n        value: params?.modelYear,\n        types: ['string', 'number'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: vin, params })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects returned in the NhtsaResponse 'Results' array of DecodeVin endpoint\n *\n * @alias DecodeVinResults\n */\nexport type DecodeVinResults = {\n  Value: string | null\n  ValueId: string | null\n  Variable: string\n  VariableId: number\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `DecodeVinExtended` decodes a Vehicle Identification Number (VIN) and returns useful information\n * about the vehicle.\n *\n * This endpoint is similar to `DecodeVin` but returns additional information on variables related\n * to other NHTSA programs like the\n * [NCSA](https://www.nhtsa.gov/research-data/national-center-statistics-and-analysis-ncsa).\n *\n * In the return object, `Results` will be an array with multiple objects containing 'key:value'\n * results. Each object will contain:\n * - \"Variable\" (variable name) and \"Value\" (variable value)\n * - \"VariableID\" and \"ValueID\" (unique ID associated with the variable/value)\n * - In case of text variables, the \"ValueID\" is not applicable\n *\n * Providing `params.modelYear` allows for the decoding to specifically be done in the current, or\n * older (pre-1980), model year ranges. It is recommended to always provide `params.modelYear` if\n * the model year is known at the time of decoding, but it is not required.\n *\n * This endpoint also supports partial VIN decoding (VINs that are less than 17 characters).\n *   - Ex: 5UXWX7C5*BA\n *   - In this case, the VIN will be decoded partially with the available characters\n *   - In case of partial VINs, a `*` could be used to indicate the unavailable characters\n *   - The 9th digit is not necessary\n *\n * NOTE: Unless you have a specific need to obtain \"ValueID\" or \"VariableID\" for each variable\n * in a decoded VIN, this package recommends using one of the `DecodeVinValues*` endpoints\n * instead. This is because they will return a single flat format object of key/value pairs,\n * where key is the name of the variable. `DecodeVinValuesBatch` will return multple flat format\n * objects, one for each VIN you search. The flat format is more efficient and easier to work with\n * as you won't have to iterate through a bunch of objects just to get all variable names/values.\n *\n * @param {string} vin - Vehicle Identification Number (full or partial)\n * @param [params] - Object of Query Search names and values to append to the URL as a query string\n * @param {(string|number)} [params.modelYear] - Optional Model Year search parameter\n * @returns {(Promise<NhtsaResponse<DecodeVinExtendedResults>>)} - Api Response object\n */\nexport const DecodeVinExtended = async (\n  vin: string,\n  params?: {\n    modelYear?: string | number\n  }\n): Promise<NhtsaResponse<DecodeVinExtendedResults>> => {\n  const endpointName = 'DecodeVinExtended'\n\n  try {\n    const args: IArgToValidate[] = [\n      { name: 'vin', value: vin, required: true, types: ['string'] },\n      { name: 'params', value: params, types: ['object'] },\n      {\n        name: 'modelYear',\n        value: params?.modelYear,\n        types: ['string', 'number'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: vin, params })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects returned in the NhtsaResponse 'Results' array of DecodeVinExtended endpoint\n *\n * @alias DecodeVinExtendedResults\n */\nexport type DecodeVinExtendedResults = {\n  Value: string | null\n  ValueId: string | null\n  Variable: string\n  VariableId: number\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `DecodeVinValues` decodes a Vehicle Identification Number (VIN) and returns useful information\n * about the vehicle in in a _flat format_. This means the endpoint will return an array with a\n * single object of results. Each key in the object is the name of a variable.\n *\n * Providing `params.modelYear` allows for the decoding to specifically be done in the current, or\n * older (pre-1980), model year ranges. It is recommended to always provide `params.modelYear` if\n * the model year is known at the time of decoding, but it is not required.\n *\n * This endpoint also supports partial VIN decoding (VINs that are less than 17 characters).\n *   - Ex: \"5UXWX7C5*BA\"\n *   - In this case, the VIN will be decoded partially with the available characters\n *   - In case of partial VINs, a `*` could be used to indicate the unavailable characters\n *   - The 9th digit is not necessary\n *\n * The variable names and values in the flat format object are equivalent to \"Variable\" and \"Value\"\n * keys found in objects returned from _nested format_ endpoints such as `DecodeVin` and\n * `DecodeVinExtended`.\n *\n * *NOTE:* For decoding VINs this package recommends using `DecodeVinValues*` endpoints such as\n * this one. The flat format is more efficient and easier to work with as you won't have to iterate\n * through a bunch of objects just to get all variable names/values as is the case with\n * _nested format_. Unless you need to obtain \"ValueID\" and/or \"VariableID\" for each variable in a\n * decoded VIN. In that case, you should use either `DecodeVin` or `DecodeVinExtended` endpoints to\n * obtain the values in a _nested format_.\n *\n * @param {string} vin - Vehicle Identification Number (full or partial)\n * @param [params] - Object of Query Search names and values to append to the URL as a query string\n * @param {(string|number)} [params.modelYear] - Optional Model Year search parameter\n * @returns {(Promise<NhtsaResponse<DecodeVinValuesResults>>)} Api Response object\n */\nexport const DecodeVinValues = async (\n  vin: string,\n  params?: {\n    modelYear?: string | number\n  }\n): Promise<NhtsaResponse<DecodeVinValuesResults>> => {\n  const endpointName = 'DecodeVinValues'\n\n  try {\n    const args: IArgToValidate[] = [\n      { name: 'vin', value: vin, required: true, types: ['string'] },\n      { name: 'params', value: params, types: ['object'] },\n      {\n        name: 'modelYear',\n        value: params?.modelYear,\n        types: ['string', 'number'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: vin, params })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects returned in the NhtsaResponse 'Results' array of DecodeVinValues endpoint\n *\n * @alias DecodeVinValuesResults\n */\nexport type DecodeVinValuesResults = {\n  ABS: string\n  ActiveSafetySysNote: string\n  AdaptiveCruiseControl: string\n  AdaptiveDrivingBeam: string\n  AdaptiveHeadlights: string\n  AdditionalErrorText: string\n  AirBagLocCurtain: string\n  AirBagLocFront: string\n  AirBagLocKnee: string\n  AirBagLocSeatCushion: string\n  AirBagLocSide: string\n  AutoReverseSystem: string\n  AutomaticPedestrianAlertingSound: string\n  AxleConfiguration: string\n  Axles: string\n  BasePrice: string\n  BatteryA: string\n  BatteryA_to: string\n  BatteryCells: string\n  BatteryInfo: string\n  BatteryKWh: string\n  BatteryKWh_to: string\n  BatteryModules: string\n  BatteryPacks: string\n  BatteryType: string\n  BatteryV: string\n  BatteryV_to: string\n  BedLengthIN: string\n  BedType: string\n  BlindSpotIntervention: string\n  BlindSpotMon: string\n  BodyCabType: string\n  BodyClass: string\n  BrakeSystemDesc: string\n  BrakeSystemType: string\n  BusFloorConfigType: string\n  BusLength: string\n  BusType: string\n  CAN_AACN: string\n  CIB: string\n  CashForClunkers: string\n  ChargerLevel: string\n  ChargerPowerKW: string\n  CoolingType: string\n  CurbWeightLB: string\n  CustomMotorcycleType: string\n  DaytimeRunningLight: string\n  DestinationMarket: string\n  DisplacementCC: string\n  DisplacementCI: string\n  DisplacementL: string\n  Doors: string\n  DriveType: string\n  DriverAssist: string\n  DynamicBrakeSupport: string\n  EDR: string\n  ESC: string\n  EVDriveUnit: string\n  ElectrificationLevel: string\n  EngineConfiguration: string\n  EngineCycles: string\n  EngineCylinders: string\n  EngineHP: string\n  EngineHP_to: string\n  EngineKW: string\n  EngineManufacturer: string\n  EngineModel: string\n  EntertainmentSystem: string\n  ErrorCode: string\n  ErrorText: string\n  ForwardCollisionWarning: string\n  FuelInjectionType: string\n  FuelTypePrimary: string\n  FuelTypeSecondary: string\n  GCWR: string\n  GCWR_to: string\n  GVWR: string\n  GVWR_to: string\n  KeylessIgnition: string\n  LaneCenteringAssistance: string\n  LaneDepartureWarning: string\n  LaneKeepSystem: string\n  LowerBeamHeadlampLightSource: string\n  Make: string\n  MakeID: string\n  Manufacturer: string\n  ManufacturerId: string\n  Model: string\n  ModelID: string\n  ModelYear: string\n  MotorcycleChassisType: string\n  MotorcycleSuspensionType: string\n  NCSABodyType: string\n  NCSAMake: string\n  NCSAMapExcApprovedBy: string\n  NCSAMapExcApprovedOn: string\n  NCSAMappingException: string\n  NCSAModel: string\n  NCSANote: string\n  NonLandUse: string\n  Note: string\n  OtherBusInfo: string\n  OtherEngineInfo: string\n  OtherMotorcycleInfo: string\n  OtherRestraintSystemInfo: string\n  OtherTrailerInfo: string\n  ParkAssist: string\n  PedestrianAutomaticEmergencyBraking: string\n  PlantCity: string\n  PlantCompanyName: string\n  PlantCountry: string\n  PlantState: string\n  PossibleValues: string\n  Pretensioner: string\n  RearAutomaticEmergencyBraking: string\n  RearCrossTrafficAlert: string\n  RearVisibilitySystem: string\n  SAEAutomationLevel: string\n  SAEAutomationLevel_to: string\n  SeatBeltsAll: string\n  SeatRows: string\n  Seats: string\n  SemiautomaticHeadlampBeamSwitching: string\n  Series: string\n  Series2: string\n  SteeringLocation: string\n  SuggestedVIN: string\n  TPMS: string\n  TopSpeedMPH: string\n  TrackWidth: string\n  TractionControl: string\n  TrailerBodyType: string\n  TrailerLength: string\n  TrailerType: string\n  TransmissionSpeeds: string\n  TransmissionStyle: string\n  Trim: string\n  Trim2: string\n  Turbo: string\n  VIN: string\n  ValveTrainDesign: string\n  VehicleDescriptor: string\n  VehicleType: string\n  WheelBaseLong: string\n  WheelBaseShort: string\n  WheelBaseType: string\n  WheelSizeFront: string\n  WheelSizeRear: string\n  Wheels: string\n  Windows: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `DecodeVinValuesBatch` decodes a batch of Vehicle Identification Numbers (VINs) and returns\n * useful information about the vehicles in in a _flat format_. This means the endpoint will return\n * an array with multiple objects of results. Each object represents a VIN from the `inputString`\n * and the key:value pairs in the objects are variables and their values for each particular VIN.\n *\n * For this particular API you just have to provide a string of VINs, `inputString`, that are\n * separated by a `;` char. You can also indicate the model year after the vin, preceded by a `,`\n * char.\n *\n * The `inputString` parameter should be in the following format:\n * - ex: `5UXWX7C5*BA, 2011; 5YJSA3DS*EF`\n * - no modelYear: `vin; vin; vin`\n * - with modelYear: `vin, modelYear; vin, modelYear; vin, modelYear`\n * - mix of with/without modelYear: `vin; vin, modelYear`\n * - _vin_ and _modelYear_ are placeholders for real values in these examples\n * - all spaces between `;` and `,` are used in these examples for readability ard are optional\n * - _Max 50 VINs per batch_\n *\n * Providing the modelYear in the input string allows for the decoding to specifically be done in\n * the current, or older (pre-1980), model year ranges. It is recommended to always provide\n * the model year if it is known at the time of decoding, but it is not required.\n *\n * The variable names and values in the flat format objects are equivalent to \"Variable\" and \"Value\"\n * keys found in objects returned from _nested format_ endpoints such as `DecodeVin` and\n * `DecodeVinExtended`.\n *\n * *NOTE:* For decoding VINs this package recommends using `DecodeVinValues*` endpoints such as\n * this one. The flat format is more efficient and easier to work with as you won't have to iterate\n * through a bunch of objects just to get all variable names/values as is the case with\n * _nested format_. Unless you need to obtain \"ValueID\" and/or \"VariableID\" for each variable in a\n * decoded VIN. In that case, you should use either `DecodeVin` or `DecodeVinExtended` endpoints to\n * obtain the values in a _nested format_ where each variable is an object containing individual\n * \"Variable\", \"Value\", \"ValueID\" and \"VariableID\" properties.\n *\n * *NOTE:* This endpoint is the only one to use a POST request instead of a GET request. We want to\n * ensure that response format is always set to 'json' in all requests, even POST requests. as POST\n * requests do not allow query strings, we can't set the response format to 'json' in a query\n * string like every other endpoint. Therefore, we\n * have to set the response format in the body of the request before sending it. This is performed\n * internally by the post function in `useNHTSA` composable but it is worth noting here.  We also\n *\n *\n * @param {string} inputString - A string of Vehicle Identification Numbers (full or partial)\n * following the format listed in the description\n * @returns {(Promise<DecodeVINValuesBatchResponse>)} - Api Response object\n */\nexport const DecodeVinValuesBatch = async (\n  inputString: string\n): Promise<NhtsaResponse<DecodeVinValuesBatchResults>> => {\n  const endpointName = 'DecodeVinValuesBatch'\n\n  try {\n    const args: IArgToValidate[] = [\n      {\n        name: 'inputString',\n        value: inputString,\n        required: true,\n        types: ['string'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().post({ endpointName }, { body: inputString })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects returned in the NhtsaResponse 'Results' array of DecodeVinValuesBatch endpoint\n *\n * @alias DecodeVINValuesBatchResults\n */\nexport type DecodeVinValuesBatchResults = {\n  ABS: string\n  ActiveSafetySysNote: string\n  AdaptiveCruiseControl: string\n  AdaptiveDrivingBeam: string\n  AdaptiveHeadlights: string\n  AdditionalErrorText: string\n  AirBagLocCurtain: string\n  AirBagLocFront: string\n  AirBagLocKnee: string\n  AirBagLocSeatCushion: string\n  AirBagLocSide: string\n  AutoReverseSystem: string\n  AutomaticPedestrianAlertingSound: string\n  AxleConfiguration: string\n  Axles: string\n  BasePrice: string\n  BatteryA: string\n  BatteryA_to: string\n  BatteryCells: string\n  BatteryInfo: string\n  BatteryKWh: string\n  BatteryKWh_to: string\n  BatteryModules: string\n  BatteryPacks: string\n  BatteryType: string\n  BatteryV: string\n  BatteryV_to: string\n  BedLengthIN: string\n  BedType: string\n  BlindSpotIntervention: string\n  BlindSpotMon: string\n  BodyCabType: string\n  BodyClass: string\n  BrakeSystemDesc: string\n  BrakeSystemType: string\n  BusFloorConfigType: string\n  BusLength: string\n  BusType: string\n  CAN_AACN: string\n  CIB: string\n  CashForClunkers: string\n  ChargerLevel: string\n  ChargerPowerKW: string\n  CoolingType: string\n  CurbWeightLB: string\n  CustomMotorcycleType: string\n  DaytimeRunningLight: string\n  DestinationMarket: string\n  DisplacementCC: string\n  DisplacementCI: string\n  DisplacementL: string\n  Doors: string\n  DriveType: string\n  DriverAssist: string\n  DynamicBrakeSupport: string\n  EDR: string\n  ESC: string\n  EVDriveUnit: string\n  ElectrificationLevel: string\n  EngineConfiguration: string\n  EngineCycles: string\n  EngineCylinders: string\n  EngineHP: string\n  EngineHP_to: string\n  EngineKW: string\n  EngineManufacturer: string\n  EngineModel: string\n  EntertainmentSystem: string\n  ErrorCode: string\n  ErrorText: string\n  ForwardCollisionWarning: string\n  FuelInjectionType: string\n  FuelTypePrimary: string\n  FuelTypeSecondary: string\n  GCWR: string\n  GCWR_to: string\n  GVWR: string\n  GVWR_to: string\n  KeylessIgnition: string\n  LaneCenteringAssistance: string\n  LaneDepartureWarning: string\n  LaneKeepSystem: string\n  LowerBeamHeadlampLightSource: string\n  Make: string\n  MakeID: string\n  Manufacturer: string\n  ManufacturerId: string\n  Model: string\n  ModelID: string\n  ModelYear: string\n  MotorcycleChassisType: string\n  MotorcycleSuspensionType: string\n  NCSABodyType: string\n  NCSAMake: string\n  NCSAMapExcApprovedBy: string\n  NCSAMapExcApprovedOn: string\n  NCSAMappingException: string\n  NCSAModel: string\n  NCSANote: string\n  NonLandUse: string\n  Note: string\n  OtherBusInfo: string\n  OtherEngineInfo: string\n  OtherMotorcycleInfo: string\n  OtherRestraintSystemInfo: string\n  OtherTrailerInfo: string\n  ParkAssist: string\n  PedestrianAutomaticEmergencyBraking: string\n  PlantCity: string\n  PlantCompanyName: string\n  PlantCountry: string\n  PlantState: string\n  PossibleValues: string\n  Pretensioner: string\n  RearAutomaticEmergencyBraking: string\n  RearCrossTrafficAlert: string\n  RearVisibilitySystem: string\n  SAEAutomationLevel: string\n  SAEAutomationLevel_to: string\n  SeatBeltsAll: string\n  SeatRows: string\n  Seats: string\n  SemiautomaticHeadlampBeamSwitching: string\n  Series: string\n  Series2: string\n  SteeringLocation: string\n  SuggestedVIN: string\n  TPMS: string\n  TopSpeedMPH: string\n  TrackWidth: string\n  TractionControl: string\n  TrailerBodyType: string\n  TrailerLength: string\n  TrailerType: string\n  TransmissionSpeeds: string\n  TransmissionStyle: string\n  Trim: string\n  Trim2: string\n  Turbo: string\n  VIN: string\n  ValveTrainDesign: string\n  VehicleDescriptor: string\n  VehicleType: string\n  WheelBaseLong: string\n  WheelBaseShort: string\n  WheelBaseType: string\n  WheelSizeFront: string\n  WheelSizeRear: string\n  Wheels: string\n  Windows: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `DecodeVinValuesExtended` decodes a Vehicle Identification Number (VIN) and returns useful\n * information about the vehicle in in a _flat format_. This means the endpoint will return an\n * array with a single object of results. Each key in the object is the name of a variable.\n *\n * This endpoint is similar to `DecodeVinValues` but returns additional information on variables\n * related to other NHTSA programs like\n * [NCSA](https://www.nhtsa.gov/research-data/national-center-statistics-and-analysis-ncsa), etc.\n *\n * Providing `params.modelYear` allows for the decoding to specifically be done in the current, or\n * older (pre-1980), model year ranges. It is recommended to always provide `params.modelYear` if\n * the model year is known at the time of decoding, but it is not required.\n *\n * This endpoint also supports partial VIN decoding (VINs that are less than 17 characters).\n *   - Ex: \"5UXWX7C5*BA\"\n *   - In this case, the VIN will be decoded partially with the available characters\n *   - In case of partial VINs, a `*` could be used to indicate the unavailable characters\n *   - The 9th digit is not necessary\n *\n * The variable names and values in the flat format object are equivalent to \"Variable\" and \"Value\"\n * keys found in objects returned from _nested format_ endpoints such as `DecodeVin` and\n * `DecodeVinExtended`.\n *\n * *NOTE:* For decoding VINs this package recommends using `DecodeVinValues*` endpoints such as\n * this one. The flat format is more efficient and easier to work with as you won't have to iterate\n * through a bunch of objects just to get all variable names/values as is the case with\n * _nested format_. Unless you need to obtain \"ValueID\" and/or \"VariableID\" for each variable in a\n * decoded VIN. In that case, you should use either `DecodeVin` or `DecodeVinExtended` endpoints to\n * obtain the values in a _nested format_ where each variable is an object containing individual\n * \"Variable\", \"Value\", \"ValueID\" and \"VariableID\" properties.\n *\n *\n * @param {string} vin - Vehicle Identification Number (full or partial)\n * @param [params] - Object of Query Search names and values to append to the URL as a query string\n * @param {(string|number)} [params.modelYear] - Optional Model Year search parameter\n * @returns {(Promise<NhtsaResponse<DecodeVinExtendedResults>>)} - Api Response object\n */\nexport const DecodeVinValuesExtended = async (\n  vin: string,\n  params?: {\n    modelYear?: string | number\n  }\n): Promise<NhtsaResponse<DecodeVinValuesExtendedResults>> => {\n  const endpointName = 'DecodeVinValuesExtended'\n\n  try {\n    const args: IArgToValidate[] = [\n      { name: 'vin', value: vin, required: true, types: ['string'] },\n      { name: 'params', value: params, types: ['object'] },\n      {\n        name: 'modelYear',\n        value: params?.modelYear,\n        types: ['string', 'number'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: vin, params })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects returned in the NhtsaResponse 'Results' array of DecodeVinValuesExtended endpoint\n *\n * @alias DecodeVinValuesExtendedResults\n */\nexport type DecodeVinValuesExtendedResults = {\n  ABS: string\n  ActiveSafetySysNote: string\n  AdaptiveCruiseControl: string\n  AdaptiveDrivingBeam: string\n  AdaptiveHeadlights: string\n  AdditionalErrorText: string\n  AirBagLocCurtain: string\n  AirBagLocFront: string\n  AirBagLocKnee: string\n  AirBagLocSeatCushion: string\n  AirBagLocSide: string\n  AutoReverseSystem: string\n  AutomaticPedestrianAlertingSound: string\n  AxleConfiguration: string\n  Axles: string\n  BasePrice: string\n  BatteryA: string\n  BatteryA_to: string\n  BatteryCells: string\n  BatteryInfo: string\n  BatteryKWh: string\n  BatteryKWh_to: string\n  BatteryModules: string\n  BatteryPacks: string\n  BatteryType: string\n  BatteryV: string\n  BatteryV_to: string\n  BedLengthIN: string\n  BedType: string\n  BlindSpotIntervention: string\n  BlindSpotMon: string\n  BodyCabType: string\n  BodyClass: string\n  BrakeSystemDesc: string\n  BrakeSystemType: string\n  BusFloorConfigType: string\n  BusLength: string\n  BusType: string\n  CAN_AACN: string\n  CIB: string\n  CashForClunkers: string\n  ChargerLevel: string\n  ChargerPowerKW: string\n  CoolingType: string\n  CurbWeightLB: string\n  CustomMotorcycleType: string\n  DaytimeRunningLight: string\n  DestinationMarket: string\n  DisplacementCC: string\n  DisplacementCI: string\n  DisplacementL: string\n  Doors: string\n  DriveType: string\n  DriverAssist: string\n  DynamicBrakeSupport: string\n  EDR: string\n  ESC: string\n  EVDriveUnit: string\n  ElectrificationLevel: string\n  EngineConfiguration: string\n  EngineCycles: string\n  EngineCylinders: string\n  EngineHP: string\n  EngineHP_to: string\n  EngineKW: string\n  EngineManufacturer: string\n  EngineModel: string\n  EntertainmentSystem: string\n  ErrorCode: string\n  ErrorText: string\n  ForwardCollisionWarning: string\n  FuelInjectionType: string\n  FuelTypePrimary: string\n  FuelTypeSecondary: string\n  GCWR: string\n  GCWR_to: string\n  GVWR: string\n  GVWR_to: string\n  KeylessIgnition: string\n  LaneCenteringAssistance: string\n  LaneDepartureWarning: string\n  LaneKeepSystem: string\n  LowerBeamHeadlampLightSource: string\n  Make: string\n  MakeID: string\n  Manufacturer: string\n  ManufacturerId: string\n  Model: string\n  ModelID: string\n  ModelYear: string\n  MotorcycleChassisType: string\n  MotorcycleSuspensionType: string\n  NCSABodyType: string\n  NCSAMake: string\n  NCSAMapExcApprovedBy: string\n  NCSAMapExcApprovedOn: string\n  NCSAMappingException: string\n  NCSAModel: string\n  NCSANote: string\n  NonLandUse: string\n  Note: string\n  OtherBusInfo: string\n  OtherEngineInfo: string\n  OtherMotorcycleInfo: string\n  OtherRestraintSystemInfo: string\n  OtherTrailerInfo: string\n  ParkAssist: string\n  PedestrianAutomaticEmergencyBraking: string\n  PlantCity: string\n  PlantCompanyName: string\n  PlantCountry: string\n  PlantState: string\n  PossibleValues: string\n  Pretensioner: string\n  RearAutomaticEmergencyBraking: string\n  RearCrossTrafficAlert: string\n  RearVisibilitySystem: string\n  SAEAutomationLevel: string\n  SAEAutomationLevel_to: string\n  SeatBeltsAll: string\n  SeatRows: string\n  Seats: string\n  SemiautomaticHeadlampBeamSwitching: string\n  Series: string\n  Series2: string\n  SteeringLocation: string\n  SuggestedVIN: string\n  TPMS: string\n  TopSpeedMPH: string\n  TrackWidth: string\n  TractionControl: string\n  TrailerBodyType: string\n  TrailerLength: string\n  TrailerType: string\n  TransmissionSpeeds: string\n  TransmissionStyle: string\n  Trim: string\n  Trim2: string\n  Turbo: string\n  VIN: string\n  ValveTrainDesign: string\n  VehicleDescriptor: string\n  VehicleType: string\n  WheelBaseLong: string\n  WheelBaseShort: string\n  WheelBaseType: string\n  WheelSizeFront: string\n  WheelSizeRear: string\n  Wheels: string\n  Windows: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `DecodeWMI` provides information on the World Manufacturer Identifier for a specific `WMI` code.\n *\n * `WMI` may provided as either 3 characters representing VIN position 1-3 _or_ 6 characters\n * representing VIN positions 1-3 & 12-14.\n * - Examples: \"JTD\" \"1T9131\"\n *\n * A list of WMI codes can be found\n * [here](https://en.wikibooks.org/wiki/Vehicle_Identification_Numbers_(VIN_codes)/World_Manufacturer_Identifier_(WMI)),\n * but keep in mind that not all of the listed WMIs are registered with NHTSA and therefore may not\n * be available in vPIC data sets.\n *\n * @param {string} WMI - World Manufacturer Identifier\n * @returns {(Promise<NhtsaResponse<DecodeWMIResults>>)} - Api Response object\n */\n\nexport const DecodeWMI = async (\n  WMI: string\n): Promise<NhtsaResponse<DecodeWMIResults>> => {\n  const endpointName = 'DecodeWMI'\n\n  try {\n    const args: IArgToValidate[] = [\n      {\n        name: 'WMI',\n        value: WMI,\n        required: true,\n        types: ['string'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: WMI })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of DecodeWMI endpoint\n *\n * @alias DecodeWMIResults\n */\nexport type DecodeWMIResults = {\n  CommonName: string\n  CreatedOn: string\n  DateAvailableToPublic: string\n  Make: string\n  ManufacturerName: string\n  ParentCompanyName: string\n  URL: string\n  UpdatedOn: string | null\n  VehicleType: string\n}\n","import { useNHTSA } from '@/api'\nimport { rejectWithError } from '@/utils'\nimport type { NhtsaResponse } from '@/types'\n\n/**\n * `GetAllMakes` provides a list of all the Makes available in the vPIC Dataset.\n * Each object in the `Results` array represents the `Make_ID` and the `Make_Name` of\n * an individual vehicle Make.\n *\n * - FYI there are over 10,000 registered makes in the database!\n *\n * @returns {(Promise<NhtsaResponse<GetAllMakesResults>>)} - Api Response object\n */\nexport const GetAllMakes = async (): Promise<\n  NhtsaResponse<GetAllMakesResults>\n> => {\n  const endpointName = 'GetAllMakes'\n\n  try {\n    return useNHTSA().get({ endpointName })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetAllMakes endpoint\n *\n * @alias GetAllMakesResults\n */\nexport type GetAllMakesResults = {\n  Make_ID: number\n  Make_Name: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetAllManufacturers` provides a list of all the Manufacturers available in the vPIC Dataset.\n *\n * `params.manufacturerType` is optional but allows the user to filter the list based on\n * manufacturer type. Types include 'Incomplete Vehicles', 'Completed Vehicle Manufacturer',\n * 'Incomplete Vehicle Manufacturer', 'Intermediate Manufacturer', 'Final-Stage Manufacturer',\n * 'Alterer', or any partial match of those strings.\n *\n * `params.page` is optional and used to specify (n)th page of results. Results are provided in\n * pages of 100 items.\n *\n * @param [params] - Object of Query Search names and values to append to the URL as a query string\n * @param {string} [params.manufacturerType] - See endpoint description\n * @param {(string|number)} [params.page] - Specify page number (results returned 100 at a time)\n * @returns {(Promise<NhtsaResponse<GetAllManufacturersResults>>)} - Api Response object\n */\n\nexport const GetAllManufacturers = async (params?: {\n  manufacturerType?: string\n  page?: string | number\n}): Promise<NhtsaResponse<GetAllManufacturersResults>> => {\n  const endpointName = 'GetAllManufacturers'\n\n  try {\n    const args: IArgToValidate[] = [\n      { name: 'params', value: params, types: ['object'] },\n      {\n        name: 'manufacturerType',\n        value: params?.manufacturerType,\n        types: ['string'],\n      },\n      {\n        name: 'page',\n        value: params?.page,\n        types: ['string', 'number'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, params })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetAllManufacturers endpoint\n *\n * @alias GetAllManufacturersResults\n */\nexport type GetAllManufacturersResults = {\n  Country: string\n  Mfr_CommonName: string | null\n  Mfr_ID: number\n  Mfr_Name: string\n  VehicleTypes: Array<{ IsPrimary?: boolean; Name?: string }>\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetCanadianVehicleSpecifications` returns data from the Canadian Vehicle Specifications (CVS).\n * The CVS consists of a database of original vehicle dimensions, used primarily in\n * collision investigation and reconstruction, combined with a search engine.\n *\n * The CVS database is compiled annually by the Collision Investigation and Research Division of\n * Transport Canada. Visit official\n * [Canadian Vehicle Specifications](http://www.carsp.ca/research/resources/safety-sources/canadian-vehicle-specifications/)\n * page for more details.\n *\n * `params.year` is the only required query parameter, all others are optional but will still be included\n * in the query string as blank values even if not provided by the user. See below Note for more\n * details.\n *\n * _NOTE:_ This endpoint does not like missing query keys and will return a 404 error if any of\n * them are omitted from the query string. Therefore, we must set default values to empty strings\n * for any query keys that are not provided by the user. This means keys not provided by user will\n * always show up as \"something=\" in the query string. `year` is the only key user must provide,\n * no default value is set for it so that an error will be thrown if not provided by user.\n *\n * @param params - Object of Query Search names and values to append to the URL as a query string\n * @param {(string|number)} params.year - Model year of the vehicle - year >= 1971\n * @param {string} [params.make=''] - Vehicle's make, like \"Honda\", \"Toyota\", etc...\n * @param {string} [params.model=''] - Vehicle's model, like \"Pilot\", \"Focus\". Can also include\n * some other elements like Body Type, Engine Model/size, etc...\n * @param {string} [params.units=''] - \"Metric\" (default), or \"US\" for standard units\n * @returns {(Promise<NhtsaResponse<GetCanadianVehicleSpecificationsResults>>)} - Api Response object\n */\n\nexport const GetCanadianVehicleSpecifications = async (params: {\n  year: string | number\n  make?: string\n  model?: string\n  units?: string\n}): Promise<NhtsaResponse<GetCanadianVehicleSpecificationsResults>> => {\n  const endpointName = 'GetCanadianVehicleSpecifications'\n\n  try {\n    /* Validate the arguments */\n    const args: IArgToValidate[] = [\n      { name: 'params', value: params, required: true, types: ['object'] },\n      {\n        name: 'year',\n        value: params.year,\n        required: true,\n        types: ['string', 'number'],\n      },\n      { name: 'make', value: params.make, types: ['string'] },\n      { name: 'model', value: params.model, types: ['string'] },\n      { name: 'units', value: params.units, types: ['string'] },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({\n      endpointName,\n      params: {\n        make: '',\n        model: '',\n        units: '',\n        ...params,\n      },\n      allowEmptyParams: true,\n    })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetCanadianVehicleSpecifications endpoint\n *\n * @alias GetCanadianVehicleSpecificationsResults\n */\nexport type GetCanadianVehicleSpecificationsResults = {\n  Specs: Array<{\n    Name:\n      | 'Make'\n      | 'Model'\n      | 'MYR'\n      | 'OL'\n      | 'OW'\n      | 'OH'\n      | 'WB'\n      | 'CW'\n      | 'A'\n      | 'B'\n      | 'C'\n      | 'D'\n      | 'E'\n      | 'F'\n      | 'G'\n      | 'TWF'\n      | 'TWR'\n      | 'WD'\n    Value: string\n  }>\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetEquipmentPlantCodes` returns assigned Equipment Plant Codes. Can be filtered by Year,\n * Equipment Type and Report Type.\n *\n * ALL parameters are required and endpoint will return 404 if there are any undefined keys and/or\n * values in the query string.\n *\n * `params.year`:\n * - year >= 2016\n * - NOTE: It seems API will still respond with years < 2016 but api docs state only years >= 2016\n *   are supported\n *\n * `params.equipmentType`:\n * - 1 (Tires)\n * - 3 (Brake Hoses)\n * - 13 (Glazing)\n * - 16 (Retread)\n *\n * `params.reportType`:\n * - 'New' (The Equipment Plant Code was assigned during the selected year)\n * - 'Updated' (The Equipment Plant data was modified during the selected year)\n * - 'Closed' (The Equipment Plant is no longer Active)\n * - 'All' (All Equipment Plant Codes regardless of year, including their status (active or closed))\n *\n * @param params - Object of Query Search names and values to append to the URL as a query string\n * @param {(string|number)} params.year - Year >= 2016\n * @param {(string|number)} params.equipmentType - Number equal to 1, 3, 13, or 16\n * @param {string} params.reportType - 'New', 'Updated', 'Closed', or 'All'\n * @returns {(Promise<NhtsaResponse<GetEquipmentPlantCodesResults>>)} - Api Response object\n */\nexport const GetEquipmentPlantCodes = async (params: {\n  year: string | number\n  equipmentType: '1' | '3' | '13' | '16' | 1 | 3 | 13 | 16\n  reportType: 'New' | 'Updated' | 'Closed' | 'All'\n}): Promise<NhtsaResponse<GetEquipmentPlantCodesResults>> => {\n  const endpointName = 'GetEquipmentPlantCodes'\n\n  try {\n    /* Validate the arguments */\n    const args: IArgToValidate[] = [\n      { name: 'params', value: params, required: true, types: ['object'] },\n      {\n        name: 'year',\n        value: params.year,\n        required: true,\n        types: ['string', 'number'],\n      },\n      {\n        name: 'equipmentType',\n        value: params.equipmentType,\n        required: true,\n        types: ['string', 'number'],\n      },\n      {\n        name: 'reportType',\n        value: params.reportType,\n        required: true,\n        types: ['string'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, params })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetEquipmentPlantCodes endpoint\n *\n * @alias GetEquipmentPlantCodesResults\n */\nexport type GetEquipmentPlantCodesResults = {\n  Address: string | null\n  City: string | null\n  Country: string\n  DOTCode: string\n  Name: string\n  OldDotCode: string\n  PostalCode: string | null\n  StateProvince: string | null\n  Status: string | null\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetMakeForManufacturer` returns all the Makes in the vPIC dataset for a specified manufacturer\n * that is requested. Multiple results are returned in case of multiple matches.\n *\n * `manufacturer` name can be a partial name, or a full name for more specificity, e.g. \"988\",\n * \"honda\", \"HONDA OF CANADA MFG., INC.\", etc.\n *\n * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id.\n * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the\n *   provided name. It accepts a partial manufacturer name as an input.\n *\n * @param {(string|number)} manufacturer - Manufacturer Name or ID\n * @returns {(Promise<NhtsaResponse<GetMakeForManufacturerResults>>)} - Api Response object\n */\nexport const GetMakeForManufacturer = async (\n  manufacturer: string | number\n): Promise<NhtsaResponse<GetMakeForManufacturerResults>> => {\n  const endpointName = 'GetMakeForManufacturer'\n\n  try {\n    const args: IArgToValidate[] = [\n      {\n        name: 'manufacturer',\n        value: manufacturer,\n        required: true,\n        types: ['string', 'number'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: manufacturer.toString() })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetMakeForManufacturer endpoint\n *\n * @alias GetMakeForManufacturerResults\n */\nexport type GetMakeForManufacturerResults = {\n  Make_ID: number\n  Make_Name: string\n  Mfr_Name: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetMakesForManufacturerAndYear` returns all the Makes in the vPIC dataset for a specified\n * `manufacturer`, and whose \"Year From\" and \"Year To\" range cover the specified `year`. Multiple\n * results are returned in case of multiple matches.\n *\n * Both `manufacturer` and `params.year` are required.\n *\n * `manufacturer` name can be a partial name, or a full name for more specificity, e.g. \"988\",\n * \"honda\", \"HONDA OF CANADA MFG., INC.\", etc.\n *\n * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id.\n * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the\n *   provided name. It accepts a partial manufacturer name as an input.\n *\n * `params.year` must be a number > 2016, years prior to 2016 are not supported according to the\n * NHTSA API.\n *\n * @param {(string|number)} manufacturer - Manufacturer Name (string) or Manufacturer ID (number)\n * @param params - Object of Query Search names and values to append to the URL as a query string\n * @param {(string|number)} params.year - Model year of the vehicle - Number, >= 2016\n * @returns {(Promise<NhtsaResponse<GetMakesForManufacturerAndYearResults>>)} - Api Response object\n */\nexport const GetMakesForManufacturerAndYear = async (\n  manufacturer: string,\n  params: {\n    year: string | number\n  }\n): Promise<NhtsaResponse<GetMakesForManufacturerAndYearResults>> => {\n  const endpointName = 'GetMakesForManufacturerAndYear'\n\n  try {\n    const args: IArgToValidate[] = [\n      {\n        name: 'manufacturer',\n        value: manufacturer,\n        required: true,\n        types: ['string', 'number'],\n      },\n      { name: 'params', value: params, required: true, types: ['object'] },\n      {\n        name: 'year',\n        value: params.year,\n        required: true,\n        types: ['string', 'number'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({\n      endpointName,\n      path: manufacturer.toString(),\n      params,\n    })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetMakesForManufacturerAndYear endpoint\n *\n * @alias GetMakesForManufacturerAndYearResults\n */\nexport type GetMakesForManufacturerAndYearResults = {\n  MakeId: number\n  MakeName: string\n  MfrId: number\n  MfrName: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetMakesForVehicleType` returns all the Makes in the vPIC dataset for a specified vehicle type\n * (`typeName`), whose name is LIKE the vehicle type name in vPIC Dataset.\n *\n * `typeName` can be a partial name, or a full name for more specificity, e.g., \"Vehicle\", \"Moto\",\n * \"Low Speed Vehicle\", etc.\n *\n * @param {string} typeName - A partial or full vehicle type name\n * @returns {(Promise<NhtsaResponse<GetMakesForVehicleTypeResults>>)} - Api Response object\n */\nexport const GetMakesForVehicleType = async (\n  typeName: string\n): Promise<NhtsaResponse<GetMakesForVehicleTypeResults>> => {\n  const endpointName = 'GetMakesForVehicleType'\n\n  try {\n    const args: IArgToValidate[] = [\n      {\n        name: 'typeName',\n        value: typeName,\n        required: true,\n        types: ['string'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: typeName })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetMakesForVehicleType endpoint\n *\n * @alias GetMakesForVehicleTypeResults\n */\nexport type GetMakesForVehicleTypeResults = {\n  MakeId: number\n  MakeName: string\n  VehicleTypeId: number\n  VehicleTypeName: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetManufacturerDetails` provides the details for a specific manufacturer that is requested.\n * Multiple results are returned in case of multiple matches.\n *\n * `manufacturer` name can be a partial name, or a full name for more specificity, e.g. \"988\",\n * \"honda\", \"HONDA OF CANADA MFG., INC.\", etc.\n *\n * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id.\n * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the\n *   provided name. It accepts a partial manufacturer name as an input.\n *\n * @param {(string|number)} manufacturer - Manufacturer Name or ID\n * @returns {(Promise<NhtsaResponse<GetManufacturerDetailsResults>>)} - Api Response object\n */\nexport const GetManufacturerDetails = async (\n  manufacturer: string | number\n): Promise<NhtsaResponse<GetManufacturerDetailsResults>> => {\n  const endpointName = 'GetManufacturerDetails'\n\n  try {\n    const args: IArgToValidate[] = [\n      {\n        name: 'manufacturer',\n        value: manufacturer,\n        required: true,\n        types: ['string', 'number'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: manufacturer.toString() })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetManufacturerDetails endpoint\n *\n * @alias GetManufacturerDetailsResults\n */\nexport type GetManufacturerDetailsResults = {\n  Address: string | null\n  Address2: string | null\n  City: string | null\n  ContactEmail: string | null\n  ContactFax: string | null\n  ContactPhone: string | null\n  Country: string | null\n  DBAs: string | null\n  EquipmentItems: Array<unknown>\n  LastUpdated: string\n  ManufacturerTypes: Array<{\n    Name: string\n  }>\n  Mfr_CommonName: string | null\n  Mfr_ID: number | null\n  Mfr_Name: string | null\n  OtherManufacturerDetails: string | null\n  PostalCode: string | null\n  PrimaryProduct: string | null\n  PrincipalFirstName: string | null\n  PrincipalLastName: string | null\n  PrincipalPosition: string | null\n  StateProvince: string | null\n  SubmittedName: string | null\n  SubmittedOn: string\n  SubmittedPosition: string | null\n  VehicleTypes: Array<{\n    GVWRFrom: string\n    GVWRTo: string\n    IsPrimary: boolean\n    Name: string\n  }>\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetModelsForMake` returns the Models in the vPIC dataset for a specified `makeName`\n * whose Name is LIKE the Make in vPIC Dataset.\n *\n * `makeName` can be a partial, or a full for more specificity, e.g., \"Harley\",\n * \"Harley Davidson\", etc.\n *\n * @param {string} makeName - Vehicle make name\n * @returns {(Promise<NhtsaResponse<GetModelsForMakeResults>>)} - Api Response object\n */\nexport const GetModelsForMake = async (\n  makeName: string\n): Promise<NhtsaResponse<GetModelsForMakeResults>> => {\n  const endpointName = 'GetModelsForMake'\n\n  try {\n    const args: IArgToValidate[] = [\n      {\n        name: 'makeName',\n        value: makeName,\n        required: true,\n        types: ['string'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: makeName })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetModelsForMake endpoint\n *\n * @alias GetModelsForMakeResults\n */\nexport type GetModelsForMakeResults = {\n  Make_ID: number\n  Make_Name: string\n  Model_ID: number\n  Model_Name: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetModelsForMakeId` returns the Models in the vPIC dataset for a specified Make whose ID is\n * equal to the `makeID` in the vPIC Dataset.\n *\n * You can get `makeID`s via `MAKE_ID` key in Results objects of the following endpoints:\n * - `GetAllMakes` endpoint\n * - `GetMakeForManufacturer` endpoint\n * - `GetModelsForMake` endpoint\n * - `GetModelsForMakeYear` endpoint\n *\n * You can get `makeID`s via `MakeID` key in Results objects of the following endpoints:\n * - `DecodeVinValues`\n * - `DecodeVinValuesBatch`\n *\n * You can get `makeID`s via `ValueId` key in Results objects of the following endpoints.\n * One of the objects in the `Results` array will contain both `Variable: \"Make\"` and\n * `VariableId: 26`. The `ValueId` key in that same object is the `makeID` for use in this\n * endpoint.\n * - `DecodeVin`\n * - `DecodeVinExtended`\n *\n * @param {(string|number)} makeId - Make ID to search\n * @returns {(Promise<NhtsaResponse<GetModelsForMakeIdResults>>)} - Api Response object\n */\nexport const GetModelsForMakeId = async (\n  makeId: string | number\n): Promise<NhtsaResponse<GetModelsForMakeIdResults>> => {\n  const endpointName = 'GetModelsForMakeId'\n\n  try {\n    const args: IArgToValidate[] = [\n      {\n        name: 'makeId',\n        value: makeId,\n        required: true,\n        types: ['string', 'number'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: makeId.toString() })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetModelsForMakeId endpoint\n *\n * @alias GetModelsForMakeIdResults\n */\nexport type GetModelsForMakeIdResults = {\n  Make_ID: number\n  Make_Name: string\n  Model_ID: number\n  Model_Name: string\n}\n","import { useNHTSA } from '@/api'\nimport {\n  catchInvalidArguments,\n  encodeQueryStringParams,\n  rejectWithError,\n} from '@/utils'\nimport type { IArgToValidate, NhtsaResponse, AtLeastOne } from '@/types'\n\n/**\n * `GetModelsForMakeIdYear` returns the Models in the vPIC dataset for a specified Model Year\n * and Make whose name is LIKE the Make in the vPIC Dataset.\n *\n * `params.makeId` is required\n *\n * A minimum of one of the following are also required (or a combination of both):\n * - `params.modelYear` year you want to search for (years >= 1995 are supported according to NHTSA\n *   docs)\n * - `params.vehicleType` can be a partial name, or a full name for more specificity, e.g.,\n *   \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.\n *\n * You can get `makeID`s via `MAKE_ID` key in Results objects of the following endpoints:\n * - `GetAllMakes` endpoint\n * - `GetMakeForManufacturer` endpoint\n * - `GetModelsForMake` endpoint\n * - `GetModelsForMakeYear` endpoint\n *\n * You can get `makeID`s via `MakeID` key in Results objects of the following endpoints:\n * - `DecodeVinValues`\n * - `DecodeVinValuesBatch`\n *\n * You can get `makeID`s via `ValueId` key in Results objects of the following endpoints.\n * One of the objects in the `Results` array will contain both `Variable: \"Make\"` and\n * `VariableId: 26`. The `ValueId` key in that same object is the `makeID` for use in this\n * endpoint.\n * - `DecodeVin`\n * - `DecodeVinExtended`\n *\n * _NOTE:_ This endpoint requires special handling of the params object, such that none of the\n * params are used in the query string and are instead used as part of the URL path for the\n * endpoint. To account for this, we pass the params object to the `createUrl` function as the\n * `path`, after encoding the params object key:values into a url path string.\n *\n * @param params - Object of Query Search names and values to append to the URL as a query string\n * @param {(string|number)} params.makeId - Make ID to search\n * @param {(string|number)} [params.modelYear] - A number representing the model year to search\n * @param {string} [params.vehicleType] - String representing the vehicle type to search\n * @returns {(Promise<NhtsaResponse<GetModelsForMakeIdYearResults>>)} Api Response object\n */\nexport const GetModelsForMakeIdYear = async (\n  params: {\n    makeId: string | number\n  } & AtLeastOne<{\n    modelYear?: string | number\n    vehicleType?: string\n  }>\n): Promise<NhtsaResponse<GetModelsForMakeIdYearResults>> => {\n  const endpointName = 'GetModelsForMakeIdYear'\n\n  try {\n    /* Validate the arguments */\n    const atLeastOne: IArgToValidate[] = [\n      {\n        name: 'modelYear',\n        value: params.modelYear,\n        types: ['string', 'number'],\n      },\n      {\n        name: 'vehicleType',\n        value: params.vehicleType,\n        types: ['string'],\n      },\n    ]\n    const args: IArgToValidate[] = [\n      { name: 'params', value: params, required: true, types: ['object'] },\n      {\n        name: 'makeId',\n        value: params.makeId,\n        required: true,\n        types: ['string'],\n      },\n      ...atLeastOne,\n    ]\n    catchInvalidArguments({ args })\n    catchInvalidArguments({ args: atLeastOne, mode: 'atLeast' })\n\n    /*\n     * Params for this endpoint are not part of the query string, instead they are part of the URL\n     * path. This means params are never run through createQueryString() and won't be URI component\n     * encoded without this.\n     */\n    const { makeId, modelYear, vehicleType } = encodeQueryStringParams(params)\n\n    /* Build the URL */\n    let path = `/make/${makeId}/`\n    path += modelYear ? `modelYear/${modelYear}` : ''\n    path += vehicleType\n      ? `${modelYear ? '/' : ''}vehicleType/${vehicleType}/`\n      : ''\n\n    return useNHTSA().get({ endpointName, path })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetModelsForMakeIdYear endpoint\n *\n * @alias GetModelsForMakeIdYearResults\n */\nexport type GetModelsForMakeIdYearResults = {\n  Make_ID: number\n  Make_Name: string\n  Model_ID: number\n  Model_Name: string\n}\n","import { useNHTSA } from '@/api'\nimport {\n  catchInvalidArguments,\n  encodeQueryStringParams,\n  rejectWithError,\n} from '@/utils'\nimport type { NhtsaResponse, IArgToValidate, AtLeastOne } from '@/types'\n\n/**\n * `GetModelsForMakeYear` returns the Models in the vPIC dataset for a specified Model Year and\n * Make whose name is LIKE the Make in the vPIC Dataset.\n *\n * `params.make` is required. It can be a partial, or a full name for more specificity, e.g.,\n * \"Harley\", \"Harley Davidson\", etc.\n *\n * A minimum of one of the following are also required (or a combination of both):\n * - `params.modelYear` year you want to search for (years >= 1995 are supported according to NHTSA\n *   docs)\n * - `params.vehicleType` can be a partial name, or a full name for more specificity, e.g.,\n *   \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.\n *\n * _NOTE:_ This endpoint requires special handling of the params object, such that none of the\n * params are used in the query string and are instead used as part of the URL path for the\n * endpoint. To account for this, we pass the params object to the `createUrl` function as the\n * `path`, after encoding the params object key:values into a url path string.\n *\n * @param params - Object of Query Search names and values to append to the URL as a query string\n * @param {string} params.make - Make name to search\n * @param {(string|number)} [params.modelYear] - A number representing the model year to search\n * (required if !vehicleType)\n * @param {string} [params.vehicleType] - String representing the vehicle type to search\n * (required if !modelYear)\n * @returns {(Promise<NhtsaResponse<GetModelsForMakeYearResults>>)} Api Response object\n */\nexport const GetModelsForMakeYear = async (\n  params: { make: string } & AtLeastOne<{\n    modelYear?: string | number\n    vehicleType?: string\n  }>\n): Promise<NhtsaResponse<GetModelsForMakeYearResults>> => {\n  const endpointName = 'GetModelsForMakeYear'\n\n  try {\n    /* Validate the arguments */\n    const atLeastOne: IArgToValidate[] = [\n      {\n        name: 'modelYear',\n        value: params.modelYear,\n        types: ['string', 'number'],\n      },\n      {\n        name: 'vehicleType',\n        value: params.vehicleType,\n        types: ['string'],\n      },\n    ]\n    const args: IArgToValidate[] = [\n      { name: 'params', value: params, required: true, types: ['object'] },\n      { name: 'make', value: params.make, required: true, types: ['string'] },\n      ...atLeastOne,\n    ]\n    catchInvalidArguments({ args })\n    catchInvalidArguments({ args: atLeastOne, mode: 'atLeast' })\n\n    /*\n     * Params for this endpoint are not part of the query string, instead they are part of the URL\n     * path. This means params are never run through createQueryString() and won't be URI component\n     * encoded without this.\n     */\n    const { make, modelYear, vehicleType } = encodeQueryStringParams(params)\n\n    /* Build the URL */\n    let path = `/make/${make}/`\n    path += modelYear ? `modelYear/${modelYear}` : ''\n    path += vehicleType\n      ? `${modelYear ? '/' : ''}vehicleType/${vehicleType}/`\n      : ''\n\n    return useNHTSA().get({ endpointName, path })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetModelsForMakeYear endpoint\n *\n * @alias GetModelsForMakeYearResults\n */\nexport type GetModelsForMakeYearResults = {\n  Make_ID: number\n  Make_Name: string\n  Model_ID: number\n  Model_Name: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetParts` provides a list of ORGs with letter date in the given range of the dates and with\n * specified Type (`params.type`) of ORG.\n *\n * - Up to 1000 results will be returned at a time.\n * - Get the next page by incrementing the `params.page` query parameter.\n *\n * All query `params` are optional.\n *\n * `params.type`:\n * - (optional) number, 565 (Vehicle Identification Number Guidance, based on 49 CFR Part 565)\n *   or 566 (Manufacturer Identification – Reporting Requirements based on 49 CFR Part 566)\n * `params.fromDate`:\n * - (optional) ORG's Letter Date should be on or after this date\n * `params.manufacturer`:\n * - (optional) if supplied value is a number - method will do exact match on Manufacturer's Id\n * - if supplied value is a string - it will look for manufacturers whose name is LIKE the provided\n *   name\n * - it accepts a partial manufacturer name as an input\n * - multiple results are returned in case of multiple matches\n * - manufacturer name can be a partial name, or a full name for more specificity, e.g., \"988\",\n *   \"HONDA\", \"HONDA OF CANADA MFG., INC.\", etc.\n * `params.page`:\n *  - (optional) number, 1 (default) first 1000 records, 2 - next 1000 records, etc\n *\n * @param [params] - Object of Query Search names and values to append to the URL as a query string\n * @param {(string|number)} [params.type] - Specified type of ORG to search\n * @param {string} [params.fromDate] - Start date of search query\n * @param {string} [params.toDate] - End date of search query\n * @param {(string|number)} [params.page] - Which page number of results to request (100 results per page)\n * @returns {(Promise<NhtsaResponse<GetPartsResults>>)} - Api Response object\n */\nexport const GetParts = async (params?: {\n  type?: string | number\n  fromDate?: string\n  toDate?: string\n  page?: string | number\n}): Promise<NhtsaResponse<GetPartsResults>> => {\n  const endpointName = 'GetParts'\n\n  try {\n    /* Validate the arguments */\n    const args: IArgToValidate[] = [\n      { name: 'params', value: params, types: ['object'] },\n      { name: 'type', value: params?.type, types: ['string', 'number'] },\n      { name: 'fromDate', value: params?.fromDate, types: ['string'] },\n      { name: 'toDate', value: params?.toDate, types: ['string'] },\n      { name: 'page', value: params?.page, types: ['string', 'number'] },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, params })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetParts endpoint\n *\n * @alias GetPartsResults\n */\nexport type GetPartsResults = {\n  CoverLetterURL: string\n  LetterDate: string\n  ManufacturerId: number\n  ManufacturerName: string\n  ModelYearFrom: number | null\n  ModelYearTo: number | null\n  Name: string\n  Type: string\n  URL: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetVehicleTypesForMake` returns all the Vehicle Types in the vPIC dataset for a specified Make,\n * whose name is LIKE the make name in the vPIC Dataset.\n *\n * `makeName` can be a partial name, or a full name for more specificity, e.g., \"Merc\",\n * \"Mercedes Benz\", etc.\n *\n * @param {string} makeName - Name of the vehicle make to search\n * @returns {(Promise<NhtsaResponse<GetVehicleTypesForMakeResults>>)} - Api Response object\n */\nexport const GetVehicleTypesForMake = async (\n  makeName: string\n): Promise<NhtsaResponse<GetVehicleTypesForMakeResults>> => {\n  const endpointName = 'GetVehicleTypesForMake'\n\n  try {\n    const args: IArgToValidate[] = [\n      {\n        name: 'makeName',\n        value: makeName,\n        required: true,\n        types: ['string'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: makeName })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetVehicleTypesForMake endpoint\n *\n * @alias GetVehicleTypesForMakeResults\n */\nexport type GetVehicleTypesForMakeResults = {\n  MakeId: number\n  MakeName: string\n  VehicleTypeId: number\n  VehicleTypeName: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetVehicleTypesForMakeId` returns the Models in the vPIC dataset for a specified Make\n * whose ID is equal to the `makeID` in the vPIC Dataset.\n *\n * You can get `makeID`s via `MAKE_ID` key in Results objects of the following endpoints:\n * - `GetAllMakes` endpoint\n * - `GetMakeForManufacturer` endpoint\n * - `GetModelsForMake` endpoint\n * - `GetModelsForMakeYear` endpoint\n *\n * You can get `makeID`s via `MakeID` key in Results objects of the following endpoints:\n * - `DecodeVinValues`\n * - `DecodeVinValuesBatch`\n *\n * You can get `makeID`s via `ValueId` key in Results objects of the following endpoints.\n * One of the objects in the `Results` array will contain both `Variable: \"Make\"` and\n * `VariableId: 26`. The `ValueId` key in that same object is the `makeID` for use in this\n * endpoint.\n * - `DecodeVin`\n * - `DecodeVinExtended`\n *\n * @param {(string|number)} makeId - Make ID to search\n * @returns {(Promise<NhtsaResponse<GetVehicleTypesForMakeIdResults>>)} - Api Response object\n */\nexport const GetVehicleTypesForMakeId = async (\n  makeId: string | number\n): Promise<NhtsaResponse<GetVehicleTypesForMakeIdResults>> => {\n  const endpointName = 'GetVehicleTypesForMakeId'\n\n  try {\n    const args: IArgToValidate[] = [\n      {\n        name: 'makeId',\n        value: makeId,\n        required: true,\n        types: ['string', 'number'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: makeId.toString() })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetVehicleTypesForMakeId endpoint\n *\n * @alias GetVehicleTypesForMakeIdResults\n */\nexport type GetVehicleTypesForMakeIdResults = {\n  MakeId: number\n  MakeName: string\n  VehicleTypeId: number\n  VehicleTypeName: string\n}\n","import { useNHTSA } from '@/api'\nimport { rejectWithError } from '@/utils'\nimport type { NhtsaResponse } from '@/types'\n\n/**\n * `GetVehicleVariableList` provides a list of all the Vehicle related variables that are in the\n * vPIC dataset. Information on the name, description and the type of the variable is provided.\n *\n * @returns {(Promise<NhtsaResponse<GetVehicleVariableListResults>>)} - Api Response object\n */\nexport const GetVehicleVariableList = async (): Promise<\n  NhtsaResponse<GetVehicleVariableListResults>\n> => {\n  const endpointName = 'GetVehicleVariableList'\n\n  try {\n    return useNHTSA().get({ endpointName })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetVehicleVariableList endpoint\n *\n * @alias GetVehicleVariableListResults\n */\nexport type GetVehicleVariableListResults = {\n  DataType: 'string' | 'int' | 'decimal' | 'lookup'\n  Description: string\n  GroupName: string | null\n  ID: number\n  Name: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetVehicleVariableValuesList` provides a list of all the accepted values for a given variable\n * that are stored in the vPIC dataset.\n *\n * If `variableValue` is a string, it must use full name, not just part of it, e.g.,\n * \"Battery Type\", not \"Battery\"\n *\n * `variableValue` can be also be a number, which is the ID of the variable, e.g., 1, 2, 3, etc.\n *\n * @param {(string|number)} variableValue - The variable you want to get a values list of\n * @returns {(Promise<NhtsaResponse<GetVehicleVariableValuesListResults>>)} - Api Response object\n */\nexport const GetVehicleVariableValuesList = async (\n  variableValue: number | string\n): Promise<NhtsaResponse<GetVehicleVariableValuesListResults>> => {\n  const endpointName = 'GetVehicleVariableValuesList'\n\n  try {\n    const args: IArgToValidate[] = [\n      {\n        name: 'variableValue',\n        value: variableValue,\n        required: true,\n        types: ['string', 'number'],\n      },\n    ]\n    catchInvalidArguments({ args })\n\n    return useNHTSA().get({ endpointName, path: variableValue.toString() })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetVehicleVariableValuesList endpoint\n *\n * @alias GetVehicleVariableValuesListResults\n */\nexport type GetVehicleVariableValuesListResults = {\n  ElementName: string\n  Id: number\n  Name: string\n}\n","import { useNHTSA } from '@/api'\nimport { catchInvalidArguments, rejectWithError } from '@/utils'\nimport type { AtLeastOne, IArgToValidate, NhtsaResponse } from '@/types'\n\n/**\n * `GetWMIsForManufacturer` provides information on the World Manufacturer Identifier (WMI) for a\n * specified `manufacturer`. Only WMIs registered in vPICList are displayed. Multiple results are\n * returned in case of multiple matches.\n *\n * Both `manufacturer` and `vehicleType` are optional but at least one must be provided.\n *\n * `manufacturer` can be a partial name, or a full name for more specificity, or WMI ID number,\n *  e.g., \"Merc\", \"Mercedes Benz\", 987, etc.\n * - If `manufacturer` is a number - method will do exact match on Manufacturer's Id\n * - If `manufacturer` is a string - it will look for manufacturers whose name is LIKE the provided\n *   name (it accepts a partial Manufacturer name as an input)\n *\n * `vehicleType` can be a string or number, e.g., \"car\", 1, etc.\n * - If `vehicleType` is a number - method will do exact match on VehicleType's Id\n * - If `vehicleType` is a string - it will look for VehicleType whose name is LIKE the provided\n *   name (it accepts a partial VehicleType name as an input).\n *\n * For this endpoint, `manufacturer` is actually part of the path string, not a query param. We\n * include `manufacturer` in params as it's easier to type the function args using the 'AtLeastOne'\n * type if they are placed in the same object (params). This can cause confusion as it's not\n * consistent with other endpoint methods where path string is the first arg, and the query params\n * are the second arg.\n *\n * @param [params] - Object of Query Search names and values to append to the URL as a query string\n * @param {(string|number)} [params.manufacturer] - Manufacturer Name or ID, or WMI ID\n * (required if !vehicleType)\n * @param {(string|number)} [params.vehicleType] - Optional Vehicle Type search parameter\n * (required if !manufacturer)\n * @returns {(Promise<NhtsaResponse<GetWMIsForManufacturerResults>>)} - Api Response object\n */\nexport const GetWMIsForManufacturer = async (\n  params: AtLeastOne<{\n    manufacturer?: string | number\n    vehicleType?: string | number\n  }>\n): Promise<NhtsaResponse<GetWMIsForManufacturerResults>> => {\n  const endpointName = 'GetWMIsForManufacturer'\n\n  try {\n    /* Validate the arguments */\n    const atLeastOne: IArgToValidate[] = [\n      {\n        name: 'manufacturer',\n        value: params?.manufacturer,\n        types: ['string', 'number'],\n      },\n      {\n        name: 'vehicleType',\n        value: params?.vehicleType,\n        types: ['string', 'number'],\n      },\n    ]\n    const args: IArgToValidate[] = [\n      { name: 'params', value: params, required: true, types: ['object'] },\n      ...atLeastOne,\n    ]\n    catchInvalidArguments({ args })\n    catchInvalidArguments({ args: atLeastOne, mode: 'atLeast' })\n\n    /* manufacturer is part of the path string, not a query param */\n    const manufacturer = params?.manufacturer\n      ? encodeURIComponent(params.manufacturer)\n      : ''\n    const vehicleType = params?.vehicleType || ''\n\n    return useNHTSA().get({\n      endpointName,\n      path: manufacturer,\n      params: { vehicleType },\n    })\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Objects found in the NhtsaResponse 'Results' array of GetWMIsForManufacturer endpoint\n *\n * @alias GetWMIsForManufacturerResults\n */\nexport type GetWMIsForManufacturerResults = {\n  Country: string | null\n  CreatedOn: string\n  DateAvailableToPublic: string\n  Id: number\n  Name: string\n  UpdatedOn: string\n  VehicleType: string\n  WMI: string\n}\n","import {\n  catchInvalidArguments,\n  createQueryString,\n  getTypeof,\n  rejectWithError,\n} from '@/utils'\nimport { NHTSA_BASE_URL, NHTSA_RESPONSE_FORMAT } from '@/constants'\nimport type { NhtsaResponse, QueryStringParams } from '@/types'\n\nexport type CreateUrlOptions = {\n  endpointName: string\n  allowEmptyParams?: boolean\n  includeQueryString?: boolean\n  path?: string\n  params?: QueryStringParams\n  saveUrl?: boolean\n}\n\n/**\n *This is the main composable function that is used to make requests to the NHTSA API.\n *\n * `useNHTSA` is a composable function that returns an object containing methods for making HTTP\n * requests to the NHTSA API. All request methods return a Promise that resolves to an object\n * containing the response data, see [NhtsaApiResponse](#TODO-LINK-TO-DOCS) type.\n *\n * Pleas see the [`/api` README](https://github.com/shaggytech/nhtsa-api-wrapper/packages/lib/src/api)\n * for more information on the exported methods and how to use them.\n *\n * ---\n *\n * The exported methods are:\n *\n * - `get` - Makes a GET request, uses the internal url variable if no URL is provided\n *\n * - `post` - Makes a POST request, uses the internal url variable if no URL is provided\n *\n * - `cacheUrl` - Builds the URL string and stores it in internal state\n *\n * - `createUrl` - Builds the URL string but does not store it in internal state\n *\n * - `getURL` - Returns the internal URL string\n *\n */\nexport const useNHTSA = () => {\n  /* Internal State */\n  let _url: string\n\n  /** Gets url from internal state */\n  const getUrl = () => _url\n\n  /** Function to create final POST body string */\n  const createPostBody = (data: string) => {\n    return encodeURI(`DATA=${data}&format=${NHTSA_RESPONSE_FORMAT}`)\n  }\n\n  /**\n   * This builds the URL string and sets it as a private variable in the composable instance if\n   * saveUrl option is true.\n   *\n   * Takes an object of type `CreateUrlOptions` as an argument and returns a full URL string.\n   *\n   * Set `allowEmptyParams` to true to allow empty parameters in the query string. This is useful if\n   * you need to make a request with an empty parameter in some endpoints.\n   *\n   * Set `includeQueryString` to false to exclude the query string from the built URL string. This\n   * is useful if you need to make a POST request with a URL that already has a query string in the\n   * POST body.\n   *\n   * `path` is a search parameter that is not part of the query string for most NHSTA API endpoints.\n   * For example if decoding a VIN, the path would be the VIN number. If you need to make a request\n   * with a path, set `path` to the path string.\n   *\n   * `params` is an object containing the query string parameters to build into the URL. Default\n   * query \"format=json\" is always included unless `includeQueryString` is false.\n   *\n   * `saveUrl` is a boolean that determines whether to save the URL in the composable instance.\n   * Default is true.\n   *\n   * @param options Object of type `CreateUrlOptions` containing the following properties:\n   * @param {string} options.endpointName - Name of the endpoint to use in the URL (required)\n   * @param {boolean} [options.allowEmptyParams=false] - Whether to allow empty parameters in the\n   * query string (default: false).\n   * @param {boolean} [options.includeQueryString=true] - Whether to include the query string in\n   * the built URL string (default: true). Set to false if making a POST request.\n   * @param {string} [options.path=''] - Path to append to the URL (default: '')\n   * @param {Object} [options.params] - Query string parameters to build into the URL. Default\n   * query \"format=json\" is always included unless options.includeQueryString is false.\n   * @param {boolean} [options.saveUrl=true] - Whether to save the URL in the composable instance\n   * (default: true)\n   * @returns {string} URL string\n   */\n  const cacheUrl = ({\n    endpointName,\n    allowEmptyParams = false,\n    includeQueryString = true,\n    path = '',\n    params,\n    saveUrl = true,\n  }: CreateUrlOptions): string => {\n    if (!endpointName) {\n      throw Error('Endpoint name is required to create URL string')\n    }\n\n    const queryString = includeQueryString\n      ? createQueryString(params, allowEmptyParams)\n      : ''\n\n    const url = encodeURI(\n      `${NHTSA_BASE_URL}/${endpointName}/${path}${queryString}`\n    )\n\n    if (saveUrl) {\n      _url = url\n    }\n\n    return url\n  }\n\n  /**\n   * Simply a wrapper for cacheUrl() with saveUrl set to false.\n   *\n   * Takes an object of type `CreateUrlOptions` as an argument and returns a full URL string.\n   *\n   * This builds the URL string but does not set it as a private cached variable of the composable.\n   *\n   * @param options Object of type `CreateUrlOptions` containing the following properties:\n   * @param {string} options.endpointName - Name of the endpoint to use in the URL (required)\n   * @param {boolean} [options.allowEmptyParams=false] - Whether to allow empty parameters in the\n   * query string (default: false).\n   * @param {boolean} [options.includeQueryString=true] - Whether to include the query string in\n   * the built URL string (default: true). Set to false if making a POST request.\n   * @param {string} [options.path=''] - Path to append to the URL (default: '')\n   * @param {Object} [options.params] - Query string parameters to build into the URL. Default\n   * query \"format=json\" is always included unless options.includeQueryString is false.\n   * @returns {string} URL string\n   */\n  const createUrl = (options: CreateUrlOptions) => {\n    return cacheUrl({ ...options, saveUrl: false })\n  }\n\n  /**\n   * This uses native `fetch()` to make a request to the NHTSA API. Returns a promise that\n   * resolves to a `NhtsaApiResponse<T>` object, where `T` is the type of the objects in the\n   * `Results` array of the `NhtsaApiResponse` object, e.g. `NhtsaApiResponse<DecodeVinResults>`.\n   *\n   * _NOTE:_ All POST requests should use the post() method of this composable, which sets specific\n   * POST fetch options before calling this method. Never call this method directly for POST\n   * requests.\n   *\n   * ---\n   *\n   * ### url\n   *\n   * `url` is optional. If not provided, the URL string saved in the composable instance will be\n   * used for the request. If no URL has been saved in the composable instance, an error will be\n   * thrown stating that a url arg is required.\n   *\n   * `url` - either a full url `string` or an `object` of type `CreateUrlOptions`\n   *\n   * - `required` if there is no url cached in the composable instance\n   * - if a `CreateUrlOptions` object is provided, `cacheUrl` will be called with the object to\n   *   build and cache the url before making the request\n   * - if a string is provided, it is assumed the string is a full url and it will be cached in the\n   *   as such in the composable instance before making the request\n   *\n   * ### Options\n   *\n   * If you need to set custom fetch options for request, set them in the `options` object.\n   *\n   * `options` is optional. If provided, it should be an object containing following properties:\n   * - `options.saveUrl` - Whether to save the URL string in the composable instance after\n   *   the request is made (default: true).\n   * - `options.body` - string to send in the NHTSA API POST request. (example: \"modelYear=2009\")\n   * - Any other valid `RequestInit` options:\n   *   https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\n   *\n   * If `options.saveUrl` is true, the URL string will be saved in the composable instance after the\n   * request is made. If false, the URL string will _not_ be saved in the composable instance and a\n   * new URL string will need to be created for the next request.\n   *\n   * When called from post(), you should set `options.includeQueryString` to false as query strings\n   * are not allowed in a POST request. In POST requests, \"&format=json\" is appended to the POST\n   * body string instead of in the query string. Using the post method direclty for POST requests\n   * will automatically set `options.includeQueryString` to false and append \"&format=json\" to the\n   * POST body string.\n   *\n   * @param {string} [url] - URL string to use for the request\n   * @param [options] - Object containing RequestInit options + custom options\n   * @param {boolean} [options.saveUrl=true] - Whether to save the URL string in the composable\n   * instance\n   * @returns {Promise<NhtsaApiResponse>} Promise that resolves to a NhtsaApiResponse object\n   */\n  const get = async <T>(\n    url?: string | CreateUrlOptions,\n    options: RequestInit & { saveUrl?: boolean } = { saveUrl: true }\n  ): Promise<NhtsaResponse<T>> => {\n    /* If url is an object, create and store a url string from it */\n    if (url && getTypeof(url) === 'object') {\n      url = cacheUrl({ ...(url as CreateUrlOptions), saveUrl: options.saveUrl })\n    }\n\n    url = getTypeof(url) === 'string' ? url : getUrl()\n\n    catchInvalidArguments({\n      args: [\n        {\n          name: 'url',\n          value: url,\n          required: true,\n          types: ['string'],\n        },\n        {\n          name: 'options',\n          value: options,\n          types: ['object'],\n        },\n      ],\n    })\n\n    /* url guranateed to be a string at this point, so ok to cast it */\n    if (options.saveUrl) {\n      _url = url as string\n    }\n\n    const nhtsaResponse: NhtsaResponse<T> = await fetch(url as string, options)\n      .then(async (response) => {\n        if (!response) {\n          throw Error(\n            `APi responded with an error, no response object returned`\n          )\n        }\n        const contentType = response.headers.get('content-type')\n        const responseDetails =\n          `content-type: ${contentType},` +\n          `responseStatus: ${response.status},` +\n          `responseUrl: ${response.url}`\n\n        if (!response.ok) {\n          throw Error(`APi responded with an error, got ${responseDetails}`)\n        }\n\n        const jsonTypes = ['application/json', 'text/json']\n        const isJson = jsonTypes.some((type) => contentType?.includes(type))\n        if (!isJson) {\n          throw Error(\n            `API response is not in JSON format, got ${responseDetails}`\n          )\n        }\n\n        const data: NhtsaResponse<T> = await response.json()\n        if (!data) {\n          throw Error(\n            `API response OK but returned no data, got ${responseDetails}`\n          )\n        } else return data\n      })\n      .catch((error: Error) => {\n        error.message = `There was an error fetching API data: ${error.message}`\n        return rejectWithError(error)\n      })\n\n    /* Return the completed ApiResponse */\n    return nhtsaResponse\n  }\n\n  /**\n   * This uses native `fetch()` to make a _POST_ request to the NHTSA API. Returns a promise that\n   * resolves to a `NhtsaApiResponse<T>` object, where `T` is the type of the objects in the\n   * `Results` array of the `NhtsaApiResponse` object, e.g. `NhtsaApiResponse<DecodeVinResults>`.\n   *\n   * `DecodeVinValueBatch` is the only NHTSA API endpoint that uses POST requests.\n   *\n   * This method sets specific POST fetch options before calling get(). All POST requests should use\n   * post() instead of calling get() directly as get() does not set the correct fetch options for\n   * POST.\n   *\n   * ---\n   *\n   * ### url\n   *\n   * `url` is optional. If not provided, the URL string saved in the composable instance will be\n   * used for the request. If no URL has been saved in the composable instance, an error will be\n   * thrown stating that a url arg is required.\n   *\n   * `url` - either a full url `string` or an `object` of type `CreateUrlOptions`\n   *\n   * - `required` if there is no url cached in the composable instance\n   * - if a `CreateUrlOptions` object is provided, `cacheUrl` will be called with the object to\n   *   build and cache the url before making the request\n   * - if a string is provided, it is assumed the string is a full url and it will be cached in the\n   *   as such in the composable instance before making the request\n   *\n   * ### Options\n   *\n   * If you need to set custom fetch options for request, set them in the `options` object.\n   *\n   * `options`: Object containing RequestInit options + custom options\n   * - `options.saveUrl` - Whether to save the URL string in the composable instance after\n   *   the request is made (default: true).\n   * - `options.body` - string to send in the NHTSA API POST request. (example: \"modelYear=2009\")\n   * - Any other valid `RequestInit` options:\n   *   https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\n   *\n   * If `options.saveUrl` is true, the URL string will be saved in the composable instance after the\n   * request is made. If false, the URL string will _not_ be saved in the composable instance and a\n   * new URL string will be need to be created for the next request.\n   *\n   * `options.body` should be a string consisting of the body request parameters in a format\n   * described further in the `DecodeVinValueBatch` endpoint documentation. Put simply, by default,\n   * \"DATA\" is prepended and \"&format=json\" appended to `options.body`, even if you\n   * don't provide `options.body`. This is required format for the NHTSA API POST request.\n   *\n   * @param {string} [url] - URL string to make the POST request to\n   * @param [options] - Object containing RequestInit options + custom options\n   * @param {boolean} [options.saveUrl=true] - Whether to save the URL string in the composable\n   * instance after the request is made (default: true).\n   * @param {string} [options.body] - Body string to send in the POST request. Default string\n   * \"&format=json\" is always appended to the body string.\n   * @returns {Promise<NhtsaApiResponse<T>>} Promise that resolves to a NhtsaApiResponse object\n   * containing the response data.\n   */\n  const post = async <T>(\n    url?: string | CreateUrlOptions,\n    options: RequestInit & { saveUrl?: boolean } = { saveUrl: true }\n  ): Promise<NhtsaResponse<T>> => {\n    /* If url is an object, create and store a url string from it */\n    if (url && getTypeof(url) === 'object') {\n      /* POST requests should not include query string */\n      url = cacheUrl({\n        ...(url as CreateUrlOptions),\n        saveUrl: options.saveUrl,\n        includeQueryString: false,\n      })\n    }\n\n    url = getTypeof(url) === 'string' ? url : getUrl()\n\n    catchInvalidArguments({\n      args: [\n        {\n          name: 'url',\n          value: url,\n          required: true,\n          types: ['string'],\n        },\n        {\n          name: 'options',\n          value: options,\n          types: ['object'],\n        },\n        {\n          name: 'options.body',\n          value: options.body,\n          types: ['string'],\n        },\n      ],\n    })\n\n    /* Set specific POST fetch options, url and body guaranteed to be a string after this point */\n    return await get(url, {\n      ...options,\n      method: 'POST',\n      headers: { 'content-type': 'application/x-www-form-urlencoded' },\n      body: createPostBody(options.body as string),\n    })\n  }\n\n  return {\n    getUrl,\n    cacheUrl,\n    createUrl,\n    createPostBody,\n    get,\n    post,\n  }\n}\n"],"names":["catchInvalidArguments","args","mode","getTypeof","arg","validateArgument","name","value","required","types","errorMode","error","typeofValue","errorPrepend","errorAppend","joinedTypes","isError","handleError","message","rejectWithError","toString","TRANSLITERATION_TABLE","WEIGHTS_ARRAY","isValidVin","vin","vinArray","checkDigit","checkValue","digit","index","digitValue","weight","acc","currValue","NHTSA_BASE_URL","NHTSA_RESPONSE_FORMAT","createQueryString","params","allowEmptyParams","_params","encodeQueryStringParams","key","array","DecodeVin","endpointName","useNHTSA","DecodeVinExtended","DecodeVinValues","DecodeVinValuesBatch","inputString","DecodeVinValuesExtended","DecodeWMI","WMI","GetAllMakes","GetAllManufacturers","GetCanadianVehicleSpecifications","GetEquipmentPlantCodes","GetMakeForManufacturer","manufacturer","GetMakesForManufacturerAndYear","GetMakesForVehicleType","typeName","GetManufacturerDetails","GetModelsForMake","makeName","GetModelsForMakeId","makeId","GetModelsForMakeIdYear","atLeastOne","modelYear","vehicleType","path","GetModelsForMakeYear","make","GetParts","GetVehicleTypesForMake","GetVehicleTypesForMakeId","GetVehicleVariableList","GetVehicleVariableValuesList","variableValue","GetWMIsForManufacturer","_url","getUrl","createPostBody","data","cacheUrl","includeQueryString","saveUrl","queryString","url","createUrl","options","get","response","contentType","responseDetails","type"],"mappings":"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"}