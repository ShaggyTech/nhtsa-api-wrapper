{"version":3,"file":"Client.js","sources":["../../node_modules/cross-fetch/dist/browser-ponyfill.js","../../src/api/Fetch.ts","../../src/api/actions/DecodeVin.ts","../../src/api/actions/DecodeVinExtended.ts","../../src/api/actions/DecodeVinValues.ts","../../src/api/actions/DecodeVinValuesExtended.ts","../../src/api/actions/DecodeWMI.ts","../../src/api/actions/GetAllMakes.ts","../../src/api/actions/GetAllManufacturers.ts","../../src/api/actions/GetCanadianVehicleSpecifications.ts","../../src/api/actions/GetEquipmentPlantCodes.ts","../../src/api/actions/GetMakeForManufacturer.ts","../../src/api/actions/GetMakesForManufacturerAndYear.ts","../../src/api/actions/GetMakesForVehicleType.ts","../../src/api/actions/GetManufacturerDetails.ts","../../src/api/actions/GetModelsForMake.ts","../../src/api/actions/GetModelsForMakeId.ts","../../src/api/actions/GetModelsForMakeIdYear.ts","../../src/api/actions/GetModelsForMakeYear.ts","../../src/api/actions/GetParts.ts","../../src/api/actions/GetVehicleTypesForMake.ts","../../src/api/actions/GetVehicleTypesForMakeId.ts","../../src/api/actions/GetVehicleVariableList.ts","../../src/api/actions/GetVehicleVariableValuesList.ts","../../src/api/actions/GetWMIsForManufacturer.ts","../../src/api/NHTSA.ts"],"sourcesContent":["var __self__ = (function (root) {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = root.DOMException\n}\nF.prototype = root;\nreturn new F();\n})(typeof self !== 'undefined' ? self : this);\n(function(self) {\n\nvar irrelevant = (function (exports) {\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  return exports;\n\n}({}));\n})(__self__);\ndelete __self__.fetch.polyfill\nexports = __self__.fetch // To enable: import fetch from 'cross-fetch'\nexports.default = __self__.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = __self__.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = __self__.Headers\nexports.Request = __self__.Request\nexports.Response = __self__.Response\nmodule.exports = exports\n","/**\r\n * @module api/Fetch\r\n */\r\n\r\n/* Module Dependencies */\r\nimport fetch from 'cross-fetch';\r\n/* Utilities */\r\nimport { getTypeof, makeQueryString } from '../utils';\r\n\r\n/**\r\n * @constant {string} BASE_URL Default Fetch base URL string\r\n * @default 'https://vpic.nhtsa.dot.gov/api/vehicles'\r\n */\r\nexport const BASE_URL = 'https://vpic.nhtsa.dot.gov/api/vehicles';\r\n\r\n/**\r\n * @constant {module:api/types.FetchConfig} DEFAULT_CONFIG Default Fetch configuration options\r\n * @property {string} apiResponseFormat=json\r\n * @property {string} baseUrl=BASE_URL\r\n */\r\nexport const DEFAULT_CONFIG: import('./types').FetchConfig = {\r\n  apiResponseFormat: 'json',\r\n  baseUrl: BASE_URL\r\n};\r\n\r\n/**\r\n * Class wrapper containing API wrapper HTTP Fetch logic.\r\n *\r\n * @param {module:api/types.FetchConfig} [userConfig] - User configuration options to construct the class with.\r\n */\r\nexport class Fetch {\r\n  apiResponseFormat?: string;\r\n  baseUrl?: string;\r\n  config?: import('./types').FetchConfig;\r\n\r\n  constructor(userConfig?: import('./types').FetchConfig) {\r\n    let finalConfig: import('./types').FetchConfig;\r\n\r\n    if (getTypeof(userConfig) === 'object') {\r\n      finalConfig = { ...DEFAULT_CONFIG, ...userConfig };\r\n    } else {\r\n      finalConfig = { ...DEFAULT_CONFIG };\r\n    }\r\n\r\n    /** @private */\r\n    this.apiResponseFormat = 'json';\r\n    /** @private */\r\n    this.baseUrl = finalConfig.baseUrl;\r\n    /** @private */\r\n    this.config = finalConfig;\r\n  }\r\n\r\n  /**\r\n   * Builds a query string from QueryStringParameters.\r\n   *\r\n   * @param {module:utils/types.QueryStringParameters} params - Object of query string search parameters.\r\n   * @param {boolean} [allowEmptyStringValues=false] - Allow empty query string parameters (as an empty string).\r\n   *\r\n   * @returns {(Promise<string | Error>)} A formatted NHSTA.dot.gov Vehicles API query string.\r\n   */\r\n  async buildQueryString(\r\n    params: import('../utils/types').QueryStringParameters,\r\n    allowEmptyStringValues = false\r\n  ): Promise<string | Error> {\r\n    /*\r\n     * Make sure we're always using 'format=json' in the url Query parameters\r\n     * If the user provides a 'format' key in the params, during class instantiation we want to override it to 'json'\r\n     * This package will never provide support for the other formats (CSV and XML)\r\n     */\r\n    if (!params || getTypeof(params) !== 'object') {\r\n      params = {\r\n        format: this.apiResponseFormat\r\n      };\r\n    } else {\r\n      params = { ...params, format: this.apiResponseFormat };\r\n    }\r\n\r\n    /* Return the completed query string */\r\n    return await makeQueryString(params, allowEmptyStringValues);\r\n  }\r\n\r\n  /**\r\n   * Uses the `cross-fetch` npm package to send HTTP requests and retrieve data from an API.\r\n   *\r\n   * @param {string} url - URL to fetch data from.\r\n   *\r\n   * @returns {(Promise<module:api/types.ApiResponse | Error>)} Response from the API.\r\n   */\r\n  async get(url: string): Promise<import('./types').ApiResponse | Error> {\r\n    if (getTypeof(url) !== 'string') {\r\n      return Promise.reject(\r\n        new Error('Fetch.get(url) - url argument must be of type string')\r\n      );\r\n    }\r\n\r\n    /* Use the cross-fetch package to perform an HTTP get request */\r\n    const response: Response = await fetch(url)\r\n      .then(result => {\r\n        if (!result?.status || result.status >= 400) {\r\n          throw new Error(\r\n            `Bad response from server, code: ${result?.status}, text: ${result?.statusText}, headers: ${result?.headers}`\r\n          );\r\n        } else return result;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`Fetch.get() http error: ${err}`))\r\n      );\r\n\r\n    /* Convert the NHTSA API data to JSON */\r\n    const json: import('./types').NhtsaResponse = await response.json();\r\n\r\n    /* Add the fetch response information to the returned NHSTA API data */\r\n    const finalResult: import('./types').ApiResponse = {\r\n      ...json,\r\n      Response: {\r\n        headers: response.headers,\r\n        ok: response.ok,\r\n        redirected: response.redirected,\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        url: response.url\r\n      }\r\n    };\r\n\r\n    /* Return the completed ApiResponse */\r\n    return Promise.resolve(finalResult);\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class DecodeVin\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class DecodeVin extends Fetch {\r\n  /**\r\n   * The DecodeVin API Action will decode the VIN and the decoded output will be made available in the format of Key-value pairs.\r\n   * - The IDs (VariableID and ValueID) represent the unique ID associated with the Variable/Value.\r\n   *   - In case of text variables, the ValueID is not applicable.\r\n   * - Providing `params.modelYear` allows for the decoding to specifically be done in the current,\r\n   *   or older (pre-1980), model year ranges.\r\n   *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding.\r\n   * - This API also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   *   - In this case, the VIN will be decoded partially with the available characters.\r\n   *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   *   - The 9th digit is not necessary.\r\n   *\r\n   * @async\r\n   * @memberof DecodeVin\r\n   *\r\n   * @param {string} vin Vehicle Identification Number (full or partial)\r\n   * @param {object} params={} Query Search Parameters to append to the URL\r\n   * @param {string|number} [params.modelYear] - Optional Model Year search parameter\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async DecodeVin(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'DecodeVin';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class DecodeVinExtended\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class DecodeVinExtended extends Fetch {\r\n  /**\r\n   * This is exactly like the DecodeVin method but provides additional information on variables\r\n   *   related to other NHTSA programs like NCSA etc.\r\n   * - This will decode the VIN and the decoded output will be made available\r\n   *   in the format of Key-value pairs.\r\n   * - In the returned 'Results` object:\r\n   *   - The IDs (VariableID and ValueID) represent the unique ID associated with the Variable/Value.\r\n   *   - In case of text variables, the ValueID is not applicable.\r\n   * - Providing `params.modelYear` allows for the decoding to specifically be done in the current,\r\n   *   or older (pre-1980), model year ranges.\r\n   *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding.\r\n   * - This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   *   - In this case, the VIN will be decoded partially with the available characters.\r\n   *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   *   - The 9th digit is not necessary.\r\n   *\r\n   * @async\r\n   * @memberof DecodeVinExtended\r\n   *\r\n   * @param {string} vin Vehicle Identification Number (full or partial)\r\n   * @param {object} params={} Query Search Parameters to append to the URL\r\n   * @param {string|number} [params.modelYear] - Optional Model Year search parameter\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async DecodeVinExtended(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'DecodeVinExtended';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class DecodeVinValues\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class DecodeVinValues extends Fetch {\r\n  /**\r\n   * The DecodeVinValues API Action will decode the VIN and the decoded output will be made available in a flat file format.\r\n   * - Providing params.modelYear allows for the decoding to specifically be done in the current,\r\n   *   or older (pre-1980), model year ranges.\r\n   *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding.\r\n   * - This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   *   - In this case, the VIN will be decoded partially with the available characters.\r\n   *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   *\r\n   * @async\r\n   * @memberof DecodeVinValues\r\n   *\r\n   * @param {string} vin Vehicle Identification Number (full or partial)\r\n   * @param {object} params={} Query Search Parameters to append to the URL\r\n   * @param {string|number} [params.modelYear] - Optional Model Year search parameter\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async DecodeVinValues(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'DecodeVinValues';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class DecodeVinValuesExtended\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class DecodeVinValuesExtended extends Fetch {\r\n  /**\r\n   * This is exactly like the DecodeVinValues (flat format) method but provides additional information\r\n   * on variables related to other NHTSA programs like NCSA etc.\r\n   * - This will decode the VIN and the decoded output will be made available in a flat file format.\r\n   * - Providing `params.modelYear` allows for the decoding to specifically be done in the current,\r\n   *   or older (pre-1980), model year ranges.\r\n   *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding.\r\n   * - This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   *   - In this case, the VIN will be decoded partially with the available characters.\r\n   *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   *\r\n   * @async\r\n   * @memberof DecodeVinValuesExtended\r\n   *\r\n   * @param {string} vin Vehicle Identification Number (full or partial)\r\n   * @param {object} params={} Query Search Parameters to append to the URL\r\n   * @param {string|number} [params.modelYear] - Optional Model Year search parameter\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async DecodeVinValuesExtended(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'DecodeVinValuesExtended';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class DecodeWMI\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class DecodeWMI extends Fetch {\r\n  /**\r\n   * This provides information on the World Manufacturer Identifier for a specific WMI code.\r\n   * - `WMI` may be put in as either 3 characters representing VIN position 1-3 or 6 characters\r\n   *   representing VIN positions 1-3 & 12-14. Example \"JTD\", \"1T9131\".\r\n   *\r\n   * @async\r\n   * @memberof DecodeWMI\r\n   *\r\n   * @param {string} WMI World Manufacturer Identifier\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async DecodeWMI(\r\n    WMI: string\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'DecodeWMI';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(WMI) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, WMI argument is required and must be a string, got: ${WMI}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${WMI}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetAllMakes\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetAllMakes extends Fetch {\r\n  /**\r\n   * This provides a list of all the Makes available in the vPIC Dataset.\r\n   *\r\n   * @async\r\n   * @memberof GetAllMakes\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  public async GetAllMakes(): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetAllMakes';\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetAllManufacturers\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetAllManufacturers extends Fetch {\r\n  /**\r\n   * This provides a list of all the Manufacturers available in vPIC Dataset.\r\n   * - `params.manufacturerType` allows the user to filter the list based on manufacturer type,\r\n   *   ('Incomplete Vehicles', 'Completed Vehicle Manufacturer', 'Incomplete Vehicle Manufacturer',\r\n   *   'Intermediate Manufacturer', 'Final-Stage Manufacturer', 'Alterer', or any partial match of those strings).\r\n   * - You can get a list of all manufacturer types with the following API Action:\r\n   *   `GetVehicleVariableValuesList('manufacturer type')`\r\n   * - Results are provided in pages of 100 items.\r\n   * - Provide a number value for params.page to specify 1st (default), 2nd, 3rd, Nth, etc page.\r\n   *\r\n   * @async\r\n   * @memberof GetAllManufacturers\r\n   *\r\n   * @param {object} params={} Query Search Parameters to append to the URL\r\n   * @param {string} [params.manufacturerType] see method description\r\n   * @param {string|number} [params.page] Specify the page number (results returned 100 at a time)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetAllManufacturers(\r\n    params: {\r\n      manufacturerType?: string;\r\n      page?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetAllManufacturers';\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetCanadianVehicleSpecifications\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetCanadianVehicleSpecifications extends Fetch {\r\n  /**\r\n   * This returns the Models in the vPIC dataset for a specified Model Year and Make whose name is LIKE the Make in vPIC Dataset.\r\n   * - `params.year` is the only query parameter the user must provide.\r\n   * - `params.makeId` is a number\r\n   * - `params.modelYear` is a number (greater than 1995)\r\n   * - `params.vehicleType` can be a partial name, or a full name for more specificity\r\n   *   (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.)\r\n   * This API action will return a 404 html error if any of the query parameters in params\r\n   *   are missing from the query string. This is the only API action with this behaviour. Therefore,\r\n   *   parameters are inserted into the query string as empty strings, if not provided by the user.\r\n   *\r\n   * @async\r\n   * @memberof GetCanadianVehicleSpecifications\r\n   *\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {number} params.year Model year of the vehicle (required) - Number, >= 1971\r\n   * @param {string} [params.make] Vehicle's make, like \"Honda\", \"Toyota\", etc...\r\n   * @param {string} [params.model] Vehicle's model, like \"Pilot\", \"Focus\". Can also include some other elements like Body Type, Engine Model/size, etc...\r\n   * @param {string} [params.units] \"Metric\" (default), or \"US\" for United States customary units\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetCanadianVehicleSpecifications(\r\n    params: {\r\n      year: number;\r\n      make?: string;\r\n      model?: string;\r\n      units?: string;\r\n    } = {\r\n      year: undefined as any\r\n    }\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetCanadianVehicleSpecifications';\r\n\r\n    /* Runtime gatekeeping */\r\n    if (!params.year) {\r\n      return Promise.reject(\r\n        new Error(`${action}, params.year is required, got: ${params.year}`)\r\n      );\r\n    }\r\n\r\n    /* Set default query parameters to empty strings if not provided by the user */\r\n    if (!params.make) params.make = '';\r\n    if (!params.model) params.model = '';\r\n    if (!params.units) params.units = '';\r\n\r\n    /*\r\n     * Build the 'default' query string to be appended to the URL\r\n     * Additionally, set the allowEmptyStringValues option (2nd argument) to true\r\n     * This API action will return a 404 error if any of the query parameters in params\r\n     * are missing from the query string. This is the only API action with this behaviour.\r\n     * \"year\" is the only param the user must provide.\r\n     */\r\n    const queryString = await this.buildQueryString(\r\n      params,\r\n      true\r\n    ).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetEquipmentPlantCodes\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetEquipmentPlantCodes extends Fetch {\r\n  /**\r\n   * Returns assigned Equipment Plant Codes. Can be filtered by Year, Equipment Type and Report Type.\r\n   * - `params.year`:\r\n   *   - Only years >= 2016 are supported\r\n   * - `params.equipmentType`:\r\n   *   - 1 (Tires)\r\n   *   - 3 (Brake Hoses)\r\n   *   - 13 (Glazing)\r\n   *   - 16 (Retread)\r\n   * - `params.reportType`:\r\n   *   - 'New' (The Equipment Plant Code was assigned during the selected year)\r\n   *   - 'Updated' (The Equipment Plant data was modified during the selected year)\r\n   *   - 'Closed' (The Equipment Plant is no longer Active)\r\n   *   - 'All' (All Equipment Plant Codes regardless of year, including their status (active or closed))\r\n   *\r\n   * @async\r\n   * @memberof GetEquipmentPlantCodes\r\n   *\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {number} params.year Model year of the vehicle - Number, >= 2016\r\n   * @param {string} params.equipmentType number equal to 1, 3, 13, or 16\r\n   * @param {string} params.reportType 'New', 'Updated', 'Closed', or 'All'\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  public async GetEquipmentPlantCodes(\r\n    params: {\r\n      year: number;\r\n      equipmentType: 1 | 3 | 13 | 16;\r\n      reportType: 'New' | 'Updated' | 'Closed' | 'All';\r\n    } = {\r\n      year: undefined as any,\r\n      equipmentType: undefined as any,\r\n      reportType: undefined as any\r\n    }\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetEquipmentPlantCodes';\r\n\r\n    /* Runtime typechecking params*/\r\n    if (!params.year) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, \"year\" parameter is required, got: ${params.year}`\r\n        )\r\n      );\r\n    }\r\n    if (!params.equipmentType) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, \"equipmentType\" parameter is required, got: ${params.equipmentType}`\r\n        )\r\n      );\r\n    }\r\n    if (!params.reportType) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, \"reportType\" parameter is required, got: ${params.reportType}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetMakeForManufacturer\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetMakeForManufacturer extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified manufacturer that is requested.\r\n   * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id.\r\n   * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the provided name\r\n   *   (it accepts a partial manufacturer name as an input).\r\n   * - Mnufacturer name can be a partial name, or a full name for more specificity\r\n   *   (e.g., \"988\", \"HONDA\", \"HONDA OF CANADA MFG., INC.\", etc.)\r\n   * - Multiple results are returned in case of multiple matches.\r\n   *\r\n   * @async\r\n   * @memberof GetMakeForManufacturer\r\n   *\r\n   * @param {string|number} manufacturer Manufacturer Name (string) or Manufacturer ID (number)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetMakeForManufacturer(\r\n    manufacturer: string | number\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetMakeForManufacturer';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string or number, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetMakesForManufacturerAndYear\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetMakesForManufacturerAndYear extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified manufacturer,\r\n   * and whose Year From and Year To range cover the specified year.\r\n   * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id.\r\n   * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the provided name\r\n   *   (it accepts a partial manufacturer name as an input).\r\n   * - Multiple results are returned in case of multiple matches.\r\n   * - Manufacturer can be idenfitied by Id, a partial name, or a full name\r\n   *   (e.g., \"988\", \"HONDA\", \"HONDA OF CANADA MFG., INC.\", etc.)\r\n   *\r\n   * @async\r\n   * @memberof GetMakesForManufacturerAndYear\r\n   *\r\n   * @param {string|number} manufacturer Manufacturer Name (string) or Manufacturer ID (number)\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {string|number} params.year Model year of the vehicle - Number, >= 2016\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  public async GetMakesForManufacturerAndYear(\r\n    manufacturer: string | number,\r\n    params: {\r\n      year: string | number;\r\n    } = { year: undefined as any }\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetMakesForManufacturerAndYear';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, please provide a valid manufacturer arg, either a number or string, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n    if (!params.year) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, please provide a valid year parameter, either a number or string, got params.year: ${params.year}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetMakesForVehicleType\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetMakesForVehicleType extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified vehicle type,\r\n   * whose name is LIKE the vehicle type name in vPIC Dataset.\r\n   * - Vehicle `typeName` can be a partial name, or a full name for more specificity\r\n   *   (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.).\r\n   *\r\n   * @async\r\n   * @memberof GetMakesForVehicleType\r\n   *\r\n   * @param {string} typeName A partial or full vehicle type name\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetMakesForVehicleType(\r\n    typeName: string\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetMakesForVehicleType';\r\n\r\n    if (getTypeof(typeName) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, typeName is required and must be a string, got: ${typeName}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${typeName}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetManufacturerDetails\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetManufacturerDetails extends Fetch {\r\n  /**\r\n   * This provides the details for a specific manufacturer that is requested.\r\n   * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id.\r\n   * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the provided name,\r\n   *   (it accepts a partial manufacturer name as an input).\r\n   * - Multiple results are returned in case of multiple matches.\r\n   *\r\n   * @async\r\n   * @memberof GetManufacturerDetails\r\n   *\r\n   * @param {string|number} manufacturer Manufacturer Name (string) or Manufacturer ID (number)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  public async GetManufacturerDetails(\r\n    manufacturer: string | number\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetManufacturerDetails';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string or number, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetModelsForMake\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetModelsForMake extends Fetch {\r\n  /**\r\n   * This returns the Models in the vPIC dataset for a specified Make whose name is LIKE the Make in vPIC Dataset.\r\n   * - `makeName` can be a partial, or a full for more specificity (e.g., \"Harley\", \"Harley Davidson\", etc.)\r\n   *\r\n   * @async\r\n   * @memberof GetModelsForMake\r\n   *\r\n   * @param {string} makeName Vehicle make name (string)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetModelsForMake(\r\n    makeName: string\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetModelsForMake';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeName) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeName is required and must be a string, got: ${makeName}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${makeName}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetModelsForMakeId\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetModelsForMakeId extends Fetch {\r\n  /**\r\n   * This returns the Models in the vPIC dataset for a specified Make whose Id is EQUAL the MakeId in vPIC Dataset.\r\n   *\r\n   * @async\r\n   * @memberof GetModelsForMakeId\r\n   *\r\n   * @param {number} makeID Vehicle make ID (number)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetModelsForMakeId(\r\n    makeID: number\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetModelsForMakeId';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeID) !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeID is required and must be a number, got: ${makeID}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${makeID}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetModelsForMakeIdYear\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetModelsForMakeIdYear extends Fetch {\r\n  /**\r\n   * This returns the Models in the vPIC dataset for a specified Model Year and Make whose name is LIKE the Make in vPIC Dataset.\r\n   *   - `params.makeId` is a number and is a required query parameter\r\n   *\r\n   * A minimum of one of the following are required (or a combination of both):\r\n   *   - `params.modelYear` is a number (greater than 1995)\r\n   *   - `params.vehicleType` can be a partial name, or a full name for more specificity\r\n   *     (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.)\r\n   *\r\n   * @async\r\n   * @memberof GetModelsForMakeIdYear\r\n   *\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {number} params.makeId Make ID to search\r\n   * @param {number} [params.modelYear] A number representing the model year to search (greater than 1995)\r\n   * @param {string} [params.vehicleType] String representing the vehicle type to search\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetModelsForMakeIdYear(\r\n    params: {\r\n      makeId: number;\r\n      modelYear?: number;\r\n      vehicleType?: string;\r\n    } = {\r\n      makeId: undefined as any\r\n    }\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetModelsForMakeIdYear';\r\n\r\n    /* Required makeId param of type number */\r\n    const typeofMakeId = getTypeof(params.makeId);\r\n    if (!params.makeId || typeofMakeId !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.makeId is required and must be a string, got: ${params.makeId} of type ${typeofMakeId}`\r\n        )\r\n      );\r\n    }\r\n    /* At least one of modelYear or vehicleType params is required */\r\n    if (!params.modelYear && !params.vehicleType) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, one of or both of, params.modelYear or params.vehicleType is required, got params: ${params}`\r\n        )\r\n      );\r\n    }\r\n    /* valid modelYear param of type number */\r\n    const typeofModelYear = getTypeof(params.modelYear);\r\n    if (params.modelYear && typeofModelYear !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.modelYear must be of type number, got type of: ${typeofModelYear}`\r\n        )\r\n      );\r\n    }\r\n    /* valid vehicleType param of type string */\r\n    const typeofVehicleType = getTypeof(params.vehicleType);\r\n    if (params.vehicleType && getTypeof(params.vehicleType) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.vehicleType must be of type string, got type of: ${typeofVehicleType}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the actionUrl */\r\n    let actionUrl = `${action}/makeId/${params.makeId}/`;\r\n\r\n    /* Append params.modelYear and params.vehicleType to the URL, at least one is required by the API */\r\n    if (params.modelYear && params.vehicleType) {\r\n      actionUrl += `modelYear/${params.modelYear}/vehicleType/${params.vehicleType}`;\r\n    } else if (params.modelYear) {\r\n      actionUrl += `modelYear/${params.modelYear}`;\r\n    } else {\r\n      actionUrl += `vehicleType/${params.vehicleType}`;\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${actionUrl}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetModelsForMakeYear\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetModelsForMakeYear extends Fetch {\r\n  /**\r\n   * This returns the Models in the vPIC dataset for a specified Model Year and Make whose name is LIKE the Make in vPIC Dataset.\r\n   *   - `params.make` can be a partial, or a full for more specificity\r\n   *     (e.g., \"Harley\", \"Harley Davidson\", etc.)\r\n   *\r\n   * A minimum of one of the following are required (or a combination of both):\r\n   *   - `params.modelYear` is a number (greater than 1995)\r\n   *   - `params.vehicleType` can be a partial name, or a full name for more specificity\r\n   *     (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.)\r\n   *\r\n   * @async\r\n   * @memberof GetModelsForMakeYear\r\n   *\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {string} params.make Make name to search\r\n   * @param {number} [params.modelYear] A number representing the model year to search (greater than 1995)\r\n   * @param {string} [params.vehicleType] String representing the vehicle type to search\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetModelsForMakeYear(\r\n    params: {\r\n      make: string;\r\n      modelYear?: number;\r\n      vehicleType?: string;\r\n    } = {\r\n      make: undefined as any\r\n    }\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetModelsForMakeYear';\r\n\r\n    /* Required make param of type string */\r\n    const typeofMake = getTypeof(params.make);\r\n    if (!params.make || typeofMake !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.make is required and must be a string, got: ${params.make} of type ${typeofMake}`\r\n        )\r\n      );\r\n    }\r\n    /* At least one of modelYear or vehicleType params is required */\r\n    if (!params.modelYear && !params.vehicleType) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, one of or both of, params.modelYear or params.vehicleType is required, got params: ${params}`\r\n        )\r\n      );\r\n    }\r\n    /* valid modelYear param of type number */\r\n    const typeofModelYear = getTypeof(params.modelYear);\r\n    if (params.modelYear && typeofModelYear !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.modelYear must be of type number, got type of: ${typeofModelYear}`\r\n        )\r\n      );\r\n    }\r\n    /* valid vehicleType param of type string */\r\n    const typeofVehicleType = getTypeof(params.vehicleType);\r\n    if (params.vehicleType && getTypeof(params.vehicleType) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, params.vehicleType must be of type string, got type of: ${typeofVehicleType}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the actionUrl */\r\n    let actionUrl = `${action}/make/${params.make}/`;\r\n\r\n    /* Append params.modelYear and params.vehicleType to the URL, at least one is required by the API */\r\n    if (params.modelYear && params.vehicleType) {\r\n      actionUrl += `modelYear/${params.modelYear}/vehicleType/${params.vehicleType}`;\r\n    } else if (params.modelYear) {\r\n      actionUrl += `modelYear/${params.modelYear}`;\r\n    } else {\r\n      actionUrl += `vehicleType/${params.vehicleType}`;\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${actionUrl}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetParts\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetParts extends Fetch {\r\n  /**\r\n   * This provides a list of ORGs with letter date in the given range of the dates and with specified `params.type` of ORG.\r\n   * - Up to 1000 results will be returned at a time.\r\n   * - Get the next page by incrementing the `params.page` query parameter.\r\n   * - All query `params` are optional.\r\n   *\r\n   * @async\r\n   * @memberof GetParts\r\n   *\r\n   * @param {object} params Query Search Parameters to append to the URL\r\n   * @param {string|number} [params.type] Specified type of ORG to search\r\n   * @param {string} [params.fromDate] Start date of search query\r\n   * @param {string} [params.toDate] End date of search query\r\n   * @param {string|number} [params.page] Page number of results to request (100 results per page)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetParts(\r\n    params: {\r\n      type?: string | number;\r\n      fromDate?: string;\r\n      toDate?: string;\r\n      page?: string | number;\r\n    } = {}\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetParts';\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetVehicleTypesForMake\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetVehicleTypesForMake extends Fetch {\r\n  /**\r\n   * This returns all the Vehicle Types in the vPIC dataset for a specified Make, whose name is LIKE the make name in vPIC Dataset.\r\n   * - `makeName` can be a partial name, or a full name for more specificity\r\n   *   (e.g., \"Merc\", \"Mercedes Benz\", etc.).\r\n   *\r\n   * @async\r\n   * @memberof GetVehicleTypesForMake\r\n   *\r\n   * @param {string} makeName Name of the vehicle make to search\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetVehicleTypesForMake(\r\n    makeName: string\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetVehicleTypesForMake';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeName) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeName is required and must be a string, got: ${makeName}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${makeName}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetVehicleTypesForMakeId\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetVehicleTypesForMakeId extends Fetch {\r\n  /**\r\n   * This returns all the Vehicle Types in the vPIC dataset for a specified Make whose ID equals the make ID in vPIC Dataset.\r\n   *\r\n   * @async\r\n   * @memberof GetVehicleTypesForMakeId\r\n   *\r\n   * @param {number} makeID Vehicle make ID\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetVehicleTypesForMakeId(\r\n    makeID: number\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetVehicleTypesForMakeId';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeID) !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeID is required and must be a number, got: ${makeID}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${makeID}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetVehicleVariableList\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetVehicleVariableList extends Fetch {\r\n  /**\r\n   * This provides a list of all the Vehicle related variables that are in vPIC dataset.\r\n   * - Information on the name, description and the type of the variable is provided.\r\n   *\r\n   * @async\r\n   * @memberof GetVehicleVariableList\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  public async GetVehicleVariableList(): Promise<\r\n    import('../types').ApiResponse | Error\r\n  > {\r\n    const action = 'GetVehicleVariableList';\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetVehicleVariableValuesList\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetVehicleVariableValuesList extends Fetch {\r\n  /**\r\n   * This provides a list of all the accepted values for a given variable that are stored in vPIC dataset.\r\n   *\r\n   * This applies to only \"Look up\" type of variables.\r\n   * - `variableValue` can either be a:\r\n   *   - Variable Name (\"battery type\" in first example, please use full name, not just part of it),\r\n   *   - or Variable ID (\"2\" in second example).\r\n   *\r\n   * @async\r\n   * @memberof GetVehicleVariableValuesList\r\n   *\r\n   * @param {string|number} variableValue The variable you want to get a values list of\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetVehicleVariableValuesList(\r\n    variableValue: string | number\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetVehicleVariableValuesList';\r\n\r\n    /* Runtime typechecking */\r\n    if (!variableValue) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, variableValue is required and must be a string or number, got: ${variableValue}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${variableValue}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/**\r\n * @category Actions\r\n * @class GetWMIsForManufacturer\r\n * @extends {module:api/Fetch.Fetch}\r\n */\r\nexport class GetWMIsForManufacturer extends Fetch {\r\n  /**\r\n   * Provides information on the all World Manufacturer Identifier (WMI) for a specified `manufacturer`.\r\n   * - Only WMIs registered in vPICList are displayed.\r\n   *\r\n   * @async\r\n   * @memberof GetWMIsForManufacturer\r\n   *\r\n   * @param {string|number} manufacturer Manufacturer Name (string) or Manufacturer ID (number)\r\n   *\r\n   * @returns {(Promise<module:api.ApiResponse | Error>)}\r\n   */\r\n  async GetWMIsForManufacturer(\r\n    manufacturer: string\r\n  ): Promise<import('../types').ApiResponse | Error> {\r\n    const action = 'GetWMIsForManufacturer';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(manufacturer) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n\r\n    /* Build the final request URL*/\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    /* Return the result */\r\n    return await this.get(url)\r\n      .then(response => response)\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from './Fetch';\r\n\r\n/* API Actions */\r\nimport {\r\n  DecodeVin,\r\n  DecodeVinValues,\r\n  DecodeVinExtended,\r\n  DecodeVinValuesExtended,\r\n  DecodeWMI,\r\n  GetWMIsForManufacturer,\r\n  GetAllMakes,\r\n  GetParts,\r\n  GetAllManufacturers,\r\n  GetManufacturerDetails,\r\n  GetMakeForManufacturer,\r\n  GetMakesForManufacturerAndYear,\r\n  GetMakesForVehicleType,\r\n  GetVehicleTypesForMake,\r\n  GetVehicleTypesForMakeId,\r\n  GetEquipmentPlantCodes,\r\n  GetModelsForMake,\r\n  GetModelsForMakeId,\r\n  GetModelsForMakeYear,\r\n  GetModelsForMakeIdYear,\r\n  GetVehicleVariableList,\r\n  GetVehicleVariableValuesList,\r\n  GetCanadianVehicleSpecifications\r\n} from './actions';\r\n\r\n/**\r\n * @class NHTSA\r\n *\r\n * @augments {Fetch}\r\n *\r\n * @implements {DecodeVin}\r\n * @implements {DecodeVinExtended}\r\n * @implements {DecodeVinValues}\r\n * @implements {DecodeVinValuesExtended}\r\n * @implements {DecodeWMI}\r\n * @implements {GetAllMakes}\r\n * @implements {GetAllManufacturers}\r\n * @implements {GetCanadianVehicleSpecifications}\r\n * @implements {GetEquipmentPlantCodes}\r\n * @implements {GetMakeForManufacturer}\r\n * @implements {GetMakesForManufacturerAndYear}\r\n * @implements {GetMakesForVehicleType}\r\n * @implements {GetManufacturerDetails}\r\n * @implements {GetModelsForMake}\r\n * @implements {GetModelsForMakeId}\r\n * @implements {GetModelsForMakeIdYear}\r\n * @implements {GetModelsForMakeYear}\r\n * @implements {GetParts}\r\n * @implements {GetVehicleTypesForMake}\r\n * @implements {GetVehicleTypesForMakeId}\r\n * @implements {GetVehicleVariableList}\r\n * @implements {GetVehicleVariableValuesList}\r\n * @implements {GetWMIsForManufacturer}\r\n */\r\nclass NHTSA extends Fetch\r\n  implements\r\n    DecodeVin,\r\n    DecodeVinExtended,\r\n    DecodeVinValues,\r\n    DecodeVinValuesExtended,\r\n    DecodeWMI,\r\n    GetAllMakes,\r\n    GetAllManufacturers,\r\n    GetCanadianVehicleSpecifications,\r\n    GetEquipmentPlantCodes,\r\n    GetMakeForManufacturer,\r\n    GetMakesForManufacturerAndYear,\r\n    GetMakesForVehicleType,\r\n    GetManufacturerDetails,\r\n    GetModelsForMake,\r\n    GetModelsForMakeId,\r\n    GetModelsForMakeIdYear,\r\n    GetModelsForMakeYear,\r\n    GetParts,\r\n    GetVehicleTypesForMake,\r\n    GetVehicleTypesForMakeId,\r\n    GetVehicleVariableList,\r\n    GetVehicleVariableValuesList,\r\n    GetWMIsForManufacturer {\r\n  constructor(userConfig?: import('./types').FetchConfig) {\r\n    super(userConfig);\r\n  }\r\n\r\n  DecodeVin = DecodeVin.prototype.DecodeVin;\r\n\r\n  DecodeVinValues = DecodeVinValues.prototype.DecodeVinValues;\r\n\r\n  DecodeVinExtended = DecodeVinExtended.prototype.DecodeVinExtended;\r\n\r\n  DecodeVinValuesExtended =\r\n    DecodeVinValuesExtended.prototype.DecodeVinValuesExtended;\r\n\r\n  DecodeWMI = DecodeWMI.prototype.DecodeWMI;\r\n\r\n  GetAllMakes = GetAllMakes.prototype.GetAllMakes;\r\n\r\n  GetAllManufacturers = GetAllManufacturers.prototype.GetAllManufacturers;\r\n\r\n  GetCanadianVehicleSpecifications =\r\n    GetCanadianVehicleSpecifications.prototype.GetCanadianVehicleSpecifications;\r\n\r\n  GetEquipmentPlantCodes =\r\n    GetEquipmentPlantCodes.prototype.GetEquipmentPlantCodes;\r\n\r\n  GetMakeForManufacturer =\r\n    GetMakeForManufacturer.prototype.GetMakeForManufacturer;\r\n\r\n  GetMakesForManufacturerAndYear =\r\n    GetMakesForManufacturerAndYear.prototype.GetMakesForManufacturerAndYear;\r\n\r\n  GetMakesForVehicleType =\r\n    GetMakesForVehicleType.prototype.GetMakesForVehicleType;\r\n\r\n  GetManufacturerDetails =\r\n    GetManufacturerDetails.prototype.GetManufacturerDetails;\r\n\r\n  GetModelsForMake = GetModelsForMake.prototype.GetModelsForMake;\r\n\r\n  GetModelsForMakeId = GetModelsForMakeId.prototype.GetModelsForMakeId;\r\n\r\n  GetModelsForMakeIdYear =\r\n    GetModelsForMakeIdYear.prototype.GetModelsForMakeIdYear;\r\n\r\n  GetModelsForMakeYear = GetModelsForMakeYear.prototype.GetModelsForMakeYear;\r\n\r\n  GetParts = GetParts.prototype.GetParts;\r\n\r\n  GetVehicleTypesForMake =\r\n    GetVehicleTypesForMake.prototype.GetVehicleTypesForMake;\r\n\r\n  GetVehicleTypesForMakeId =\r\n    GetVehicleTypesForMakeId.prototype.GetVehicleTypesForMakeId;\r\n\r\n  GetVehicleVariableList =\r\n    GetVehicleVariableList.prototype.GetVehicleVariableList;\r\n\r\n  GetVehicleVariableValuesList =\r\n    GetVehicleVariableValuesList.prototype.GetVehicleVariableValuesList;\r\n\r\n  GetWMIsForManufacturer =\r\n    GetWMIsForManufacturer.prototype.GetWMIsForManufacturer;\r\n}\r\n\r\nexport { NHTSA };\r\n\r\nexport const Client = new NHTSA();\r\n"],"names":["__self__","root","F","fetch","DOMException","prototype","self","this","exports","support","Symbol","Blob","e","viewClasses","isArrayBufferView","ArrayBuffer","isView","obj","indexOf","Object","toString","call","normalizeName","name","String","test","TypeError","toLowerCase","normalizeValue","value","iteratorFor","items","iterator","next","shift","done","undefined","Headers","headers","map","forEach","append","Array","isArray","header","getOwnPropertyNames","consumed","body","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","result","onerror","error","readBlobAsArrayBuffer","blob","FileReader","promise","readAsArrayBuffer","bufferClone","buf","slice","view","Uint8Array","byteLength","set","buffer","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","DataView","_bodyArrayBuffer","get","type","rejected","Error","arrayBuffer","then","text","readAsText","chars","length","i","fromCharCode","join","readArrayBufferAsText","formData","decode","json","JSON","parse","oldValue","has","hasOwnProperty","callback","thisArg","keys","push","values","entries","methods","Request","input","options","method","upcased","url","credentials","mode","signal","toUpperCase","referrer","form","trim","split","bytes","replace","decodeURIComponent","Response","bodyInit","status","ok","statusText","clone","response","redirectStatuses","redirect","RangeError","location","err","message","stack","create","constructor","init","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","rawHeaders","getAllResponseHeaders","line","parts","key","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","module","DEFAULT_CONFIG","apiResponseFormat","baseUrl","userConfig","finalConfig","getTypeof","config","Fetch","params","allowEmptyStringValues","format","makeQueryString","_a","catch","finalResult","redirected","__extends","DecodeVin","vin","action","buildQueryString","queryString","DecodeVinExtended","DecodeVinValues","DecodeVinValuesExtended","DecodeWMI","WMI","GetAllMakes","GetAllManufacturers","GetCanadianVehicleSpecifications","year","make","model","units","GetEquipmentPlantCodes","equipmentType","reportType","GetMakeForManufacturer","manufacturer","GetMakesForManufacturerAndYear","GetMakesForVehicleType","typeName","GetManufacturerDetails","GetModelsForMake","makeName","GetModelsForMakeId","makeID","GetModelsForMakeIdYear","makeId","typeofMakeId","modelYear","vehicleType","typeofModelYear","typeofVehicleType","actionUrl","GetModelsForMakeYear","typeofMake","GetParts","GetVehicleTypesForMake","GetVehicleTypesForMakeId","GetVehicleVariableList","GetVehicleVariableValuesList","variableValue","GetWMIsForManufacturer","_super","_this","Client","NHTSA"],"mappings":"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"}