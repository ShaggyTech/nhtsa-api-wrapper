(function(a,m){typeof exports=="object"&&typeof module<"u"?m(exports):typeof define=="function"&&define.amd?define(["exports"],m):(a=typeof globalThis<"u"?globalThis:a||self,m(a.NHTSA={}))})(this,function(a){"use strict";const m=({args:e,mode:t="default"})=>{if(t==="default")e.forEach(n=>{S(n)});else if(t==="atLeast"&&!e.find(o=>o.value!==void 0))throw Error(`must provide at least one of the following arguments: ${e.map(o=>o.name).join(", ")}`)},S=({name:e,value:t,required:n,types:o})=>{if(!e)throw Error("error validating argument, 'name' arg is required");if(!n&&!o)throw Error(`error validating argument ${e}, either 'required' or 'types' args are required`);if(u(o)!=="array")throw Error(`error validating argument ${e}, 'types' must be an array of strings`);const c=u(t),r=o?`<${o.join(" | ")}>`:"",s=`error validating argument, "${e}"`,g=`received value: ${t} - of type: <${c}>`;if(n&&!o&&!t)throw Error(`${s} is required; ${g}`);if(o&&!n&&t&&!o.includes(c))throw Error(`${s} must be of type(s) ${r}, ${g}`);if(n&&o&&(!t||!o.includes(c)))throw Error(`${s} is required and must be of type(s) ${r}, ${g}`)},f="https://vpic.nhtsa.dot.gov/api/vehicles",T="json",u=e=>{const t=Object.prototype.toString.call(e).toLowerCase();return t.slice(8,t.length-1)},V=(e,t=!1)=>{const n={format:T},o=u(e)==="object"?{...e,...n}:n,c="?"+Object.entries(o).map(([r,s],g,$)=>{const d=u(s);return d!=="string"&&d!=="number"?"":(d==="number"&&(s=s.toString()),s.length||t&&s===""?`${r}=${s}${g<$.length-1?"&":""}`:"")}).join("");return G(c)},G=e=>{if(e=encodeURI(e),/[^0-9A-Z?&=%]/gi.test(e))throw Error("Invalid characters found in query string. Only characters a-z, 0-9, and ?,&,=,% are allowed.");return e},k=e=>u(e)==="error",Y=e=>{let t,n;k(e)?(t=e.message,n=e.stack):u(e)==="string"?t=e:t="an unknown error occurred.";const o=new Error(t);return o.stack=n||"unknown stack",o},i=async e=>((!k(e)||!e.message||!e.stack)&&(e=Y(e)),Promise.reject(e)),j={A:1,B:2,C:3,D:4,E:5,F:6,G:7,H:8,J:1,K:2,L:3,M:4,N:5,P:7,R:9,S:2,T:3,U:4,V:5,W:6,X:7,Y:8,Z:9},p=[8,7,6,5,4,3,2,10,0,9,8,7,6,5,4,3,2];function E(e){if(typeof e!="string"||e.length!=17)return!1;e=e.toUpperCase();const t=e.split(""),n=t[8];if(isNaN(parseInt(n))&&n!=="X")return!1;const o=n==="X"?10:parseInt(n);return t.map((r,s)=>{let g;isNaN(parseInt(r))?g=j[r]:g=parseInt(r);const $=p[s];return g*$}).reduce((r,s)=>r+s,0)%11===o}function l(e,t=!1){const n={format:T};let o={};!e||u(e)!=="object"?o={...n}:o={...e,...n};const c=Object.entries(o),r=c.length;if(r<1)return Promise.resolve("");let s=!1;const g=c.map(([$,d],h)=>{let M="",b="";const q=u(d);if(d&&q==="number"&&(d=d.toString()),(d||t)&&(q==="string"||q==="number"))return s||(M="?",s=!0),h<r-1&&(b="&"),`${M}${$}=${d}${b}`});return Promise.resolve(encodeURI(g.join("")))}const y=()=>({get:async(t,n={})=>await fetch(t,n).then(async c=>{if(!c.ok)throw Error(c.statusText);const r=["application/json","text/json"],s=c.headers.get("content-type");if(!r.some(d=>s==null?void 0:s.includes(d)))throw Error(`response is not in JSON format; got content-type: ${s}`);const $=await c.json();if(!$)throw Error(`response is empty; got content-type: ${s}, responseStatusText: ${c.statusText}}`);return $}).catch(c=>(c.message=`error fetching data; ${c.message}`,i(c)))}),I=async(e,t)=>{const n="DecodeVin",o=t==null?void 0:t.modelYear;try{m({args:[{name:"vin",required:!0,types:["string"],value:e},{name:"params",types:["object"],value:t},{name:"params.modelYear",types:["number","string"],value:o}]});const r=V(t),s=`${f}/${n}/${e}${r}`;return await y().get(s).then(g=>g)}catch(c){return i(c)}},F=async(e,t)=>{const n="DecodeVinExtended",o=u(e);if(!e||o!=="string")return i(`${n}, "vin" argument is required and must be of type string, got: <${o}> ${e}`);const c=u(t);if(t&&c!=="object")return i(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=u(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return i(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const s=await l(t).catch($=>i(`${n}, error building query string: ${$}`)),g=`${f}/${n}/${e}${s}`;return await y().get(g).then($=>$).catch($=>i(`${n}, error fetching data: ${$}`))},A=async(e,t)=>{const n="DecodeVinValues",o=u(e);if(!e||o!=="string")return i(`${n}, "vin" argument is required and must be of type string, got: <${o}> ${e}`);const c=u(t);if(t&&c!=="object")return i(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=u(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return i(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const s=await l(t).catch($=>i(`${n}, error building query string: ${$}`)),g=`${f}/${n}/${e}${s}`;return await y().get(g).then($=>$).catch($=>i(`${n}, error fetching data: ${$}`))},D=async e=>{const t="DecodeVinValuesBatch",n=u(e);if(!e||n!=="string")return i(`${t}, "inputString" argument is required and must be of type string, got: <${n}> ${e}`);const o=`${f}/${t}/`,c=encodeURI(`DATA=${e}&format=${T}`);return await y().get(o,{method:"POST",headers:{"content-type":"application/x-www-form-urlencoded"},body:c}).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},P=async(e,t)=>{const n="DecodeVinValuesExtended",o=u(e);if(!e||o!=="string")return i(`${n}, "vin" argument is required and must be of type string, got: <${o}> ${e}`);const c=u(t);if(t&&c!=="object")return i(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=u(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return i(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const s=await l(t).catch($=>i(`${n}, error building query string: ${$}`)),g=`${f}/${n}/${e}${s}`;return await y().get(g).then($=>$).catch($=>i(`${n}, error fetching data: ${$}`))},v=async e=>{const t="DecodeWMI",n=u(e);if(n!=="string")return i(`${t}, "WMI" argument is required and must be of type string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},R=async()=>{const e="GetAllMakes",t=await l().catch(o=>i(`${e}, error building query string: ${o}`)),n=`${f}/${e}${t}`;return await y().get(n).then(o=>o).catch(o=>i(`${e}, error fetching data: ${o}`))},L=async e=>{const t="GetAllManufacturers",n=u(e);if(e&&n!=="object")return i(`${t}, "params" argument must be of type object, got: <${n}> ${e}`);const o=u(e==null?void 0:e.manufacturerType);if(e!=null&&e.manufacturerType&&o!=="string")return i(`${t}, params.manufacturerType" argument must be of type string, got: <${o}> ${e.manufacturerType}`);const c=u(e==null?void 0:e.page);if(e!=null&&e.page&&c!=="number | string")return i(`${t}, "params.page" argument must be of type number or string, got: <${c}> ${e.page}`);const r=await l(e).catch(g=>i(`${t}, error building query string: ${g}`)),s=`${f}/${t}${r}`;return await y().get(s).then(g=>g).catch(g=>i(`${t}, error fetching data: ${g}`))},C=async e=>{const t="GetCanadianVehicleSpecifications",n=u(e);if(!e||e&&n!=="object")return i(`${t}, "params" argument is required and must be of type object, got: <${n}> ${e}`);const o=u(e==null?void 0:e.year);if(!(e!=null&&e.year)||o!=="number")return i(`${t}, "params.year" argument is required and must be of type number or string, got: <${o}> ${e.year}`);const c=u(e.make);if(e!=null&&e.make&&c!=="string")return i(`${t}, "params.make" argument must be of type string, got: <${c}> ${e.make}`);const r=u(e.model);if(e.model&&r!=="string")return i(`${t}, "params.model" argument must be of type string, got: <${r}> ${e.model}`);const s=u(e.units);if(e.units&&s!=="string")return i(`${t}, "params.units" argument must be of type string, got: <${s}> ${e.units}`);const g=e.make||"",$=e.model||"",d=e.units||"",h={year:e.year,make:g,model:$,units:d},M=await l(h,!0).catch(w=>i(`${t}, error building query string: ${w}`)),b=`${f}/${t}/${M}`;return await y().get(b).then(w=>w).catch(w=>i(`${t}, error fetching data: ${w}`))},N=async e=>{const t="GetEquipmentPlantCodes",n=u(e);if(!e||n!=="object")return i(`${t}, "params" argument must be of type object, got: <${n}> ${e}`);const o=u(e.year);if(o!=="number")return i(`${t}, "params.year" argument is required and must be of type number or string, got: <${o}> ${e.year}`);const c=u(e.equipmentType);if(c!=="number")return i(`${t}, "params.equipmentType" argument is required and must be of type number or string, got: <${c}> ${e.equipmentType}`);const r=u(e.reportType);if(r!=="string")return i(`${t}, "params.reportType" argument is required and must be of type string, got: <${r}> ${e.reportType}`);const s=await l(e).catch($=>i(`${t}, error building query string: ${$}`)),g=`${f}/${t}${s}`;return await y().get(g).then($=>$).catch($=>i(`${t}, error fetching data: ${$}`))},O=async e=>{const t="GetMakeForManufacturer",n=u(e);if(!e||n!=="number")return i(`${t}, "manufacturer" argument is required and must be of type number or string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},U=async(e,t)=>{const n="GetMakesForManufacturerAndYear",o=u(e);if(!e||o!=="number")return i(`${n}, "manufacturer" argument is required and must be of type number or string, got <${o}> ${e}`);const c=u(t);if(!t||t&&c!=="object")return i(`${n}, "params" argument is required and must be of type object, got: <${c}> ${t}`);const r=u(t.year);if(!t.year||r!=="number")return i(`${n}, "params.year" is required and must be of type number or string, got: <${r}> ${t.year}`);const s=await l(t).catch($=>i(`${n}, error building query string: ${$}`)),g=`${f}/${n}/${e}${s}`;return await y().get(g).then($=>$).catch($=>i(`${n}, error fetching data: ${$}`))},W=async e=>{const t="GetMakesForVehicleType",n=u(e);if(n!=="string")return i(`${t}, "typeName" argument is required and must be of type string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},_=async e=>{const t="GetManufacturerDetails",n=u(e);if(!e||n!=="number")return i(`${t}, "manufacturer" argument is required and must be of type number or string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},B=async e=>{const t="GetModelsForMake",n=u(e);if(n!=="string")return i(`${t}, "makeName" argument is required and must be of type string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},H=async e=>{const t="GetModelsForMakeId",n=u(e);if(!e||n!=="number")return i(`${t}, "makeId" argument is required and must be of type number or string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},J=async e=>{const t="GetModelsForMakeIdYear",n=e==null?void 0:e.makeId,o=e==null?void 0:e.modelYear,c=e==null?void 0:e.vehicleType,r=u(e);if(!e||e&&r!=="object")return i(`${t}, "params" argument is required and must be of type object, got: <${r}> ${e}`);const s=u(n);if(!n||s!=="number")return i(`${t}, "params.makeId" is required and must be of type number or string, got: <${s}> ${n}`);if(!o&&!c)return i(`${t}, must provide either "params.modelYear" or "params.vehicleType", got: { modelYear: ${o}, vehicleType: ${c} }`);const g=u(o);if(e!=null&&e.modelYear&&g!=="number")return i(`${t}, "params.modelYear" must be of type number or string, got: <${g}> ${o}`);const $=u(c);if(c&&$!=="string")return i(`${t}, "params.vehicleType" must be of type string, got: <${$}> ${c}`);let d=`${t}/makeId/${n}/`;o&&c?d+=`modelYear/${o}/vehicleType/${c}`:o?d+=`modelYear/${o}`:d+=`vehicleType/${c}`;const h=await l().catch(b=>i(`${t}, error building query string: ${b}`)),M=`${f}/${d}${h}`;return await y().get(M).then(b=>b).catch(b=>i(`${t}, error fetching data: ${b}`))},X=async(e,t)=>{const n="GetModelsForMakeYear",o=t==null?void 0:t.modelYear,c=t==null?void 0:t.vehicleType;try{const r=[{name:"params.modelYear",types:["number","string"],value:o},{name:"params.vehicleType",types:["string"],value:c}],s=[{name:"make",required:!0,types:["string"],value:e},{name:"params",required:!0,types:["object"],value:t},...r];m({args:s}),m({args:r,mode:"atLeast"}),s.forEach(h=>{u(h.value)==="string"&&(h.value=G(h.value))});let g=`${n}/make/${e}/`;o&&(g+=`modelYear/${o}`),c&&(g+=`${o?"/":""}vehicleType/${c}`);const $=V(),d=`${f}/${g}${$}`;return await y().get(d).then(h=>h)}catch(r){return i(r)}},Q=async e=>{const t="GetParts",n=e==null?void 0:e.type,o=e==null?void 0:e.fromDate,c=e==null?void 0:e.toDate,r=e==null?void 0:e.page,s=u(e);if(e&&s!=="object")return i(`${t}, "params" argument must be of type object, got: <${s}> ${e}`);const g=u(n);if(n&&g!=="number")return i(`${t}, "params.type" argument must be of type number or string, got: <${g}> ${n}`);const $=u(o);if(o&&$!=="string")return i(`${t}, "params.fromDate" argument must be of type string, got: <${$}> ${o}`);const d=u(c);if(c&&d!=="string")return i(`${t}, "params.toDate" argument must be of type string, got: <${d}> ${c}`);const h=u(r);if(r&&h!=="number")return i(`${t}, "params.page" argument must be of type number or string, got: <${h}> ${r}`);const M=await l(e).catch(q=>i(`${t}, error building query string: ${q}`)),b=`${f}/${t}${M}`;return await y().get(b).then(q=>q).catch(q=>i(`${t}, error fetching data: ${q}`))},Z=async e=>{const t="GetVehicleTypesForMake",n=u(e);if(!e||n!=="string")return i(`${t}, "makeName" argument is required and must be of type string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},z=async e=>{const t="GetVehicleTypesForMakeId",n=u(e);if(!e||n!=="number")return i(`${t}, "makeId" argument is required and must be of type number or string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},K=async()=>{const e="GetVehicleVariableList",t=await l().catch(o=>i(`${e}, error building query string: ${o}`)),n=`${f}/${e}${t}`;return await y().get(n).then(o=>o).catch(o=>i(`${e}, error fetching data: ${o}`))},x=async e=>{const t="GetVehicleVariableValuesList",n=u(e);if(!e||!["number","string"].includes(n))return i(`${t}, "variableValue" argument is required and must be of type number or string, got <${n}> ${e}`);e=encodeURI(String(e));const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},ee=async(e,t)=>{const n="GetWMIsForManufacturer",o=t==null?void 0:t.vehicleType;if(!e&&!o)return i(`${n}, "manufacturer" and "params.vehicleType" arguments are optional but at least 1 is required, got: manufacturer: ${e} and vehicleType: ${o}`);const c=u(e);if(e&&!["number","string"].includes(c))return i(`${n}, "manufacturer" must be of type number or string, got <${c}> ${e}`);const r=u(t);if(t&&r!=="object")return i(`${n}, "params" must be of type object, got: <${r}> ${t}`);const s=u(t==null?void 0:t.vehicleType);if(t!=null&&t.vehicleType&&!["number","string"].includes(s))return i(`${n}, "params.vehicleType" must be of type number or string, got: <${s}> ${t.vehicleType}`);const g=await l(t).catch(d=>i(`${n}, error building query string: ${d}`)),$=`${f}/${n}/${e||""}${g}`;return await y().get($).then(d=>d).catch(d=>i(`${n}, error fetching data: ${d}`))};a.DecodeVin=I,a.DecodeVinExtended=F,a.DecodeVinValues=A,a.DecodeVinValuesBatch=D,a.DecodeVinValuesExtended=P,a.DecodeWMI=v,a.GetAllMakes=R,a.GetAllManufacturers=L,a.GetCanadianVehicleSpecifications=C,a.GetEquipmentPlantCodes=N,a.GetMakeForManufacturer=O,a.GetMakesForManufacturerAndYear=U,a.GetMakesForVehicleType=W,a.GetManufacturerDetails=_,a.GetModelsForMake=B,a.GetModelsForMakeId=H,a.GetModelsForMakeIdYear=J,a.GetModelsForMakeYear=X,a.GetParts=Q,a.GetVehicleTypesForMake=Z,a.GetVehicleTypesForMakeId=z,a.GetVehicleVariableList=K,a.GetVehicleVariableValuesList=x,a.GetWMIsForManufacturer=ee,a.isValidVin=E,Object.defineProperty(a,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=nhtsa-api-wrapper.umd.js.map
