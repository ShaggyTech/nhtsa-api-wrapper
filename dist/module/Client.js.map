{"version":3,"file":"Client.js","sources":["../../src/utils/getTypeof.ts","../../src/utils/isValidType.ts","../../src/utils/isValidVin.ts","../../src/utils/makeQueryString.ts","../../node_modules/cross-fetch/dist/browser-ponyfill.js","../../src/api/Fetch.ts","../../src/api/actions/DecodeVin.ts","../../src/api/actions/DecodeVinValues.ts","../../src/api/actions/DecodeVinExtended.ts","../../src/api/actions/DecodeVinValuesExtended.ts","../../src/api/actions/DecodeWMI.ts","../../src/api/actions/GetWMIsForManufacturer.ts","../../src/api/actions/GetAllMakes.ts","../../src/api/actions/GetParts.ts","../../src/api/actions/GetAllManufacturers.ts","../../src/api/actions/GetManufacturerDetails.ts","../../src/api/actions/GetMakeForManufacturer.ts","../../src/api/actions/GetMakesForManufacturerAndYear.ts","../../src/api/actions/GetMakesForVehicleType.ts","../../src/api/actions/GetVehicleTypesForMake.ts","../../src/api/actions/GetVehicleTypesForMakeId.ts","../../src/api/NHTSA.ts"],"sourcesContent":["/**\r\n * @module getTypeof\r\n * @category Utils\r\n */\r\n\r\n/**\r\n * Returns the typeof of a given value using Object.prototype.toString.call(value)\r\n * @param {any} value what value to get the type of\r\n * @returns {string} Type of value, normalized to a lowercase string\r\n */\r\n\r\nexport function getTypeof(value: any): string {\r\n  const type = Object.prototype.toString\r\n    .call(value)\r\n    .toLowerCase(); /* ex: => [object string] */\r\n  return type.slice(8, type.length - 1);\r\n}\r\n","/**\r\n * @memberof module:isValidType\r\n * @category Utils\r\n *\r\n * @description Options argument object provided to utils/isValidType()\r\n *\r\n * ```javascript\r\n *  {\r\n *    type: <string>,\r\n *    value: <any>\r\n *  }\r\n * ```\r\n */\r\ninterface IsValidTypeOptions {\r\n  type: string;\r\n  value: any;\r\n}\r\n\r\n/**\r\n * @module isValidType\r\n * @category Utils\r\n */\r\n\r\n/**\r\n * @async\r\n * @description Validate types and existence of various input values.<br>\r\n * Note: Uses `Object.prototype.toString.call(value)` under the hood\r\n *\r\n * ---\r\n *\r\n * Returns `true` if:\r\n *   - type of value is equal to provided type\r\n *\r\n * ---\r\n *\r\n * Returns `false` if:\r\n *   - 'options.value is not of type options.type\r\n *   - 'options.type' is missing from options object\r\n *   - 'options.type' is not of type 'string'\r\n *   - 'options.value' is falsey or not provided\r\n *\r\n * @param {object} options Object of Type [IsValidTypeOptions](module-isValidType.IsValidTypeOptions.html)\r\n * @param {string} options.type What type are you expecting the value to be?\r\n * @param {any} options.value What value are we testing against?\r\n * @returns {Promise<Boolean>}\r\n *\r\n * @example <caption>Verify type string</caption>\r\n * const isValid = await isValidType({\r\n *   type: 'string',\r\n *   value: 'this is a string'\r\n * }).catch(error => error)\r\n * //  isValid = \"true\"\r\n *\r\n * @example <caption>Verify type object</caption>\r\n * const isValid = await isValidType({\r\n *   type: 'object',\r\n *   value: { someKey: 'some value' }\r\n * }).catch(error => error)\r\n * //  isValid = \"true\"\r\n *\r\n * @example <caption>Returns false if type is not valid</caption>\r\n * const isValid = await isValidType({\r\n *   type: 'array',\r\n *   value: 'this is not an array'\r\n * }).catch(error => error)\r\n * //  isValid = \"false\"\r\n */\r\n\r\nexport async function isValidType(opts: IsValidTypeOptions): Promise<boolean> {\r\n  // Gatekeeping\r\n  if (typeof opts?.type !== 'string' || !opts.value) {\r\n    return Promise.resolve(false);\r\n  }\r\n\r\n  // normalize type\r\n  const type_ = opts.type.toLowerCase();\r\n\r\n  const expected = `[object ${type_}]`;\r\n  const actual = Object.prototype.toString.call(opts.value).toLowerCase();\r\n\r\n  return Promise.resolve(expected === actual);\r\n}\r\n","/**\r\n * @module isValidVin\r\n * @category Utils\r\n */\r\n\r\n/**\r\n * @async\r\n *\r\n * @description Provides **offline** validation of Vehicle Identification Numbers (VINs) using the\r\n * [VIN Check Algorithm](https://en.wikibooks.org/wiki/Vehicle_Identification_Numbers_(VIN_codes)/Check_digit)\r\n *\r\n * @param {string} vin Vehicle Identification Number\r\n *\r\n * @returns {Promise<boolean>} true | false\r\n *\r\n * @example <caption>When loaded from a bundle via html script tags</caption>\r\n * // <script type=\"text/javascript\" src=\"https://www.npmjs.com/package/@shaggytools/nhtsa-api-wrapper\"></script>\r\n * const isValid = await NHTSA.isValidVin('3VWD07AJ5EM388202').catch(error => error)\r\n * // isValid = true\r\n *\r\n * @example <caption>When loaded as a module</caption>\r\n * import { isValidVin } from '@shaggytools/nhtsa-api-wrapper'\r\n * const isValid = await isValidVin('3VWD07AJ5EM388202').catch(error => error)\r\n * // isValid = true\r\n */\r\nexport async function isValidVin(vin: string): Promise<boolean> {\r\n  /* A valid VIN must be a string and is always exactly 17 digits */\r\n  if (typeof vin !== 'string' || vin.length != 17) {\r\n    return Promise.resolve(false);\r\n  }\r\n\r\n  /* Normalize the vin to all uppercase letters */\r\n  vin = vin.toUpperCase();\r\n\r\n  /* split the vin digits into an array */\r\n  const vinArray: string[] = vin.split('');\r\n\r\n  /* checkDigit will be tested against the checkSum later */\r\n  const checkDigit: string = vinArray[8];\r\n\r\n  /*\r\n   * In a valid VIN, the checkDigit can either be:\r\n   * a number, 0-9 inclusive OR the character 'X'\r\n   */\r\n  if (isNaN(parseInt(checkDigit)) && checkDigit !== 'X') {\r\n    return Promise.resolve(false);\r\n  }\r\n\r\n  /*\r\n   * The checkValue must be a digit and 'X' is the only valid alphabetic check value.\r\n   * As per the algorithm, a checkDigit of 'X' is equal to a checkValue of `10` and needs\r\n   * to be converted as such.\r\n   */\r\n  const checkValue: number = checkDigit === 'X' ? 10 : parseInt(checkDigit);\r\n\r\n  /*\r\n   * There will need to be some way to translate vin digits that are alphabetic\r\n   * into their number value in the VIN algorithm transliteration table.\r\n   * Later, during the creation of the checkusm variable, those digits will be\r\n   * multiplied against their corresponding weight (by index) in the weightsArray.\r\n   * This transliteration table is a key part of the VIN validation algorithm.\r\n   */\r\n  const transliterationTable: object = {\r\n    A: 1,\r\n    B: 2,\r\n    C: 3,\r\n    D: 4,\r\n    E: 5,\r\n    F: 6,\r\n    G: 7,\r\n    H: 8,\r\n    J: 1,\r\n    K: 2,\r\n    L: 3,\r\n    M: 4,\r\n    N: 5,\r\n    P: 7,\r\n    R: 9,\r\n    S: 2,\r\n    T: 3,\r\n    U: 4,\r\n    V: 5,\r\n    W: 6,\r\n    X: 7,\r\n    Y: 8,\r\n    Z: 9\r\n  };\r\n\r\n  /*\r\n   * Later, during the creation of the 'checksum' variable, these weights will be\r\n   * multilplied by the value of their mirrored index vin digits.\r\n   * The array index of each weight corresponds to the same index of each\r\n   * digit in the 'vin'.\r\n   */\r\n  const weightsArray: number[] = [\r\n    8,\r\n    7,\r\n    6,\r\n    5,\r\n    4,\r\n    3,\r\n    2,\r\n    10,\r\n    0,\r\n    9,\r\n    8,\r\n    7,\r\n    6,\r\n    5,\r\n    4,\r\n    3,\r\n    2\r\n  ];\r\n\r\n  /*\r\n   * Maps the vinArray and converts any values (digits) that are alphabetic,\r\n   * into numbers, using the above transliteration table.\r\n   * Then these numbers are multiplied against their corresponding weight\r\n   * in the weights array, matched by index position.\r\n   * All 17 of those digitValues are then added together and divided by 11.\r\n   * The remainder, or % modulo, of that division will be the final 'checksum'.\r\n   */\r\n  const checksum =\r\n    vinArray\r\n      .map((digit, index) => {\r\n        let digitValue: number;\r\n        isNaN(parseInt(digit))\r\n          ? (digitValue = transliterationTable[digit])\r\n          : (digitValue = parseInt(digit));\r\n\r\n        const weight: number = weightsArray[index];\r\n        return digitValue * weight;\r\n      })\r\n      .reduce((acc, currValue) => acc + currValue, 0) % 11;\r\n\r\n  /*\r\n   * The checksum is compared against the checkValue we set earlier (the 9th digit of the VIN)\r\n   * As per the algorithm, if they are equal to each other, then the VIN must be valid and\r\n   * we return true, otherwise the VIN is invalid and we return false.\r\n   */\r\n  return Promise.resolve(checksum === checkValue);\r\n}\r\n","/**\r\n * @memberof module:makeQueryString\r\n * @category Utils\r\n *\r\n * @description Object containing Key:Value pairs to build the URL query string with.<br>\r\n * Parameter values may be either strings or numbers. <br>\r\n * ---\r\n * ```javascript\r\n *  Example\r\n *  {\r\n *    format: 'json',\r\n *    modelYear: 2009,\r\n *    whatever: 'something'\r\n *  }\r\n * ```\r\n */\r\nexport interface QueryStringParameters {\r\n  [propName: string]: string | number | undefined;\r\n}\r\n\r\n/**\r\n * @module makeQueryString\r\n * @category Utils\r\n */\r\n\r\n/**\r\n * @async\r\n * @description Utility method to generate a query string.<br>\r\n *   Prepend it to an API URL string. <br>\r\n *   ---\r\n *\r\n * @param {object} params Object of Type [QueryStringParameters](module-makeQueryString.QueryStringParameters.html)\r\n *\r\n * @returns {Promise<string>|Error} An API query string <br>\r\n *  - On resolve: `Promise(<string>)`<br>\r\n *  - On reject: `new Error(<string>)` - if parameters are not of type 'object'\r\n *\r\n * @example <caption>Single Param:</caption>\r\n * const qs = await genQueryString({\r\n *   format: 'json'\r\n * }).catch(error => error)\r\n * //  qs = \"format=json\"\r\n *\r\n * @example <caption>Multiple Params:</caption>\r\n * const qs = await genQueryString({\r\n *   format: 'json',\r\n *   modelYear: 2006,\r\n *   page: \"2\"\r\n * }).catch(error => error)\r\n * // qs = \"?format=json&modelYear=2006&page=2\"\r\n *\r\n * @example <caption>Empty Params Object:</caption>\r\n * const qs = await genQueryString({}).catch(error => error)\r\n * // qs = \"\"\r\n *\r\n */\r\n\r\nexport function makeQueryString(\r\n  params: QueryStringParameters = {}\r\n): Promise<string | Error> {\r\n  // Error message begins with\r\n  const errorBase =\r\n    'queryString(params) - expected params in the form of an object , got:';\r\n\r\n  // Type guard params argument, must be of type object\r\n  if (Object.prototype.toString.call(params) !== '[object Object]') {\r\n    return Promise.reject(new Error(`${errorBase} ${params}`));\r\n  }\r\n\r\n  // Setup QueryString for Array mapping\r\n  const entries = Object.entries(params);\r\n  const paramsLength = entries.length;\r\n\r\n  // Return an empty string if params are an empty object\r\n  if (paramsLength < 1) return Promise.resolve('');\r\n\r\n  // Used to check if we've already prepended a valid query param\r\n  let isPrepended = false;\r\n\r\n  // Map [key]:value entries to \"key=value\" strings in an array\r\n  const queryStringArray = entries.map(([key, value], index) => {\r\n    let prepend = '';\r\n    let append = '';\r\n\r\n    const typeofValue = typeof value;\r\n\r\n    if (value && typeofValue === 'number') {\r\n      value = value.toString();\r\n    }\r\n\r\n    // skip any invalid values, only string or number types are valid\r\n    if (value && (typeofValue === 'string' || typeofValue === 'number')) {\r\n      // if this is the first param we need to prepend the '?' char\r\n      if (value !== '' && !isPrepended) {\r\n        prepend = '?';\r\n        isPrepended = true;\r\n      }\r\n      // if there is another param coming after this one we need to append the '&' char\r\n      if (index < paramsLength - 1) {\r\n        append = '&';\r\n      }\r\n\r\n      // map the completed partial query string to queryStringArray\r\n      return `${prepend}${key}=${value}${append}`;\r\n    }\r\n    return;\r\n  });\r\n\r\n  // Join and return the completed query string anfter URI encoding\r\n  return Promise.resolve(encodeURI(queryStringArray.join('')));\r\n}\r\n","var __self__ = (function (root) {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = root.DOMException\n}\nF.prototype = root;\nreturn new F();\n})(typeof self !== 'undefined' ? self : this);\n(function(self) {\n\nvar irrelevant = (function (exports) {\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  return exports;\n\n}({}));\n})(__self__);\ndelete __self__.fetch.polyfill\nexports = __self__.fetch // To enable: import fetch from 'cross-fetch'\nexports.default = __self__.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = __self__.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = __self__.Headers\nexports.Request = __self__.Request\nexports.Response = __self__.Response\nmodule.exports = exports\n","/* Module Dependencies */\r\nimport fetch from 'cross-fetch';\r\n\r\n/* Utilities */\r\nimport { getTypeof, makeQueryString, QueryStringParameters } from '../utils';\r\n\r\n/* Types */\r\nimport { FetchConfig, FetchResponse, NhtsaResponse } from './index';\r\n\r\n/* Constants */\r\nexport const BASE_URL = 'https://vpic.nhtsa.dot.gov/api/vehicles';\r\nexport const DEFAULT_CONFIG: FetchConfig = {\r\n  apiResponseFormat: 'json',\r\n  baseUrl: BASE_URL\r\n};\r\n\r\nexport class Fetch {\r\n  apiResponseFormat?: string;\r\n  baseUrl?: string;\r\n  config?: FetchConfig;\r\n\r\n  constructor(userConfig?: FetchConfig) {\r\n    let finalConfig: FetchConfig;\r\n\r\n    if (getTypeof(userConfig) === 'object') {\r\n      finalConfig = { ...DEFAULT_CONFIG, ...userConfig };\r\n    } else {\r\n      finalConfig = { ...DEFAULT_CONFIG };\r\n    }\r\n\r\n    this.apiResponseFormat = 'json';\r\n    this.baseUrl = finalConfig.baseUrl;\r\n    this.config = finalConfig;\r\n  }\r\n\r\n  public async buildQueryString(\r\n    params: QueryStringParameters\r\n  ): Promise<string | Error> {\r\n    /*\r\n     * Make sure we're always using 'format=json' in the url Query parameters\r\n     * If the user provides a 'format' key in the params, during class instantiation we want to override it to 'json'\r\n     * Support for the other formats (CSV and XML) can be added at a later date by configuring the fetch request\r\n     */\r\n    if (!params || getTypeof(params) !== 'object') {\r\n      params = {\r\n        format: this.apiResponseFormat\r\n      };\r\n    } else {\r\n      params = { ...params, format: this.apiResponseFormat };\r\n    }\r\n\r\n    return await makeQueryString(params);\r\n  }\r\n\r\n  public async get(url: string): Promise<FetchResponse | Error> {\r\n    if (getTypeof(url) !== 'string') {\r\n      return Promise.reject(\r\n        new Error('Fetch.get(url) - url argument must be of type string')\r\n      );\r\n    }\r\n\r\n    const response: Response = await fetch(url)\r\n      .then(result => {\r\n        if (!result?.status || result.status >= 400) {\r\n          throw new Error(\r\n            `Bad response from server, code: ${result?.status}, text: ${result?.statusText}, headers: ${result?.headers}`\r\n          );\r\n        }\r\n\r\n        return result;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`Fetch.get() http error: ${err}`))\r\n      );\r\n\r\n    const json: NhtsaResponse = await response.json();\r\n\r\n    const finalResult: FetchResponse = {\r\n      ...json,\r\n      Response: {\r\n        headers: response.headers,\r\n        ok: response.ok,\r\n        redirected: response.redirected,\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        url: response.url\r\n      }\r\n    };\r\n\r\n    return Promise.resolve(finalResult);\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class DecodeVin extends Fetch {\r\n  /**\r\n   * The DecodeVin API Action will decode the VIN and the decoded output will be made available in the format of Key-value pairs.\r\n   * The IDs (VariableID and ValueID) represent the unique ID associated with the Variable/Value.\r\n   * In case of text variables, the ValueID is not applicable.\r\n   * Model Year in the request allows for the decoding to specifically be done in the current,\r\n   * or older (pre-1980), model year ranges. It is recommended to always send in the model year.\r\n   * This API also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   * In this case, the VIN will be decoded partially with the available characters.\r\n   * In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   * The 9th digit is not necessary.\r\n   */\r\n  async DecodeVin(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'DecodeVin';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class DecodeVinValues extends Fetch {\r\n  /**\r\n   * The DecodeVinValues API Action will decode the VIN and the decoded output will be made available in a flat file format.\r\n   * Model Year in the request allows for the decoding to specifically be done in the current,\r\n   * or older (pre-1980), model year ranges. It is recommended to always send in the model year.\r\n   * This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   * In this case, the VIN will be decoded partially with the available characters.\r\n   * In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   */\r\n  async DecodeVinValues(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'DecodeVinValues';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class DecodeVinExtended extends Fetch {\r\n  /**\r\n   * This is exactly like the DecodeVin method but provides additional information on variables\r\n   * related to other NHTSA programs like NCSA etc.\r\n   * This will decode the VIN and the decoded output will be made available\r\n   * in the format of Key-value pairs.\r\n   * The IDs (VariableID and ValueID) represent the unique ID associated with the Variable/Value.\r\n   * In case of text variables, the ValueID is not applicable.\r\n   * Model Year in the request allows for the decoding to specifically be done in the current,\r\n   * or older (pre-1980), model year ranges. It is recommended to always send in the model year.\r\n   * This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   * In this case, the VIN will be decoded partially with the available characters.\r\n   * In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   * The 9th digit is not necessary.\r\n   */\r\n  async DecodeVinExtended(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'DecodeVinExtended';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class DecodeVinValuesExtended extends Fetch {\r\n  /**\r\n   * This is exactly like the DecodeVinValues (flat format) method but provides additional information\r\n   * on variables related to other NHTSA programs like NCSA etc.\r\n   * This will decode the VIN and the decoded output will be made available in a flat file format.\r\n   * Model Year in the request allows for the decoding to specifically be done in the current,\r\n   * or older (pre-1980), model year ranges. It is recommended to always send in the model year.\r\n   * This Action also supports partial VIN decoding (VINs that are less than 17 characters).\r\n   * In this case, the VIN will be decoded partially with the available characters.\r\n   * In case of partial VINs, a \"*\" could be used to indicate the unavailable characters.\r\n   */\r\n  async DecodeVinValuesExtended(\r\n    vin: string,\r\n    params: {\r\n      modelYear?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'DecodeVinValuesExtended';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(vin) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, vin argument is required and must be a string, got: ${vin}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${vin}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class DecodeWMI extends Fetch {\r\n  /**\r\n   * This provides information on the World Manufacturer Identifier for a specific WMI code.\r\n   * WMIs may be put in as either 3 characters representing VIN position 1-3 or 6 characters\r\n   * representing VIN positions 1-3 & 12-14. Example \"JTD\", \"1T9131\".\r\n   */\r\n  async DecodeWMI(WMI: string): Promise<NhtsaResponse | Error> {\r\n    const action = 'DecodeWMI';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(WMI) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, WMI argument is required and must be a string, got: ${WMI}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${WMI}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetWMIsForManufacturer extends Fetch {\r\n  /**\r\n   * Provides information on the all World Manufacturer Identifier (WMI) for a specified Manufacturer.\r\n   * Only WMI registered in vPICList are displayed.\r\n   */\r\n  async GetWMIsForManufacturer(\r\n    manufacturer: string\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetWMIsForManufacturer';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(manufacturer) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetAllMakes extends Fetch {\r\n  /**\r\n   * This provides a list of all the Makes available in vPIC Dataset.\r\n   */\r\n  public async GetAllMakes(): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetAllMakes';\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetParts extends Fetch {\r\n  /**\r\n   * This provides a list of ORGs with letter date in the given range of the dates and with specified Type of ORG.\r\n   * Up to 1000 results will be returned at a time, get the next page by incrementing the \"page\" parameter.\r\n   */\r\n  async GetParts(\r\n    params: {\r\n      type?: string | number;\r\n      fromDate?: string;\r\n      toDate?: string;\r\n      page?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetParts';\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { RequestManufacturerType, NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetAllManufacturers extends Fetch {\r\n  /**\r\n   * This provides a list of all the Manufacturers available in vPIC Dataset.\r\n   * Parameter \"manufacturerType\" allows to filter the list based on manufacturer type,\r\n   * (Incomplete Vehicles, Completed Vehicle Manufacturer, Incomplete Vehicle Manufacturer,\r\n   * Intermediate Manufacturer, Final-Stage Manufacturer, Alterer, or any part of it), optional.\r\n   * You can get a list of all manufacturer types with this API call:\r\n   * \"/api/vehicles/getvehiclevariablevalueslist/Manufacturer Type\"\r\n   * Results are provided in pages of 100 items.\r\n   * Use parameter \"page\" to specify 1-st (default), 2nd, 3rd, ...Nth ... page.\r\n   */\r\n  async GetAllManufacturers(\r\n    params: {\r\n      manufacturerType?: RequestManufacturerType;\r\n      page?: string | number;\r\n    } = {}\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetAllManufacturers';\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetManufacturerDetails extends Fetch {\r\n  /**\r\n   * This provides the details for a specific manufacturer that is requested.\r\n   * If supplied manufacturer is a number - method will do exact match on Manufacturer's Id.\r\n   * If supplied manufacturer is a string - it will look for manufacturers whose name is LIKE the provided name,\r\n   * (it accepts a partial manufacturer name as an input).\r\n   * Multiple results are returned in case of multiple matches.\r\n   */\r\n  public async GetManufacturerDetails(\r\n    manufacturer: string | number\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetManufacturerDetails';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string or number, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetMakeForManufacturer extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified manufacturer that is requested.\r\n   * If supplied manufacturer is a number - method will do exact match on Manufacturer's Id.\r\n   * If supplied manufacturer is a string - it will look for manufacturers whose name is LIKE the provided name\r\n   * (it accepts a partial manufacturer name as an input).\r\n   * Multiple results are returned in case of multiple matches.\r\n   * Manufacturer name can be a partial name, or a full name for more specificity\r\n   * (e.g., \"988\", \"HONDA\", \"HONDA OF CANADA MFG., INC.\", etc.)\r\n   */\r\n  async GetMakeForManufacturer(\r\n    manufacturer: string | number\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetMakeForManufacturer';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, manufacturer argument is required and must be a string or number, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetMakesForManufacturerAndYear extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified manufacturer,\r\n   * and whose Year From and Year To range cover the specified year.\r\n   * If supplied manufacturer is a number - method will do exact match on Manufacturer's Id.\r\n   * If supplied manufacturer is a string - it will look for manufacturers whose name is LIKE the provided name\r\n   * (it accepts a partial manufacturer name as an input).\r\n   * Multiple results are returned in case of multiple matches.\r\n   * Manufacturer can be idenfitied by Id, a partial name, or a full name\r\n   * (e.g., \"988\", \"HONDA\", \"HONDA OF CANADA MFG., INC.\", etc.)\r\n   */\r\n  public async GetMakesForManufacturerAndYear(\r\n    manufacturer: string | number,\r\n    params: {\r\n      year: string | number;\r\n    } = { year: undefined as any }\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetMakesForManufacturerAndYear';\r\n\r\n    /* Runtime typechecking */\r\n    if (!manufacturer) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, please provide a valid manufacturer arg, either a number or string, got: ${manufacturer}`\r\n        )\r\n      );\r\n    }\r\n    if (!params.year) {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, please provide a valid year parameter, either a number or string, got params.year: ${params.year}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString(params).catch(err =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${manufacturer}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch(err =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetMakesForVehicleType extends Fetch {\r\n  /**\r\n   * This returns all the Makes in the vPIC dataset for a specified vehicle type,\r\n   * whose name is LIKE the vehicle type name in vPIC Dataset.\r\n   * Vehicle Type name can be a partial name, or a full name for more specificity\r\n   * (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.).\r\n   */\r\n  async GetMakesForVehicleType(\r\n    typeName: string\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetMakesForVehicleType';\r\n\r\n    if (getTypeof(typeName) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, typeName is required and must be a string, got: ${typeName}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${typeName}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetVehicleTypesForMake extends Fetch {\r\n  /**\r\n   * This returns all the Vehicle Types in the vPIC dataset for a specified Make,\r\n   * whose name is LIKE the make name in vPIC Dataset.\r\n   * Make name can be a partial name, or a full name for more specificity\r\n   * (e.g., \"Merc\", \"Mercedes Benz\", etc.).\r\n   */\r\n  async GetVehicleTypesForMake(\r\n    makeName: string\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetVehicleTypesForMake';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeName) !== 'string') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeName is required and must be a string, got: ${makeName}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${makeName}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Utiltiy Functions */\r\nimport { getTypeof } from '../../utils';\r\n\r\n/* Types */\r\nimport { NhtsaResponse } from '../index';\r\n\r\n/* Parent Class */\r\nimport { Fetch } from '../Fetch';\r\n\r\nexport class GetVehicleTypesForMakeId extends Fetch {\r\n  /**\r\n   * This returns all the Vehicle Types in the vPIC dataset for a specified Make\r\n   * whose ID equals the make ID in vPIC Dataset.\r\n   */\r\n  async GetVehicleTypesForMakeId(\r\n    makeID: number\r\n  ): Promise<NhtsaResponse | Error> {\r\n    const action = 'GetVehicleTypesForMakeId';\r\n\r\n    /* Runtime typechecking */\r\n    if (getTypeof(makeID) !== 'number') {\r\n      return Promise.reject(\r\n        new Error(\r\n          `${action}, makeID is required and must be a number, got: ${makeID}`\r\n        )\r\n      );\r\n    }\r\n\r\n    /* Build the 'default' query string to be appended to the URL*/\r\n    const queryString = await this.buildQueryString({}).catch((err: Error) =>\r\n      Promise.reject(\r\n        new Error(`${action}, Error building query string: ${err}`)\r\n      )\r\n    );\r\n    const url = `${this.baseUrl}/${action}/${makeID}${queryString}`;\r\n\r\n    return await this.get(url)\r\n      .then(response => {\r\n        return response;\r\n      })\r\n      .catch((err: Error) =>\r\n        Promise.reject(new Error(`${action}, Fetch.get() error: ${err}`))\r\n      );\r\n  }\r\n}\r\n","/* Parent Class */\r\nimport { Fetch } from './Fetch';\r\n\r\n/* API Actions */\r\nimport {\r\n  DecodeVin,\r\n  DecodeVinValues,\r\n  DecodeVinExtended,\r\n  DecodeVinValuesExtended,\r\n  DecodeWMI,\r\n  GetWMIsForManufacturer,\r\n  GetAllMakes,\r\n  GetParts,\r\n  GetAllManufacturers,\r\n  GetManufacturerDetails,\r\n  GetMakeForManufacturer,\r\n  GetMakesForManufacturerAndYear,\r\n  GetMakesForVehicleType,\r\n  GetVehicleTypesForMake,\r\n  GetVehicleTypesForMakeId\r\n} from './actions';\r\n\r\n/* Types */\r\nimport { FetchConfig } from './index';\r\n\r\nclass NHTSA extends Fetch\r\n  implements\r\n    DecodeVin,\r\n    DecodeVinValues,\r\n    DecodeVinExtended,\r\n    DecodeVinValuesExtended,\r\n    DecodeWMI,\r\n    GetAllMakes,\r\n    GetParts,\r\n    GetAllManufacturers,\r\n    GetManufacturerDetails,\r\n    GetMakeForManufacturer,\r\n    GetWMIsForManufacturer,\r\n    GetMakesForManufacturerAndYear,\r\n    GetMakesForVehicleType,\r\n    GetVehicleTypesForMake,\r\n    GetVehicleTypesForMakeId {\r\n  constructor(userConfig?: FetchConfig) {\r\n    super(userConfig);\r\n  }\r\n\r\n  DecodeVin = DecodeVin.prototype.DecodeVin;\r\n\r\n  DecodeVinValues = DecodeVinValues.prototype.DecodeVinValues;\r\n\r\n  DecodeVinExtended = DecodeVinExtended.prototype.DecodeVinExtended;\r\n\r\n  DecodeVinValuesExtended =\r\n    DecodeVinValuesExtended.prototype.DecodeVinValuesExtended;\r\n\r\n  DecodeWMI = DecodeWMI.prototype.DecodeWMI;\r\n\r\n  GetWMIsForManufacturer =\r\n    GetWMIsForManufacturer.prototype.GetWMIsForManufacturer;\r\n\r\n  GetAllMakes = GetAllMakes.prototype.GetAllMakes;\r\n\r\n  GetParts = GetParts.prototype.GetParts;\r\n\r\n  GetAllManufacturers = GetAllManufacturers.prototype.GetAllManufacturers;\r\n\r\n  GetManufacturerDetails =\r\n    GetManufacturerDetails.prototype.GetManufacturerDetails;\r\n\r\n  GetMakeForManufacturer =\r\n    GetMakeForManufacturer.prototype.GetMakeForManufacturer;\r\n\r\n  GetMakesForManufacturerAndYear =\r\n    GetMakesForManufacturerAndYear.prototype.GetMakesForManufacturerAndYear;\r\n\r\n  GetMakesForVehicleType =\r\n    GetMakesForVehicleType.prototype.GetMakesForVehicleType;\r\n\r\n  GetVehicleTypesForMake =\r\n    GetVehicleTypesForMake.prototype.GetVehicleTypesForMake;\r\n\r\n  GetVehicleTypesForMakeId =\r\n    GetVehicleTypesForMakeId.prototype.GetVehicleTypesForMakeId;\r\n}\r\n\r\nexport { NHTSA };\r\n\r\nexport const Client = new NHTSA();\r\n"],"names":["getTypeof","value","type","Object","prototype","toString","call","toLowerCase","slice","length","isValidType","opts","type_","expected","actual","Promise","resolve","isValidVin","vin","toUpperCase","vinArray","split","checkDigit","isNaN","parseInt","checkValue","transliterationTable","A","B","C","D","E","F","G","H","J","K","L","M","N","P","R","S","T","U","V","W","X","Y","Z","weightsArray","checksum","map","digit","index","reduce","acc","currValue","makeQueryString","params","reject","Error","errorBase","entries","paramsLength","isPrepended","queryStringArray","_a","key","prepend","append","typeofValue","encodeURI","join","__self__","root","fetch","DOMException","self","this","exports","support","Symbol","Blob","e","viewClasses","isArrayBufferView","ArrayBuffer","isView","obj","indexOf","normalizeName","name","String","test","TypeError","normalizeValue","iteratorFor","items","iterator","next","shift","done","undefined","Headers","headers","forEach","Array","isArray","header","getOwnPropertyNames","consumed","body","bodyUsed","fileReaderReady","reader","onload","result","onerror","error","readBlobAsArrayBuffer","blob","FileReader","promise","readAsArrayBuffer","bufferClone","buf","view","Uint8Array","byteLength","set","buffer","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","DataView","_bodyArrayBuffer","get","rejected","arrayBuffer","then","text","readAsText","chars","i","fromCharCode","readArrayBufferAsText","formData","decode","json","JSON","parse","oldValue","has","hasOwnProperty","callback","thisArg","keys","push","values","methods","Request","input","options","method","upcased","url","credentials","mode","signal","referrer","form","trim","bytes","replace","decodeURIComponent","Response","bodyInit","status","ok","statusText","clone","response","redirectStatuses","redirect","RangeError","location","err","message","stack","create","constructor","init","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","rawHeaders","getAllResponseHeaders","line","parts","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","module","DEFAULT_CONFIG","apiResponseFormat","baseUrl","userConfig","finalConfig","config","Fetch","format","catch","finalResult","redirected","__extends","DecodeVin","action","buildQueryString","queryString","DecodeVinValues","DecodeVinExtended","DecodeVinValuesExtended","DecodeWMI","WMI","GetWMIsForManufacturer","manufacturer","GetAllMakes","GetParts","GetAllManufacturers","GetManufacturerDetails","GetMakeForManufacturer","GetMakesForManufacturerAndYear","year","GetMakesForVehicleType","typeName","GetVehicleTypesForMake","makeName","GetVehicleTypesForMakeId","makeID","_super","_this","Client","NHTSA"],"mappings":"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"}