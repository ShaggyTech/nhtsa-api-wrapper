{"version":3,"file":"nhtsa-api-wrapper.mjs","sources":["../src/utils/argHandler.ts","../src/constants.ts","../src/utils/getTypeof.ts","../src/utils/createQueryString.ts","../src/utils/errorHandler.ts","../src/utils/isValidVin.ts","../src/utils/makeQueryString.ts","../src/utils/useFetch.ts","../src/api/endpoints/DecodeVin.ts","../src/api/endpoints/DecodeVinExtended.ts","../src/api/endpoints/DecodeVinValues.ts","../src/api/endpoints/DecodeVinValuesBatch.ts","../src/api/endpoints/DecodeVinValuesExtended.ts","../src/api/endpoints/DecodeWMI.ts","../src/api/endpoints/GetAllMakes.ts","../src/api/endpoints/GetAllManufacturers.ts","../src/api/endpoints/GetCanadianVehicleSpecifications.ts","../src/api/endpoints/GetEquipmentPlantCodes.ts","../src/api/endpoints/GetMakeForManufacturer.ts","../src/api/endpoints/GetMakesForManufacturerAndYear.ts","../src/api/endpoints/GetMakesForVehicleType.ts","../src/api/endpoints/GetManufacturerDetails.ts","../src/api/endpoints/GetModelsForMake.ts","../src/api/endpoints/GetModelsForMakeId.ts","../src/api/endpoints/GetModelsForMakeIdYear.ts","../src/api/endpoints/GetModelsForMakeYear.ts","../src/api/endpoints/GetParts.ts","../src/api/endpoints/GetVehicleTypesForMake.ts","../src/api/endpoints/GetVehicleTypesForMakeId.ts","../src/api/endpoints/GetVehicleVariableList.ts","../src/api/endpoints/GetVehicleVariableValuesList.ts","../src/api/endpoints/GetWMIsForManufacturer.ts"],"sourcesContent":["import { getTypeof } from '../utils'\n/* Types */\nimport type { AtLeastOne } from '../types'\n\nexport type IArgToValidate = {\n  name: string\n  value: unknown\n} & AtLeastOne<{\n  types?: string[]\n  required?: boolean\n}>\n\nexport const catchInvalidArguments = ({\n  args,\n  mode = 'default',\n}: {\n  args: IArgToValidate[]\n  mode?: 'default' | 'atLeast'\n}) => {\n  if (mode === 'default') {\n    args.forEach((arg) => {\n      validateArgument(arg)\n    })\n  } else if (mode === 'atLeast') {\n    const providedArg = args.find((arg) => arg.value !== undefined)\n    if (!providedArg) {\n      throw Error(\n        `must provide at least one of the following arguments: ${args\n          .map((arg) => arg.name)\n          .join(', ')}`\n      )\n    }\n  }\n}\n\nexport const validateArgument = ({\n  name,\n  value,\n  required,\n  types,\n}: IArgToValidate &\n  AtLeastOne<{\n    types?: string[]\n    required?: boolean\n  }>): void => {\n  /* fast-fail if required args are not provided*/\n  if (!name) {\n    throw Error(`error validating argument, 'name' arg is required`)\n  }\n  if (!required && !types) {\n    throw Error(\n      `error validating argument ${name}, either 'required' or 'types' args are required`\n    )\n  }\n  if (getTypeof(types) !== 'array') {\n    throw Error(\n      `error validating argument ${name}, 'types' must be an array of strings`\n    )\n  }\n\n  const typeofValue = getTypeof(value)\n\n  /* ex: if types = ['string', 'number'] then you'll get '<string | number>' */\n  const joinedTypes = types ? `<${types.join(' | ')}>` : ''\n\n  /* common error message parts */\n  const errorPrepend = `error validating argument, \"${name}\"`\n  const errorAppend = `received value: ${value} - of type: <${typeofValue}>`\n\n  /* argument validation logic */\n  if (required && !types) {\n    if (!value) {\n      throw Error(`${errorPrepend} is required; ${errorAppend}`)\n    }\n  }\n\n  if (types && !required) {\n    /* \n      if value is not defined and is not required then there should be no need to validate the type and throw error\n    */\n    if (value && !types.includes(typeofValue)) {\n      throw Error(\n        `${errorPrepend} must be of type(s) ${joinedTypes}, ${errorAppend}`\n      )\n    }\n  }\n\n  if (required && types) {\n    if (!value || !types.includes(typeofValue)) {\n      throw Error(\n        `${errorPrepend} is required and must be of type(s) ${joinedTypes}, ${errorAppend}`\n      )\n    }\n  }\n\n  return\n}\n","export const NHTSA_BASE_URL = 'https://vpic.nhtsa.dot.gov/api/vehicles'\nexport const NHTSA_RESPONSE_FORMAT = 'json'\n","/**\n * @module utils/getTypeof\n * @category Utils\n */\n\n/**\n * Gets type of `value` using `Object.prototype.toString.call(value)`.\n *\n * Why? Because `typeof` is not reliable for all types of values.\n *\n * Object.prototype.toString gives more accurate results in the case someone has used an object wrapper\n * for primitive data types such as `new Number()` or `new String()`.\n *\n * @param {any} value - Any kind of value (string, object, array, function, etc).\n *\n * @returns {string} - Type of value, normalized to a lowercase string.\n */\nexport const getTypeof = (value: unknown): string => {\n  const toString: string = Object.prototype.toString\n    .call(value)\n    .toLowerCase() /* ex: => '[object string]' or '[object array], etc. */\n  return toString.slice(8, toString.length - 1)\n}\n","import { NHTSA_RESPONSE_FORMAT } from '../constants'\nimport { getTypeof } from './getTypeof'\n\n/**\n * @module utils/createQueryString\n * @category Internal Utility Functions\n */\n\n/**\n * Utility function to generate a query string conforming to URI standards for use in API URL strings.\n *\n * The function takes an object of search parameters and returns a query string.\n * The paramater { format: 'json' } is hardcoded and cannot be overridden, no support for CSV or XML formats.\n * The function ignores any parameters that are not strings or numbers, and also ignores empty strings or falsy values by default.\n * If `allowEmptyStringValues` option is set to `true`, the function will include empty string values in the returned query string.\n * The function only allows characters a-z, 0-9, and ?,&,=,% in valid URI strings\n *   and will throw an error if invalid characters are found in the search parameters.\n *\n * @param {QueryStringParameters} params - An object of search parameters to be converted to a query string, will be ignored if not an object.\n * @param {boolean} [allowEmptyStringValues=false] - Set to `true` to include empty string values in the returned query string.\n * @returns {string} - A query string of search parameters for use in a final fetch URL.\n * @throws {Error} - If any invalid characters are found in the search parameters.\n *\n * @requires module:utils/getTypeof\n * @requires module:constants/NHTSA_RESPONSE_FORMAT\n *\n * @example\n * // use default params\n * const qs = await createQueryString()\n * const qs2 = await createQueryString({})\n * console.log(qs)\n * // Output: \"?format=json\"\n * console.log(qs2)\n * // Output: \"?format=json\"\n *\n * @example\n * // basic usage\n * const qs = await createQueryString({ modelYear: 2019 })\n * console.log(qs)\n * // Output: \"?modelYear=2019&format=json\"\n *\n * @example\n * // URI encodes string with spaces\n * const qs = await createQueryString({\n *   whatever: 'some value',\n *   modelYear: 2006,\n *   page: \"2\",\n * })\n * console.log(qs)\n * // Output: \"?whatever=some%20value&modelYear=2006&page=2&format=json\"\n *\n * @example\n * // uses empty string values with allowEmptyStringValues = true\n * const qs = await createQueryString({\n *   year: 2016,\n *   vehicleType: '',\n *   make: 'Audi',\n * }, true)\n * console.log(qs)\n * // Output: \"?year=2016&vehicleType=&make=Audi&format=json\"\n *\n */\nexport const createQueryString = (\n  params?: QueryStringParameters,\n  allowEmptyStringValues = false\n): string => {\n  /* Static (default) params are 'format=json', this package does not support CSV or XML formats */\n  const staticParams = { format: NHTSA_RESPONSE_FORMAT }\n\n  /* Merge default params with user params, override with static params, ignore params if not an object */\n  const _params =\n    getTypeof(params) === 'object'\n      ? { ...params, ...staticParams }\n      : staticParams\n\n  /* Create query string  */\n  const queryString =\n    '?' +\n    Object.entries(_params)\n      .map(([key, value], index, array) => {\n        const typeofValue = getTypeof(value)\n\n        /* Skip invalid values */\n        if (typeofValue !== 'string' && typeofValue !== 'number') {\n          return ''\n        }\n\n        /* Convert number values to string */\n        if (typeofValue === 'number') {\n          value = value.toString()\n        }\n\n        /* Skip empty values unless allowEmptyStringValues is true, convert [key]:value to key=value, append '&' if not last param */\n        return value.length || (allowEmptyStringValues && value === '')\n          ? `${key}=${value}${index < array.length - 1 ? '&' : ''}`\n          : ''\n      })\n      .join('')\n\n  /* Perform URI encoding and return the completed string after checking URI validity */\n  return validateURI(queryString)\n}\n\n/**\n * Ensures there are no invalid characters in a URI query string.\n * Only characters a-z, 0-9, and ?,&,=,% are allowed.\n * @param {string} string - The URI query string to validate\n * @returns {string} - The validated URI query string\n * @throws {Error} - If invalid characters are found in the URI query string\n */\n\nexport const validateURI = (value: string): string => {\n  value = encodeURI(value)\n  const invalidCharacters = /[^0-9A-Z?&=%]/gi\n  if (invalidCharacters.test(value)) {\n    throw Error(\n      'Invalid characters found in query string. Only characters a-z, 0-9, and ?,&,=,% are allowed.'\n    )\n  }\n  return value\n}\n\n/**\n * Object containing Key:Value pairs to build the URL query string with.\n * @typedef {Object.<string, number>} QueryStringParameters\n *\n * @example\n * {\n * modelYear: 2009,\n * whatever: 'something'\n * }\n *\n */\nexport type QueryStringParameters = {\n  [propName: string]: string | number | undefined\n}\n","// export const errorHandler = (error: string | Error | TypeError | unknown) => {\n//   if (error instanceof Error || error instanceof TypeError) {\n//     return error.message && error.stack ? error.stack : ''\n//   }\n//   if (typeof error === 'string') {\n//     return error\n//   }\n//   return 'An unknown error occurred'\n// }\n\nimport { getTypeof } from '.'\n\nexport const isError = (error: unknown): boolean => {\n  return getTypeof(error) === 'error'\n}\n\nexport const handleError = (\n  error: Error | TypeError | string | unknown\n): Error => {\n  let message: string\n  let stack: string | undefined\n\n  if (isError(error)) {\n    message = (error as Error).message\n    stack = (error as Error).stack\n  } else if (getTypeof(error) === 'string') {\n    message = error as string\n  } else {\n    message = 'an unknown error occurred.'\n  }\n\n  const modifiedError = new Error(message)\n  modifiedError.stack = stack ? stack : 'unknown stack'\n\n  return modifiedError\n}\n\nexport const rejectWithError = async (error: unknown): Promise<never> => {\n  if (!isError(error) || !(error as Error).message || !(error as Error).stack) {\n    error = handleError(error)\n  }\n  return Promise.reject(error)\n}\n","/**\n * @module utils/isValidVin\n * @category Utils\n */\n\n/*\n * There will need to be some way to translate vin digits that are alphabetic\n * into their number value in the VIN algorithm transliteration table.\n * Later, during the creation of the checksum variable, those digits will be\n * multiplied against their corresponding weight (by index) in the WEIGHTS_ARRAY.\n * This transliteration table is a key part of the VIN validation algorithm.\n */\nconst TRANSLITERATION_TABLE: Record<string, number> = {\n  A: 1,\n  B: 2,\n  C: 3,\n  D: 4,\n  E: 5,\n  F: 6,\n  G: 7,\n  H: 8,\n  J: 1,\n  K: 2,\n  L: 3,\n  M: 4,\n  N: 5,\n  P: 7,\n  R: 9,\n  S: 2,\n  T: 3,\n  U: 4,\n  V: 5,\n  W: 6,\n  X: 7,\n  Y: 8,\n  Z: 9,\n}\n\n/*\n * Later, during the creation of the 'checksum' variable, these weights will be\n * multiplied by the value of their mirrored index vin digits.\n * The array index of each weight corresponds to the same index of each\n * digit in the 'vin'.\n */\nconst WEIGHTS_ARRAY: number[] = [\n  8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2,\n]\n\n/**\n * Provides **offline** validation of Vehicle Identification Numbers (VINs) using the\n * [VIN Check Algorithm](https://en.wikibooks.org/wiki/Vehicle_Identification_Numbers_(VIN_codes)/Check_digit).\n *\n * @param {string} vin - Vehicle Identification Number.\n * @returns {boolean} True for a valid VIN, false for an invalid VIN.\n *\n * @example <caption>When loaded from the browser via html script tags</caption>\n * // <script type=\"text/javascript\" src=\"https://www.npmjs.com/package/@shaggytools/nhtsa-api-wrapper\"></script>\n * const isValid = NHTSA.isValidVin('3VWD07AJ5EM388202')\n * console.log(isValid) // true\n *\n * @example <caption>When loaded as a module</caption>\n * import { isValidVin } from '@shaggytools/nhtsa-api-wrapper'\n * const isValid = isValidVin('3VWD07AJ5EM388202')\n * console.log(isValid) // true\n *\n */\nexport function isValidVin(vin: string): boolean {\n  /* A valid VIN must be a string and is always exactly 17 digits */\n  if (typeof vin !== 'string' || vin.length != 17) {\n    return false\n  }\n\n  /* Normalize the vin to all uppercase letters */\n  vin = vin.toUpperCase()\n\n  /* split the vin digits into an array */\n  const vinArray: string[] = vin.split('')\n\n  /* checkDigit will be tested against the checkSum later */\n  const checkDigit: string = vinArray[8]\n\n  /*\n   * In a valid VIN, the checkDigit can either be:\n   * a number, 0-9 inclusive OR the character 'X'\n   */\n  if (isNaN(parseInt(checkDigit)) && checkDigit !== 'X') {\n    return false\n  }\n\n  /*\n   * The checkValue must be a digit and 'X' is the only valid alphabetic check value.\n   * As per the algorithm, a checkDigit of 'X' is equal to a checkValue of `10` and needs\n   * to be converted as such.\n   */\n  const checkValue: number = checkDigit === 'X' ? 10 : parseInt(checkDigit)\n\n  /*\n   * Maps the vinArray and converts any values (digits) that are alphabetic,\n   * into numbers, using the TRANSLITERATION_TABLE.\n   * Then these numbers are multiplied against their corresponding weight\n   * in the WEIGHTS_ARRAY, matched by index position.\n   * All 17 of those digitValues are then added together and divided by 11.\n   * The remainder, or % modulo, of that division will be the final 'checksum'.\n   */\n  const checksum: number =\n    vinArray\n      .map((digit: string, index: number) => {\n        let digitValue: number\n        /* Use the transliteration table to convert any Not a Number(NaN) values to numbers */\n        isNaN(parseInt(digit))\n          ? (digitValue = TRANSLITERATION_TABLE[digit])\n          : (digitValue = parseInt(digit))\n\n        /* Convert the digitValue to a weighted number corresponding to it's position, by index, in the weightsArray. */\n        const weight: number = WEIGHTS_ARRAY[index]\n\n        /* The final step for each digit is to multiply the digit by it's corresponding weight */\n        return digitValue * weight\n      })\n      /* Finally, get the sum of all digits and divide by 11, the remainder of that operation is the checksum */\n      .reduce((acc, currValue) => acc + currValue, 0) % 11\n\n  /*\n   * The checksum is compared against the checkValue we set earlier (the 9th digit of the VIN)\n   * As per the algorithm, if they are equal to each other, then the VIN must be valid and\n   * we return true, otherwise the VIN is invalid and we return false.\n   */\n  return checksum === checkValue\n}\n","import { NHTSA_RESPONSE_FORMAT } from '../constants'\nimport { getTypeof } from './getTypeof'\n\n/**\n * @module utils/makeQueryString\n * @category Utils\n */\n\n/**\n * Utility method to generate a query string compatible with the NHSTA API, for use in an API URL string.\n *\n * @async\n *\n * @param {object} params - Object of Type [QueryStringParameters](module-utils_makeQueryString.html#.QueryStringParameters).\n * @param {boolean} [allowEmptyStringValues=false] - Set to `true` to add empty parameter values to the returned query string.\n * - Given params of `{ paramName: \"\" }` , setting this to true will use 'paramName=' in the final query string.\n * - GetCanadianVehicleSpecifications is the only API Action that requires this functionality.\n *\n * @returns {Promise<string>} A query string of search parameters for use in a final Fetch.get URL.\n *\n * @example <caption>When loaded as a module</caption>\n * import { makeQueryString } from '@shaggytools/nhtsa-api-wrapper'\n * const qs = await makeQueryString({ modelYear: 2010 }).catch(error => error)\n * console.log(qs) // \"?modelYear=2010\"\n *\n * @example <caption>Single Param:</caption>\n * const qs = await makeQueryString({\n *   modelYear: 2019\n * }).catch(error => error)\n * console.log(qs) // \"?modelYear=2019&format=json\"\n *\n * @example <caption>Multiple Params:</caption>\n * const qs = await makeQueryString({\n *   whatever: 'some value',\n *   modelYear: 2006,\n *   page: \"2\"\n * }).catch(error => error)\n *\n * console.log(qs) // \"?whatever=some%20value&modelYear=2006&page=2&format=json\"\n *\n * @example <caption>Empty Params Object:</caption>\n * const qs = await makeQueryString({}).catch(error => error)\n *\n * console.log(qs) // \"?format=json\"\n *\n * @example <caption>Using allowEmptyStringValues option:</caption>\n * const qs = await makeQueryString({\n *   year: 2016,\n *   vehicleType: '',\n *   make: 'Audi'\n * }, true).catch(error => error)\n *\n * console.log(qs) // \"?year=2016&vehicleType=&make=Audi&format=json\"\n *\n */\nexport function makeQueryString(\n  params?: QueryStringParameters,\n  allowEmptyStringValues = false\n): Promise<string> {\n  /*\n   * Make sure we're always using 'format=json' in the url Query parameters\n   * If the user provides a 'format' key in the params, during class instantiation we want to override it to 'json'\n   * This package may provide support for the other formats (CSV and XML) if requested.\n   */\n  const defaultParams = { format: NHTSA_RESPONSE_FORMAT }\n  let _params = {}\n  if (!params || getTypeof(params) !== 'object') {\n    _params = { ...defaultParams }\n  } else {\n    _params = { ...params, ...defaultParams }\n  }\n\n  /* Setup QueryString for Array mapping */\n  const entries = Object.entries(_params)\n  const paramsLength = entries.length\n\n  /* Return an empty string if params are an empty object */\n  if (paramsLength < 1) return Promise.resolve('')\n\n  /* Used to check if we've already prepended a valid query param */\n  let isPrepended = false\n\n  /* Map [key]:value entries to \"key=value\" strings in an array */\n  const queryStringArray = entries.map(([key, value], index) => {\n    let prepend = ''\n    let append = ''\n\n    const typeofValue = getTypeof(value)\n\n    /* Convert any number values to a string */\n    if (value && typeofValue === 'number') {\n      value = value.toString()\n    }\n\n    /* Skips any invalid values, only string and number value types are valid */\n    if (\n      (value || allowEmptyStringValues) &&\n      (typeofValue === 'string' || typeofValue === 'number')\n    ) {\n      /* if this is the first param we need to prepend the '?' char */\n      if (!isPrepended) {\n        prepend = '?'\n        isPrepended = true\n      }\n      /* if there is another param coming after this one we need to append the '&' char */\n      if (index < paramsLength - 1) {\n        append = '&'\n      }\n\n      /* Add the completed partial query string to queryStringArray */\n      return `${prepend}${key}=${value}${append}`\n    }\n    return\n  })\n\n  /* Join and return the completed query string after URI encoding */\n  return Promise.resolve(encodeURI(queryStringArray.join('')))\n}\n\n/**\n * Object containing Key:Value pairs to build the URL query string with.\n * - Parameter values may be either strings or numbers.\n *\n * @memberof module:utils/makeQueryString\n * @alias QueryStringParameters\n * @example\n * {\n * modelYear: 2009,\n * whatever: 'something'\n * }\n *\n */\ntype QueryStringParameters = {\n  [propName: string]: string | number | undefined\n}\n","import type { NhtsaResponse } from '../api/types'\nimport { rejectWithError } from '.'\n\nexport const useFetch = () => {\n  const get = async <T>(\n    url: string,\n    options: RequestInit = {}\n  ): Promise<NhtsaResponse<T>> => {\n    const nhtsaResponse: NhtsaResponse<T> = await fetch(url, options)\n      .then(async (response) => {\n        if (!response.ok) {\n          throw Error(response.statusText)\n        }\n\n        const jsonTypes = ['application/json', 'text/json']\n        const contentType = response.headers.get('content-type')\n        const isJson = jsonTypes.some((type) => contentType?.includes(type))\n\n        if (!isJson) {\n          throw Error(\n            `response is not in JSON format; got content-type: ${contentType}`\n          )\n        }\n\n        const data: NhtsaResponse<T> = await response.json()\n\n        if (!data) {\n          throw Error(\n            `response is empty; got content-type: ${contentType}, responseStatusText: ${response.statusText}}`\n          )\n        }\n\n        return data\n      })\n      .catch((error: Error) => {\n        error.message = `error fetching data; ${error.message}`\n        return rejectWithError(error)\n      })\n\n    /* Return the completed ApiResponse */\n    return nhtsaResponse\n  }\n\n  return {\n    get,\n  }\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  catchInvalidArguments,\n  createQueryString,\n  getTypeof,\n  handleError,\n  isError,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse, IArgToValidate } from '../../types'\n\n/**\n * DecodeVin will decode the VIN and the decoded output will be made available in the format of Key-value pairs.\n *\n * - In the returned 'Results` object:\n *   - The IDs (VariableID and ValueID) represent the unique ID associated with the Variable/Value\n *   - In case of text variables, the ValueID is not applicable\n *\n * - Providing `params.modelYear` allows for the decoding to specifically be done in the current,\n *   or older (pre-1980), model year ranges\n *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding\n * - This endpoint also supports partial VIN decoding (VINs that are less than 17 characters)\n *   - In this case, the VIN will be decoded partially with the available characters\n *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters\n *   - The 9th digit is not necessary\n *   - Ex: 5UXWX7C5*BA\n *\n * @async\n * @param {string} vin - Vehicle Identification Number (full or partial)\n * @param {Object} [params] - Query Search Parameters to append to the URL\n * @param {(number|string)} [params.modelYear] - Optional Model Year search parameter\n * @returns {(Promise<NhtsaResponse<DecodeVinResults>>)} - Api Response object\n */\n\nexport const DecodeVin = async (\n  vin: string,\n  params?: {\n    modelYear?: number | string\n  }\n): Promise<NhtsaResponse<DecodeVinResults>> => {\n  const action = 'DecodeVin'\n  const modelYear = params?.modelYear\n\n  try {\n    const args: IArgToValidate[] = [\n      { name: 'vin', required: true, types: ['string'], value: vin },\n      { name: 'params', types: ['object'], value: params },\n      {\n        name: 'params.modelYear',\n        types: ['number', 'string'],\n        value: modelYear,\n      },\n    ]\n\n    catchInvalidArguments({ args })\n\n    const queryString = createQueryString(params)\n    const url = `${NHTSA_BASE_URL}/${action}/${vin}${queryString}`\n\n    return await useFetch()\n      .get<DecodeVinResults>(url)\n      .then((response) => response)\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for DecodeVin endpoint\n *\n * @alias DecodeVinResults\n */\nexport type DecodeVinResults = {\n  Value: string | null\n  ValueId: string | null\n  Variable: string\n  VariableId: number\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * DecodeVinExtended is exactly like the DecodeVin endpoint but provides additional information on variables\n * related to other NHTSA programs like\n * [NCSA](https://www.nhtsa.gov/research-data/national-center-statistics-and-analysis-ncsa), etc.\n * - This will decode the VIN and the decoded output will be made available in the format of Key-value pairs\n * - In the returned 'Results` object:\n *   - The IDs (VariableID and ValueID) represent the unique ID associated with the Variable/Value\n *   - In case of text variables, the ValueID is not applicable\n * - Providing `params.modelYear` allows for the decoding to specifically be done in the current,\n *   or older (pre-1980), model year ranges\n *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding\n * - This endpoint also supports partial VIN decoding (VINs that are less than 17 characters)\n *   - In this case, the VIN will be decoded partially with the available characters\n *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters\n *   - The 9th digit is not necessary\n *   - Ex: 5UXWX7C5*BA\n *\n * @async\n * @param {string} vin - Vehicle Identification Number (full or partial)\n * @param {(number|string)} [params.modelYear] - Optional Model Year search parameter\n * @returns {(Promise<NhtsaResponse<DecodeVinExtendedResults>>)} - Api Response object\n */\n\nexport const DecodeVinExtended = async (\n  vin: string,\n  params?: {\n    modelYear?: number\n  }\n): Promise<NhtsaResponse<DecodeVinExtendedResults>> => {\n  const action = 'DecodeVinExtended'\n\n  /* Runtime type guards against user provided args*/\n  const typeofVin = getTypeof(vin)\n  if (!vin || typeofVin !== 'string') {\n    return rejectWithError(\n      `${action}, \"vin\" argument is required and must be of type string, got: <${typeofVin}> ${vin}`\n    )\n  }\n\n  const typeofParams = getTypeof(params)\n  if (params && typeofParams !== 'object') {\n    return rejectWithError(\n      `${action}, \"params\" argument must be of type object, got: <${typeofParams}> ${params}`\n    )\n  }\n\n  const typeofModelYear = getTypeof(params?.modelYear)\n  if (params?.modelYear && typeofModelYear !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"params.modelYear\" must be of type number or string, got: <${typeofModelYear}> ${params.modelYear}`\n    )\n  }\n\n  /* Build the query string to be appended to the URL*/\n  const queryString = await makeQueryString(params).catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${vin}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<DecodeVinExtendedResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for DecodeVinExtended endpoint\n *\n * @alias DecodeVinExtendedResults\n */\nexport type DecodeVinExtendedResults = {\n  Value: string | null\n  ValueId: string | null\n  Variable: string\n  VariableId: number\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * DecodeVinValues will decode the VIN with the Results returned in a _flat file_ format.\n * - The results will be made available in a flat file format of a single object containing\n *   'key<string>: value<string>' results\n * - Providing params.modelYear allows for the decoding to specifically be done in the current,\n *   or older (pre-1980), model year ranges\n *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding\n * - This endpoint also supports partial VIN decoding (VINs that are less than 17 characters)\n *   - In this case, the VIN will be decoded partially with the available characters\n *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters\n *   - The 9th digit is not necessary\n *   - Ex: 5UXWX7C5*BA\n *\n * @async\n * @param {string} vin - Vehicle Identification Number (full or partial)\n * @param {(number|string)} [params.modelYear] - Optional Model Year search parameter\n * @returns {(Promise<NhtsaResponse<DecodeVinValuesResults>>)} Api Response object\n */\n\nexport const DecodeVinValues = async (\n  vin: string,\n  params?: {\n    modelYear?: number\n  }\n): Promise<NhtsaResponse<DecodeVinValuesResults>> => {\n  const action = 'DecodeVinValues'\n\n  /* Runtime type guards against user provided args*/\n  const typeofVin = getTypeof(vin)\n  if (!vin || typeofVin !== 'string') {\n    return rejectWithError(\n      `${action}, \"vin\" argument is required and must be of type string, got: <${typeofVin}> ${vin}`\n    )\n  }\n\n  const typeofParams = getTypeof(params)\n  if (params && typeofParams !== 'object') {\n    return rejectWithError(\n      `${action}, \"params\" argument must be of type object, got: <${typeofParams}> ${params}`\n    )\n  }\n\n  const typeofModelYear = getTypeof(params?.modelYear)\n  if (params?.modelYear && typeofModelYear !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"params.modelYear\" must be of type number or string, got: <${typeofModelYear}> ${params.modelYear}`\n    )\n  }\n\n  /* Build the query string to be appended to the URL*/\n  const queryString = await makeQueryString(params).catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${vin}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<DecodeVinValuesResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for DecodeVinValues endpoint\n *\n * @alias DecodeVinValuesResults\n */\nexport type DecodeVinValuesResults = {\n  /** Flat file format, single object containing keys and values of type string */\n  ABS: string\n  ActiveSafetySysNote: string\n  AdaptiveCruiseControl: string\n  AdaptiveDrivingBeam: string\n  AdaptiveHeadlights: string\n  AdditionalErrorText: string\n  AirBagLocCurtain: string\n  AirBagLocFront: string\n  AirBagLocKnee: string\n  AirBagLocSeatCushion: string\n  AirBagLocSide: string\n  AutoReverseSystem: string\n  AutomaticPedestrianAlertingSound: string\n  AxleConfiguration: string\n  Axles: string\n  BasePrice: string\n  BatteryA: string\n  BatteryA_to: string\n  BatteryCells: string\n  BatteryInfo: string\n  BatteryKWh: string\n  BatteryKWh_to: string\n  BatteryModules: string\n  BatteryPacks: string\n  BatteryType: string\n  BatteryV: string\n  BatteryV_to: string\n  BedLengthIN: string\n  BlindSpotIntervention: string\n  BlindSpotMon: string\n  BodyCabType: string\n  BodyClass: string\n  BrakeSystemDesc: string\n  BrakeSystemType: string\n  BusFloorConfigType: string\n  BusLength: string\n  BusType: string\n  CAN_AACN: string\n  CIB: string\n  CashForClunkers: string\n  ChargerLevel: string\n  ChargerPowerKW: string\n  CoolingType: string\n  CurbWeightLB: string\n  CustomMotorcycleType: string\n  DaytimeRunningLight: string\n  DestinationMarket: string\n  DisplacementCC: string\n  DisplacementCI: string\n  DisplacementL: string\n  Doors: string\n  DriveType: string\n  DriverAssist: string\n  DynamicBrakeSupport: string\n  EDR: string\n  ESC: string\n  EVDriveUnit: string\n  ElectrificationLevel: string\n  EngineConfiguration: string\n  EngineCycles: string\n  EngineCylinders: string\n  EngineHP: string\n  EngineHP_to: string\n  EngineKW: string\n  EngineManufacturer: string\n  EngineModel: string\n  EntertainmentSystem: string\n  ErrorCode: string\n  ErrorText: string\n  ForwardCollisionWarning: string\n  FuelInjectionType: string\n  FuelTypePrimary: string\n  FuelTypeSecondary: string\n  GCWR: string\n  GCWR_to: string\n  GVWR: string\n  GVWR_to: string\n  KeylessIgnition: string\n  LaneCenteringAssistance: string\n  LaneDepartureWarning: string\n  LaneKeepSystem: string\n  LowerBeamHeadlampLightSource: string\n  Make: string\n  MakeID: string\n  Manufacturer: string\n  ManufacturerId: string\n  Model: string\n  ModelID: string\n  ModelYear: string\n  MotorcycleChassisType: string\n  MotorcycleSuspensionType: string\n  NCSABodyType: string\n  NCSAMake: string\n  NCSAMapExcApprovedBy: string\n  NCSAMapExcApprovedOn: string\n  NCSAMappingException: string\n  NCSAModel: string\n  NCSANote: string\n  NonLandUse: string\n  Note: string\n  OtherBusInfo: string\n  OtherEngineInfo: string\n  OtherMotorcycleInfo: string\n  OtherRestraintSystemInfo: string\n  OtherTrailerInfo: string\n  ParkAssist: string\n  PedestrianAutomaticEmergencyBraking: string\n  PlantCity: string\n  PlantCompanyName: string\n  PlantCountry: string\n  PlantState: string\n  PossibleValues: string\n  Pretensioner: string\n  RearAutomaticEmergencyBraking: string\n  RearCrossTrafficAlert: string\n  RearVisibilitySystem: string\n  SAEAutomationLevel: string\n  SAEAutomationLevel_to: string\n  SeatBeltsAll: string\n  SeatRows: string\n  Seats: string\n  SemiautomaticHeadlampBeamSwitching: string\n  Series: string\n  Series2: string\n  SteeringLocation: string\n  SuggestedVIN: string\n  TPMS: string\n  TopSpeedMPH: string\n  TrackWidth: string\n  TractionControl: string\n  TrailerBodyType: string\n  TrailerLength: string\n  TrailerType: string\n  TransmissionSpeeds: string\n  TransmissionStyle: string\n  Trim: string\n  Trim2: string\n  Turbo: string\n  VIN: string\n  ValveTrainDesign: string\n  VehicleDescriptor: string\n  VehicleType: string\n  WheelBaseLong: string\n  WheelBaseShort: string\n  WheelBaseType: string\n  WheelSizeFront: string\n  WheelSizeRear: string\n  Wheels: string\n  Windows: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL, NHTSA_RESPONSE_FORMAT } from '../../constants'\n/* Utility Functions */\nimport { getTypeof, rejectWithError, useFetch } from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * DecodeVinValuesBatch decodes a batch of VINs that are submitted in a standardized format (see below) and returns multiple decodes in a flat format.\n *\n * For this particular API you just have to provie a string of VINs `inputString` that are separated by a “;”.\n *\n * You can also indicate the model year prior to the “;” separated by a “,”\n *\n * The `inputString` parameter should be in the following format\n * - no modelYear: `vin;vin;vin`\n * - with modelYear`vin,modelYear;vin,modelYear;vin,modelYear`\n * - mix of with/without modelYear`vin;vin,modelYear`\n * - vin and modelYear are placeholders for real values in these examples\n *\n *  Max 50 VINs per batch\n *\n * @async\n * @param {string} inputString - A string of Vehicle Identification Numbers (full or partial) following the format listed in the description\n * @returns {(Promise<DecodeVINValuesBatchResponse>)} - Api Response object\n */\n\nexport const DecodeVinValuesBatch = async (\n  inputString: string\n): Promise<NhtsaResponse<DecodeVinValuesBatchResults>> => {\n  const action = 'DecodeVinValuesBatch'\n\n  /* Runtime type guards against user provided args*/\n  const typeofInputString = getTypeof(inputString)\n  if (!inputString || typeofInputString !== 'string') {\n    return rejectWithError(\n      `${action}, \"inputString\" argument is required and must be of type string, got: <${typeofInputString}> ${inputString}`\n    )\n  }\n\n  /* Build the final request URL and POST body */\n  const url = `${NHTSA_BASE_URL}/${action}/`\n  const body = encodeURI(`DATA=${inputString}&format=${NHTSA_RESPONSE_FORMAT}`)\n\n  /* Return the result */\n  return await useFetch()\n    .get<DecodeVinValuesBatchResults>(url, {\n      method: 'POST',\n      headers: { 'content-type': 'application/x-www-form-urlencoded' },\n      body,\n    })\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for DecodeVinValuesBatch endpoint\n *\n * @alias DecodeVINValuesBatchResults\n */\nexport type DecodeVinValuesBatchResults = {\n  ABS: string\n  ActiveSafetySysNote: string\n  AdaptiveCruiseControl: string\n  AdaptiveDrivingBeam: string\n  AdaptiveHeadlights: string\n  AdditionalErrorText: string\n  AirBagLocCurtain: string\n  AirBagLocFront: string\n  AirBagLocKnee: string\n  AirBagLocSeatCushion: string\n  AirBagLocSide: string\n  AutoReverseSystem: string\n  AutomaticPedestrianAlertingSound: string\n  AxleConfiguration: string\n  Axles: string\n  BasePrice: string\n  BatteryA: string\n  BatteryA_to: string\n  BatteryCells: string\n  BatteryInfo: string\n  BatteryKWh: string\n  BatteryKWh_to: string\n  BatteryModules: string\n  BatteryPacks: string\n  BatteryType: string\n  BatteryV: string\n  BatteryV_to: string\n  BedLengthIN: string\n  BlindSpotIntervention: string\n  BlindSpotMon: string\n  BodyCabType: string\n  BodyClass: string\n  BrakeSystemDesc: string\n  BrakeSystemType: string\n  BusFloorConfigType: string\n  BusLength: string\n  BusType: string\n  CAN_AACN: string\n  CIB: string\n  CashForClunkers: string\n  ChargerLevel: string\n  ChargerPowerKW: string\n  CoolingType: string\n  CurbWeightLB: string\n  CustomMotorcycleType: string\n  DaytimeRunningLight: string\n  DestinationMarket: string\n  DisplacementCC: string\n  DisplacementCI: string\n  DisplacementL: string\n  Doors: string\n  DriveType: string\n  DriverAssist: string\n  DynamicBrakeSupport: string\n  EDR: string\n  ESC: string\n  EVDriveUnit: string\n  ElectrificationLevel: string\n  EngineConfiguration: string\n  EngineCycles: string\n  EngineCylinders: string\n  EngineHP: string\n  EngineHP_to: string\n  EngineKW: string\n  EngineManufacturer: string\n  EngineModel: string\n  EntertainmentSystem: string\n  ErrorCode: string\n  ErrorText: string\n  ForwardCollisionWarning: string\n  FuelInjectionType: string\n  FuelTypePrimary: string\n  FuelTypeSecondary: string\n  GCWR: string\n  GCWR_to: string\n  GVWR: string\n  GVWR_to: string\n  KeylessIgnition: string\n  LaneCenteringAssistance: string\n  LaneDepartureWarning: string\n  LaneKeepSystem: string\n  LowerBeamHeadlampLightSource: string\n  Make: string\n  MakeID: string\n  Manufacturer: string\n  ManufacturerId: string\n  Model: string\n  ModelID: string\n  ModelYear: string\n  MotorcycleChassisType: string\n  MotorcycleSuspensionType: string\n  NCSABodyType: string\n  NCSAMake: string\n  NCSAMapExcApprovedBy: string\n  NCSAMapExcApprovedOn: string\n  NCSAMappingException: string\n  NCSAModel: string\n  NCSANote: string\n  NonLandUse: string\n  Note: string\n  OtherBusInfo: string\n  OtherEngineInfo: string\n  OtherMotorcycleInfo: string\n  OtherRestraintSystemInfo: string\n  OtherTrailerInfo: string\n  ParkAssist: string\n  PedestrianAutomaticEmergencyBraking: string\n  PlantCity: string\n  PlantCompanyName: string\n  PlantCountry: string\n  PlantState: string\n  PossibleValues: string\n  Pretensioner: string\n  RearAutomaticEmergencyBraking: string\n  RearCrossTrafficAlert: string\n  RearVisibilitySystem: string\n  SAEAutomationLevel: string\n  SAEAutomationLevel_to: string\n  SeatBeltsAll: string\n  SeatRows: string\n  Seats: string\n  SemiautomaticHeadlampBeamSwitching: string\n  Series: string\n  Series2: string\n  SteeringLocation: string\n  SuggestedVIN: string\n  TPMS: string\n  TopSpeedMPH: string\n  TrackWidth: string\n  TractionControl: string\n  TrailerBodyType: string\n  TrailerLength: string\n  TrailerType: string\n  TransmissionSpeeds: string\n  TransmissionStyle: string\n  Trim: string\n  Trim2: string\n  Turbo: string\n  VIN: string\n  ValveTrainDesign: string\n  VehicleDescriptor: string\n  VehicleType: string\n  WheelBaseLong: string\n  WheelBaseShort: string\n  WheelBaseType: string\n  WheelSizeFront: string\n  WheelSizeRear: string\n  Wheels: string\n  Windows: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * DecodeVinValuesExtended is exactly like the DecodeVinValues endpoint (flat format Results) but provides additional information\n * on variables related to other NHTSA programs like\n * [NCSA](https://www.nhtsa.gov/research-data/national-center-statistics-and-analysis-ncsa), etc.\n *\n * The results will be made available in a flat file format of a single object containing 'key<string>: value<string>' results.\n *\n * Providing `params.modelYear` allows for the decoding to specifically be done in the current,\n * or older (pre-1980), model year ranges\n *   - It is recommended to always provide `params.modelYear` if the model year is known at the time of decoding\n *\n * This endpoint also supports partial VIN decoding (VINs that are less than 17 characters).\n *   - In this case, the VIN will be decoded partially with the available characters\n *   - In case of partial VINs, a \"*\" could be used to indicate the unavailable characters\n *   - The 9th digit is not necessary.\n *   - Ex: 5UXWX7C5*BA\n *\n * @async\n * @param {string} vin - Vehicle Identification Number (full or partial)\n * @param {Object} [params] - Query Search Parameters to append to the URL\n * @param {(number|string)} [params.modelYear] - Optional Model Year search parameter\n * @returns {(Promise<NhtsaResponse<DecodeVinExtendedResults>>)} - Api Response object\n */\n\nexport const DecodeVinValuesExtended = async (\n  vin: string,\n  params?: {\n    modelYear?: number\n  }\n): Promise<NhtsaResponse<DecodeVinValuesExtendedResults>> => {\n  const action = 'DecodeVinValuesExtended'\n\n  /* Runtime type guards against user provided args*/\n  const typeofVin = getTypeof(vin)\n  if (!vin || typeofVin !== 'string') {\n    return rejectWithError(\n      `${action}, \"vin\" argument is required and must be of type string, got: <${typeofVin}> ${vin}`\n    )\n  }\n\n  const typeofParams = getTypeof(params)\n  if (params && typeofParams !== 'object') {\n    return rejectWithError(\n      `${action}, \"params\" argument must be of type object, got: <${typeofParams}> ${params}`\n    )\n  }\n\n  const typeofModelYear = getTypeof(params?.modelYear)\n  if (params?.modelYear && typeofModelYear !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"params.modelYear\" must be of type number or string, got: <${typeofModelYear}> ${params.modelYear}`\n    )\n  }\n\n  /* Build the query string to be appended to the URL*/\n  const queryString = await makeQueryString(params).catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${vin}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<DecodeVinValuesExtendedResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for DecodeVinValuesExtended endpoint\n *\n * @alias DecodeVinValuesExtendedResults\n */\nexport type DecodeVinValuesExtendedResults = {\n  Value: string | null\n  ValueId: string | null\n  Variable: string\n  VariableId: number\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * DecodeWMI provides information on the World Manufacturer Identifier for a specific WMI code.\n *\n * - `WMI` may be put in as either 3 characters representing VIN position 1-3 or 6 characters\n *   representing VIN positions 1-3 & 12-14. Examples: \"JTD\" \"1T9131\"\n *\n * @async\n * @param {string} WMI - World Manufacturer Identifier\n * @returns {(Promise<NhtsaResponse<DecodeWMIResults>>)} - Api Response object\n */\n\nexport const DecodeWMI = async (\n  WMI: string\n): Promise<NhtsaResponse<DecodeWMIResults>> => {\n  const action = 'DecodeWMI'\n\n  /* Runtime type guards against user provided args*/\n  const typeofWMI = getTypeof(WMI)\n  if (typeofWMI !== 'string') {\n    return rejectWithError(\n      `${action}, \"WMI\" argument is required and must be of type string, got <${typeofWMI}> ${WMI}`\n    )\n  }\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${WMI}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<DecodeWMIResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for DecodeWMI endpoint\n *\n * @alias DecodeWMIResults\n */\nexport type DecodeWMIResults = {\n  CommonName: string\n  CreatedOn: string\n  DateAvailableToPublic: string\n  Make: string\n  ManufacturerName: string\n  ParentCompanyName: string\n  URL: string\n  UpdatedOn: string\n  VehicleType: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport { makeQueryString, rejectWithError, useFetch } from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetAllMakes endpoint provides a list of all the Makes available in the vPIC Dataset.\n * - FYI there are over 10,000 registered makes in the database!\n *\n * @async\n * @returns {(Promise<NhtsaResponse<GetAllMakesResults>>)} - Api Response object\n */\n\nexport const GetAllMakes = async (): Promise<\n  NhtsaResponse<GetAllMakesResults>\n> => {\n  const action = 'GetAllMakes'\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetAllMakesResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetAllMakes endpoint\n *\n * @alias GetAllMakesResults\n */\nexport type GetAllMakesResults = {\n  Make_ID: number\n  Make_Name: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetAllManufacturers provides a list of all the Manufacturers available in vPIC Dataset.\n *\n * - `params.manufacturerType` allows the user to filter the list based on manufacturer type\n *   ('Incomplete Vehicles', 'Completed Vehicle Manufacturer', 'Incomplete Vehicle Manufacturer',\n *   'Intermediate Manufacturer', 'Final-Stage Manufacturer', 'Alterer', or any partial match of those strings)\n * - You can get a list of all manufacturer types via `GetVehicleVariableValuesList` endpoint\n *\n * Results are provided in pages of 100 items.\n * - Provide `params.page` to specify (n)th page of results\n *\n * @async\n * @param {Object} [params] - Query Search Parameters to append to the URL\n * @param {string} [params.manufacturerType] - See method description\n * @param {(number|string)} [params.page] - Specify the page number (results returned 100 at a time)\n * @returns {(Promise<NhtsaResponse<GetAllManufacturersResults>>)} - Api Response object\n */\n\nexport const GetAllManufacturers = async (params?: {\n  manufacturerType?: string\n  page?: number | string\n}): Promise<NhtsaResponse<GetAllManufacturersResults>> => {\n  const action = 'GetAllManufacturers'\n\n  /* Runtime type guards against user provided args*/\n  const typeofParams = getTypeof(params)\n  if (params && typeofParams !== 'object') {\n    return rejectWithError(\n      `${action}, \"params\" argument must be of type object, got: <${typeofParams}> ${params}`\n    )\n  }\n\n  const typeofManufacturerType = getTypeof(params?.manufacturerType)\n  if (params?.manufacturerType && typeofManufacturerType !== 'string') {\n    return rejectWithError(\n      `${action}, params.manufacturerType\" argument must be of type string, got: <${typeofManufacturerType}> ${params.manufacturerType}`\n    )\n  }\n\n  const typeofPage = getTypeof(params?.page)\n  if (params?.page && typeofPage !== 'number | string') {\n    return rejectWithError(\n      `${action}, \"params.page\" argument must be of type number or string, got: <${typeofPage}> ${params.page}`\n    )\n  }\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString(params).catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetAllManufacturersResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetAllManufacturers endpoint\n *\n * @alias GetAllManufacturersResults\n */\nexport type GetAllManufacturersResults = {\n  Country: string\n  Mfr_CommonName: string\n  Mfr_ID: number\n  Mfr_Name: string\n  VehicleTypes: Array<{ IsPrimary?: boolean; Name?: string }>\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * The Canadian Vehicle Specifications (CVS) consists of a database of original vehicle dimensions,\n * used primarily in collision investigation and reconstruction, combined with a search engine.\n *\n * The database is compiled annually by the Collision Investigation and Research Division of Transport Canada.\n * Visit official [Canadian Vehicle Specifications](http://www.carsp.ca/research/resources/safety-sources/canadian-vehicle-specifications/)\n * page for more details.\n *\n * GetCanadianVehicleSpecifications will return a 404 html error if any of the query parameters in params\n * are missing from the query string. This is the only API action with this behaviour. Therefore,\n * parameters are inserted into the query string with empty string values if that particular param value is not provided by the user.\n *\n * @async\n * @param {Object} params - Query Search Parameters to append to the URL\n * @param {(number|string)} params.year - Model year of the vehicle (required) - year >= 1971\n * @param {string} [params.make] - Vehicle's make, like \"Honda\", \"Toyota\", etc...\n * @param {string} [params.model] - Vehicle's model, like \"Pilot\", \"Focus\". Can also include some other elements like Body Type, Engine Model/size, etc...\n * @param {string} [params.units] - \"Metric\" (default), or \"US\" for United States customary units\n * @returns {(Promise<NhtsaResponse<GetCanadianVehicleSpecificationsResults>>)} - Api Response object\n */\n\nexport const GetCanadianVehicleSpecifications = async (params: {\n  year: number | string\n  make?: string\n  model?: string\n  units?: string\n}): Promise<NhtsaResponse<GetCanadianVehicleSpecificationsResults>> => {\n  const action = 'GetCanadianVehicleSpecifications'\n\n  /* Runtime type guards against user provided args*/\n  const typeofParams = getTypeof(params)\n  if (!params || (params && typeofParams !== 'object')) {\n    return rejectWithError(\n      `${action}, \"params\" argument is required and must be of type object, got: <${typeofParams}> ${params}`\n    )\n  }\n\n  const typeofYear = getTypeof(params?.year)\n  if (!params?.year || typeofYear !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"params.year\" argument is required and must be of type number or string, got: <${typeofYear}> ${params.year}`\n    )\n  }\n\n  const typeofMake = getTypeof(params.make)\n  if (params?.make && typeofMake !== 'string') {\n    return rejectWithError(\n      `${action}, \"params.make\" argument must be of type string, got: <${typeofMake}> ${params.make}`\n    )\n  }\n\n  const typeofModel = getTypeof(params.model)\n  if (params.model && typeofModel !== 'string') {\n    return rejectWithError(\n      `${action}, \"params.model\" argument must be of type string, got: <${typeofModel}> ${params.model}`\n    )\n  }\n\n  const typeofUnits = getTypeof(params.units)\n  if (params.units && typeofUnits !== 'string') {\n    return rejectWithError(\n      `${action}, \"params.units\" argument must be of type string, got: <${typeofUnits}> ${params.units}`\n    )\n  }\n\n  /* Set default query parameters to empty strings if not provided by the user */\n  const make = params.make || ''\n  const model = params.model || ''\n  const units = params.units || ''\n\n  const _params = {\n    year: params.year,\n    make,\n    model,\n    units,\n  }\n\n  /*\n   * Build the query string to be appended to the URL\n   *\n   * Additionally, sets the allowEmptyStringValues option (2nd argument) to true because\n   * this API action will return a 404 error if any of the query parameters are missing from the query string.\n   * Empty values are allowed so empty strings are inserted as default values unless provided by user\n   * This is the only API action with this behaviour (\"year\" is the only param the user must provide).\n   */\n  const queryString = await makeQueryString(_params, true).catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${queryString}`\n\n  /* Return the result */\n  const response = await useFetch()\n    .get<GetCanadianVehicleSpecificationsResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n\n  return response\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetCanadianVehicleSpecifications endpoint\n *\n * @alias GetCanadianVehicleSpecificationsResults\n */\nexport type GetCanadianVehicleSpecificationsResults = {\n  Specs: Array<{\n    Name:\n      | 'Make'\n      | 'Model'\n      | 'MYR'\n      | 'OL'\n      | 'OW'\n      | 'OH'\n      | 'WB'\n      | 'CW'\n      | 'A'\n      | 'B'\n      | 'C'\n      | 'D'\n      | 'E'\n      | 'F'\n      | 'G'\n      | 'TWF'\n      | 'TWR'\n      | 'WD'\n    Value: string\n  }>\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetEquipmentPlantCodes returns assigned Equipment Plant Codes. Can be filtered by Year, Equipment Type and Report Type.\n *\n * ALL parameters are required and endpoint will return 404 if there are any missing keys and/or values\n *\n * `params.year`:\n *  - year >= 2016\n *  - NOTE: It seems API will still respond with years < 2016 but developers state only years >= 2016 are supported\n * `params.equipmentType`:\n *  - 1 (Tires)\n *  - 3 (Brake Hoses)\n *  - 13 (Glazing)\n *  - 16 (Retread)\n * `params.reportType`:\n *  - 'New' (The Equipment Plant Code was assigned during the selected year)\n *  - 'Updated' (The Equipment Plant data was modified during the selected year)\n *  - 'Closed' (The Equipment Plant is no longer Active)\n *  - 'All' (All Equipment Plant Codes regardless of year, including their status (active or closed))\n *\n * @async\n * @param {Object} params - Query Search Parameters to append to the URL\n * @param {(number|string)} params.year - Year >= 2016 (required)\n * @param {(number|string)} params.equipmentType - Number equal to 1, 3, 13, or 16 (required)\n * @param {string} params.reportType - 'New', 'Updated', 'Closed', or 'All' (required)\n * @returns {(Promise<NhtsaResponse<GetEquipmentPlantCodesResults>>)} - Api Response object (required)\n */\n\nexport const GetEquipmentPlantCodes = async (params: {\n  year: number | string\n  equipmentType: 1 | 3 | 13 | 16 | '1' | '3' | '13' | '16'\n  reportType: 'New' | 'Updated' | 'Closed' | 'All'\n}): Promise<NhtsaResponse<GetEquipmentPlantCodesResults>> => {\n  const action = 'GetEquipmentPlantCodes'\n\n  /* Runtime type guards against user provided args*/\n  const typeofParams = getTypeof(params)\n  if (!params || typeofParams !== 'object') {\n    return rejectWithError(\n      `${action}, \"params\" argument must be of type object, got: <${typeofParams}> ${params}`\n    )\n  }\n\n  const typeofYear = getTypeof(params.year)\n  if (typeofYear !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"params.year\" argument is required and must be of type number or string, got: <${typeofYear}> ${params.year}`\n    )\n  }\n\n  const typeofEquipmentType = getTypeof(params.equipmentType)\n  if (typeofEquipmentType !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"params.equipmentType\" argument is required and must be of type number or string, got: <${typeofEquipmentType}> ${params.equipmentType}`\n    )\n  }\n\n  const typeofReportType = getTypeof(params.reportType)\n  if (typeofReportType !== 'string') {\n    return rejectWithError(\n      `${action}, \"params.reportType\" argument is required and must be of type string, got: <${typeofReportType}> ${params.reportType}`\n    )\n  }\n\n  /* Build the query string to be appended to the URL*/\n  const queryString = await makeQueryString(params).catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetEquipmentPlantCodesResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetEquipmentPlantCodes endpoint\n *\n * @alias GetEquipmentPlantCodesResults\n */\nexport type GetEquipmentPlantCodesResults = {\n  Address: string\n  City: string\n  Country: string\n  DOTCode: string\n  Name: string\n  OldDotCode: string\n  PostalCode: string\n  StateProvince: string\n  Status: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetMakeForManufacturer returns all the Makes in the vPIC dataset for a specified manufacturer that is requested.\n *\n * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id\n * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the provided name\n *   (it accepts a partial manufacturer name as an input)\n * - `manufacturer` name can be a partial name, or a full name for more specificity\n *   (e.g., \"988\", \"honda\", \"HONDA OF CANADA MFG., INC.\", etc.)\n * - Multiple results are returned in case of multiple matches\n *\n * @async\n * @param {(number|string)} manufacturer - Manufacturer Name (string) or Manufacturer ID (number)\n * @returns {(Promise<NhtsaResponse<GetMakeForManufacturerResults>>)} - Api Response object\n */\n\nexport const GetMakeForManufacturer = async (\n  manufacturer: number | string\n): Promise<NhtsaResponse<GetMakeForManufacturerResults>> => {\n  const action = 'GetMakeForManufacturer'\n\n  /* Runtime type guards against user provided args*/\n  const typeofManufacturer = getTypeof(manufacturer)\n  if (!manufacturer || typeofManufacturer !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"manufacturer\" argument is required and must be of type number or string, got <${typeofManufacturer}> ${manufacturer}`\n    )\n  }\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${manufacturer}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetMakeForManufacturerResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetMakeForManufacturer endpoint\n *\n * @alias GetMakeForManufacturerResults\n */\nexport type GetMakeForManufacturerResults = {\n  Make_ID: number\n  Make_Name: string\n  Mfr_Name: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetMakesForManufacturerAndYear returns all the Makes in the vPIC dataset for a specified manufacturer,\n * and whose Year From and Year To range cover the specified year.\n * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id\n * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the provided name\n *   (it accepts a partial manufacturer name as an input)\n * - Multiple results are returned in case of multiple matches\n * - Manufacturer can be idenfitied by Id, a partial name, or a full name\n *   (e.g., \"988\", \"HONDA\", \"HONDA OF CANADA MFG., INC.\", etc.)\n *\n * @async\n * @param {(number|string)} manufacturer - Manufacturer Name (string) or Manufacturer ID (number)\n * @param {Object} params - Query Search Parameters to append to the URL\n * @param {(number|string)} params.year - Model year of the vehicle - Number, >= 2016\n * @returns {(Promise<NhtsaResponse<GetMakesForManufacturerAndYearResults>>)} - Api Response object\n */\n\nexport const GetMakesForManufacturerAndYear = async (\n  manufacturer: string,\n  params: {\n    year: number | string\n  }\n): Promise<NhtsaResponse<GetMakesForManufacturerAndYearResults>> => {\n  const action = 'GetMakesForManufacturerAndYear'\n\n  /* Runtime type guards against user provided args*/\n  const typeofManufacturer = getTypeof(manufacturer)\n  if (!manufacturer || typeofManufacturer !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"manufacturer\" argument is required and must be of type number or string, got <${typeofManufacturer}> ${manufacturer}`\n    )\n  }\n\n  const typeofParams = getTypeof(params)\n  if (!params || (params && typeofParams !== 'object')) {\n    return rejectWithError(\n      `${action}, \"params\" argument is required and must be of type object, got: <${typeofParams}> ${params}`\n    )\n  }\n\n  const typeofYear = getTypeof(params.year)\n  if (!params.year || typeofYear !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"params.year\" is required and must be of type number or string, got: <${typeofYear}> ${params.year}`\n    )\n  }\n\n  /* Build the query string to be appended to the URL*/\n  const queryString = await makeQueryString(params).catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${manufacturer}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetMakesForManufacturerAndYearResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetMakesForManufacturerAndYear endpoint\n *\n * @alias GetMakesForManufacturerAndYearResults\n */\nexport type GetMakesForManufacturerAndYearResults = {\n  MakeId: number\n  MakeName: string\n  MfrId: number\n  MfrName: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetMakesForVehicleType returns all the Makes in the vPIC dataset for a specified vehicle type (`typeName`),\n * whose name is LIKE the vehicle type name in vPIC Dataset.\n * - Vehicle `typeName` can be a partial name, or a full name for more specificity\n *   (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.)\n *\n * @async\n * @param {string} typeName - A partial or full vehicle type name (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.)\n * @returns {(Promise<NhtsaResponse<GetMakesForVehicleTypeResults>>)} - Api Response object\n */\n\nexport const GetMakesForVehicleType = async (\n  typeName: string\n): Promise<NhtsaResponse<GetMakesForVehicleTypeResults>> => {\n  const action = 'GetMakesForVehicleType'\n\n  /* Runtime type guards against user provided args*/\n  const typeofTypeName = getTypeof(typeName)\n  if (typeofTypeName !== 'string') {\n    return rejectWithError(\n      `${action}, \"typeName\" argument is required and must be of type string, got <${typeofTypeName}> ${typeName}`\n    )\n  }\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${typeName}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetMakesForVehicleTypeResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetMakesForVehicleType endpoint\n *\n * @alias GetMakesForVehicleTypeResults\n */\nexport type GetMakesForVehicleTypeResults = {\n  MakeId: number\n  MakeName: string\n  VehicleTypeId: number\n  VehicleTypeName: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetManufacturerDetails provides the details for a specific manufacturer that is requested.\n *\n * - If supplied `manufacturer` is a number - method will do exact match on Manufacturer's Id\n * - If supplied `manufacturer` is a string - it will look for manufacturers whose name is LIKE the provided name\n *   (it accepts a partial manufacturer name as an input)\n * - `manufacturer` name can be a partial name, or a full name for more specificity\n *   (e.g., \"988\", \"honda\", \"HONDA OF CANADA MFG., INC.\", etc.)\n * - Multiple results are returned in case of multiple matches\n *\n * @async\n * @param {(number|string)} manufacturer - Manufacturer Name (string) or Manufacturer ID (number)\n * @returns {(Promise<NhtsaResponse<GetManufacturerDetailsResults>>)} - Api Response object\n */\n\nexport const GetManufacturerDetails = async (\n  manufacturer: number | string\n): Promise<NhtsaResponse<GetManufacturerDetailsResults>> => {\n  const action = 'GetManufacturerDetails'\n\n  /* Runtime type guards against user provided args*/\n  const typeofManufacturer = getTypeof(manufacturer)\n  if (!manufacturer || typeofManufacturer !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"manufacturer\" argument is required and must be of type number or string, got <${typeofManufacturer}> ${manufacturer}`\n    )\n  }\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${manufacturer}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetManufacturerDetailsResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetManufacturerDetails endpoint\n *\n * @alias GetManufacturerDetailsResults\n */\nexport type GetManufacturerDetailsResults = {\n  Address: string | null\n  Address2: string | null\n  City: string | null\n  ContactEmail: string | null\n  ContactFax: string | null\n  ContactPhone: string | null\n  Country: string | null\n  DBAs: string | null\n  EquipmentItems: Array<unknown>\n  LastUpdated: string\n  ManufacturerTypes: Array<{\n    Name: string\n  }>\n  Mfr_CommonName: string | null\n  Mfr_ID: number | null\n  Mfr_Name: string | null\n  OtherManufacturerDetails: string | null\n  PostalCode: string | null\n  PrimaryProduct: string | null\n  PrincipalFirstName: string | null\n  PrincipalLastName: string | null\n  PrincipalPosition: string | null\n  StateProvince: string | null\n  SubmittedName: string | null\n  SubmittedOn: string\n  SubmittedPosition: string | null\n  VehicleTypes: Array<{\n    GVWRFrom: string\n    GVWRTo: string\n    IsPrimary: boolean\n    Name: string\n  }>\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n// import { GetModelsForMakeYear } from '../endpoints'\n\n// const results = GetModelsForMakeYear('Harley', {})\n\n/**\n * GetModelsForMake returns the Models in the vPIC dataset for a specified `makeName`\n * whose Name is LIKE the Make in vPIC Dataset.\n * - `makeName` can be a partial, or a full for more specificity\n *   (e.g., \"Harley\", \"Harley Davidson\", etc.)\n *\n * @async\n * @param {string} makeName - Vehicle make name\n * @returns {(Promise<NhtsaResponse<GetModelsForMakeResults>>)} - Api Response object\n */\n\nexport const GetModelsForMake = async (\n  makeName: string\n): Promise<NhtsaResponse<GetModelsForMakeResults>> => {\n  const action = 'GetModelsForMake'\n\n  /* Runtime type guards against user provided args*/\n  const typeofMakeName = getTypeof(makeName)\n  if (typeofMakeName !== 'string') {\n    return rejectWithError(\n      `${action}, \"makeName\" argument is required and must be of type string, got <${typeofMakeName}> ${makeName}`\n    )\n  }\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${makeName}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetModelsForMakeResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetModelsForMake endpoint\n *\n * @alias GetModelsForMakeResults\n */\nexport type GetModelsForMakeResults = {\n  Make_ID: number\n  Make_Name: string\n  Model_ID: number\n  Model_Name: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetModelsForMakeId returns the Models in the vPIC dataset for a specified Make\n * whose ID is equal to the `makeID` in the vPIC Dataset.\n *\n * @async\n * @param {(number|string)} makeId - Vehicle make ID (number)\n * @returns {(Promise<NhtsaResponse<GetModelsForMakeIdResults>>)} - Api Response object\n */\n\nexport const GetModelsForMakeId = async (\n  makeId: number | string\n): Promise<NhtsaResponse<GetModelsForMakeIdResults>> => {\n  const action = 'GetModelsForMakeId'\n\n  /* Runtime type guards against user provided args*/\n  const typeofMakeId = getTypeof(makeId)\n  if (!makeId || typeofMakeId !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"makeId\" argument is required and must be of type number or string, got <${typeofMakeId}> ${makeId}`\n    )\n  }\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${makeId}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetModelsForMakeIdResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetModelsForMakeId endpoint\n *\n * @alias GetModelsForMakeIdResults\n */\nexport type GetModelsForMakeIdResults = {\n  Make_ID: number\n  Make_Name: string\n  Model_ID: number\n  Model_Name: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse, AtLeastOne } from '../../types'\n\n/**\n * This returns the Models in the vPIC dataset for a specified Model Year\n * and Make whose name is LIKE the Make in the vPIC Dataset.\n *\n * `params.makeId` is a number and is a required query parameter\n *\n * A minimum of one of the following are required (or a combination of both):\n *   - `params.modelYear` is a number (greater than 1995)\n *   - `params.vehicleType` can be a partial name, or a full name for more specificity\n *     (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.)\n *\n * You can get `makeId`s by:\n * - using `DecodeVinValues` endpoint, via `MakeID` in the Results\n * - using `DecodeVin` endpoint, via `ValueId` in the object containing `Variable: \"Make\"`\n *\n * @async\n * @param {Object} params - Query Search Parameters to append to the URL\n * @param {(number|string)} params.makeId - Make ID to search\n * @param {(number|string)} [params.modelYear] - A number representing the model year to search (greater than 1995)\n * @param {string} [params.vehicleType] - String representing the vehicle type to search\n * @returns {(Promise<NhtsaResponse<GetModelsForMakeIdYearResults>>)} Api Response object\n */\n\nexport const GetModelsForMakeIdYear = async (\n  params: {\n    makeId: number | string\n  } & AtLeastOne<{\n    modelYear?: number | string\n    vehicleType?: string\n  }>\n): Promise<NhtsaResponse<GetModelsForMakeIdYearResults>> => {\n  const action = 'GetModelsForMakeIdYear'\n\n  const makeId: number | string = params?.makeId\n  const modelYear: number | string | undefined = params?.modelYear\n  const vehicleType: string | undefined = params?.vehicleType\n\n  /* Check for required params existence */\n  const typeofParams = getTypeof(params)\n  if (!params || (params && typeofParams !== 'object')) {\n    return rejectWithError(\n      `${action}, \"params\" argument is required and must be of type object, got: <${typeofParams}> ${params}`\n    )\n  }\n\n  /* Required params.makeId */\n  const typeofMakeId = getTypeof(makeId)\n  if (!makeId || typeofMakeId !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"params.makeId\" is required and must be of type number or string, got: <${typeofMakeId}> ${makeId}`\n    )\n  }\n\n  /* At least one of modelYear or vehicleType is required */\n  if (!modelYear && !vehicleType) {\n    return rejectWithError(\n      `${action}, must provide either \"params.modelYear\" or \"params.vehicleType\", got: { modelYear: ${modelYear}, vehicleType: ${vehicleType} }`\n    )\n  }\n\n  /* Runtime type guards against user provided args*/\n  const typeofModelYear = getTypeof(modelYear)\n  if (params?.modelYear && typeofModelYear !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"params.modelYear\" must be of type number or string, got: <${typeofModelYear}> ${modelYear}`\n    )\n  }\n\n  const typeofVehicleType = getTypeof(vehicleType)\n  if (vehicleType && typeofVehicleType !== 'string') {\n    return rejectWithError(\n      `${action}, \"params.vehicleType\" must be of type string, got: <${typeofVehicleType}> ${vehicleType}`\n    )\n  }\n\n  /* Beginning of the the actionUrl string */\n  let actionUrl = `${action}/makeId/${makeId}/`\n\n  /* Append params.modelYear and params.vehicleType to the actionUrl, at least one is required by the API */\n  if (modelYear && vehicleType) {\n    actionUrl += `modelYear/${modelYear}/vehicleType/${vehicleType}`\n  } else if (modelYear) {\n    actionUrl += `modelYear/${modelYear}`\n  } else {\n    actionUrl += `vehicleType/${vehicleType}`\n  }\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${actionUrl}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetModelsForMakeIdYearResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetModelsForMakeIdYear endpoint\n *\n * @alias GetModelsForMakeIdYearResults\n */\nexport type GetModelsForMakeIdYearResults = {\n  Make_ID: number\n  Make_Name: string\n  Model_ID: number\n  Model_Name: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  catchInvalidArguments,\n  createQueryString,\n  getTypeof,\n  rejectWithError,\n  useFetch,\n  validateURI,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse, IArgToValidate, AtLeastOne } from '../../types'\n\n/**\n * GetModelsForMakeYear returns the Models in the vPIC dataset for a specified Model Year\n * and Make whose name is LIKE the Make in the vPIC Dataset.\n *   - `make` is required. It can be a partial, or a full name for more specificity\n *     (e.g., \"Harley\", \"Harley Davidson\", etc.)\n *\n * A minimum of one of the following are required (or a combination of both):\n *   - `params.modelYear` is a number (greater than 1995)\n *   - `params.vehicleType` can be a partial name, or a full name for more specificity\n *     (e.g., \"Vehicle\", \"Moto\", \"Low Speed Vehicle\", etc.)\n *\n * @async\n *\n * @param {string} make - Make name to search\n * @param {Object} params - Query Search Parameters to append to the URL\n * @param {(number|string)} [params.modelYear] - A number representing the model year to search (greater than 1995), required if params.vehicleType is not provided\n * @param {string} [params.vehicleType] - String representing the vehicle type to search, required if params.modelYear is not provided\n * @returns {(Promise<NhtsaResponse<GetModelsForMakeYearResults>>)} Api Response object\n */\n\nexport const GetModelsForMakeYear = async (\n  make: string,\n  params: AtLeastOne<{\n    modelYear?: number | string\n    vehicleType?: string\n  }>\n): Promise<NhtsaResponse<GetModelsForMakeYearResults>> => {\n  const action = 'GetModelsForMakeYear'\n  const modelYear = params?.modelYear\n  const vehicleType = params?.vehicleType\n\n  /* Validate the arguments */\n  try {\n    const atLeastOneArgs: IArgToValidate[] = [\n      {\n        name: 'params.modelYear',\n        types: ['number', 'string'],\n        value: modelYear,\n      },\n      { name: 'params.vehicleType', types: ['string'], value: vehicleType },\n    ]\n    const args: IArgToValidate[] = [\n      { name: 'make', required: true, types: ['string'], value: make },\n      { name: 'params', required: true, types: ['object'], value: params },\n      ...atLeastOneArgs,\n    ]\n\n    catchInvalidArguments({ args })\n    catchInvalidArguments({ args: atLeastOneArgs, mode: 'atLeast' })\n\n    args.forEach((arg) => {\n      if (getTypeof(arg.value) === 'string') {\n        arg.value = validateURI(arg.value as string)\n      }\n    })\n\n    let path = `${action}/make/${make}/`\n    if (modelYear) {\n      path += `modelYear/${modelYear}`\n    }\n    if (vehicleType) {\n      path += `${modelYear ? '/' : ''}vehicleType/${vehicleType}`\n    }\n\n    const queryString = createQueryString()\n    const url = `${NHTSA_BASE_URL}/${path}${queryString}`\n\n    return await useFetch()\n      .get<GetModelsForMakeYearResults>(url)\n      .then((response) => response)\n  } catch (error) {\n    return rejectWithError(error)\n  }\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetModelsForMakeYear endpoint\n *\n * @alias GetModelsForMakeYearResults\n */\nexport type GetModelsForMakeYearResults = {\n  Make_ID: number\n  Make_Name: string\n  Model_ID: number\n  Model_Name: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetParts provides a list of ORGs with letter date in the given range of the dates\n * and with specified Type (`params.type`) of ORG.\n * - Up to 1000 results will be returned at a time.\n * - Get the next page by incrementing the `params.page` query parameter.\n *\n * All query `params` are optional.\n *\n * `params.type`:\n * - (optional) number, 565 (Vehicle Identification Number Guidance, based on 49 CFR Part 565)\n *   or 566 (Manufacturer Identification – Reporting Requirements based on 49 CFR Part 566)\n * `params.fromDate`:\n * - (optional) ORG's Letter Date should be on or after this date\n * `params.manufacturer`:\n * - (optional) if supplied value is a number - method will do exact match on Manufacturer's Id\n * - if supplied value is a string - it will look for manufacturers whose name is LIKE the provided name\n * - it accepts a partial manufacturer name as an input\n * - multiple results are returned in case of multiple matches\n * - manufacturer name can be a partial name, or a full name for more specificity\n *   (e.g., \"988\", \"HONDA\", \"HONDA OF CANADA MFG., INC.\", etc.)\n * `params.page`:\n *  - (optional) number, 1 (default) first 1000 records, 2 - next 1000 records, etc\n *\n * @async\n * @param {Object} [params] - Query Search Parameters to append to the URL\n * @param {(number|string)} [params.type] - Specified type of ORG to search\n * @param {string} [params.fromDate] - Start date of search query\n * @param {string} [params.toDate] - End date of search query\n * @param {(number|string)} [params.page] - Which page number of results to request (100 results per page)\n * @returns {(Promise<NhtsaResponse<GetPartsResults>>)} - Api Response object (required)\n */\n\nexport const GetParts = async (params?: {\n  type?: number | string\n  fromDate?: string\n  toDate?: string\n  page?: number | string\n}): Promise<NhtsaResponse<GetPartsResults>> => {\n  const action = 'GetParts'\n\n  const type = params?.type\n  const fromDate = params?.fromDate\n  const toDate = params?.toDate\n  const page = params?.page\n\n  /* Runtime type guards against user provided args*/\n  const typeofParams = getTypeof(params)\n  if (params && typeofParams !== 'object') {\n    return rejectWithError(\n      `${action}, \"params\" argument must be of type object, got: <${typeofParams}> ${params}`\n    )\n  }\n\n  const typeofType = getTypeof(type)\n  if (type && typeofType !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"params.type\" argument must be of type number or string, got: <${typeofType}> ${type}`\n    )\n  }\n\n  const typeoffromDate = getTypeof(fromDate)\n  if (fromDate && typeoffromDate !== 'string') {\n    return rejectWithError(\n      `${action}, \"params.fromDate\" argument must be of type string, got: <${typeoffromDate}> ${fromDate}`\n    )\n  }\n\n  const typeofToDate = getTypeof(toDate)\n  if (toDate && typeofToDate !== 'string') {\n    return rejectWithError(\n      `${action}, \"params.toDate\" argument must be of type string, got: <${typeofToDate}> ${toDate}`\n    )\n  }\n\n  const typeofPage = getTypeof(page)\n  if (page && typeofPage !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"params.page\" argument must be of type number or string, got: <${typeofPage}> ${page}`\n    )\n  }\n\n  /* Build the query string to be appended to the URL*/\n  const queryString = await makeQueryString(params).catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetPartsResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetParts endpoint\n *\n * @alias GetPartsResults\n */\nexport type GetPartsResults = {\n  CoverLetterURL: string\n  LetterDate: string\n  ManufacturerId: number\n  ManufacturerName: string\n  ModelYearFrom: number | null\n  ModelYearTo: number | null\n  Name: string\n  Type: string\n  URL: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetVehicleTypesForMake returns all the Vehicle Types in the vPIC dataset for a specified Make,\n * whose name is LIKE the make name in the vPIC Dataset.\n * - `makeName` can be a partial name, or a full name for more specificity\n *   (e.g., \"Merc\", \"Mercedes Benz\", etc.)\n *\n * @async\n * @param {string} makeName - Name of the vehicle make to search\n * @returns {(Promise<NhtsaResponse<GetVehicleTypesForMakeResults>>)} - Api Response object\n */\n\nexport const GetVehicleTypesForMake = async (\n  makeName: string\n): Promise<NhtsaResponse<GetVehicleTypesForMakeResults>> => {\n  const action = 'GetVehicleTypesForMake'\n\n  /* Runtime type guards against user provided args*/\n  const typeofMakeName = getTypeof(makeName)\n  if (!makeName || typeofMakeName !== 'string') {\n    return rejectWithError(\n      `${action}, \"makeName\" argument is required and must be of type string, got <${typeofMakeName}> ${makeName}`\n    )\n  }\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${makeName}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetVehicleTypesForMakeResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetVehicleTypesForMake endpoint\n *\n * @alias GetVehicleTypesForMakeResults\n */\nexport type GetVehicleTypesForMakeResults = {\n  MakeId: number\n  MakeName: string\n  VehicleTypeId: number\n  VehicleTypeName: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetVehicleTypesForMakeId returns the Models in the vPIC dataset for a specified Make\n * whose ID is equal to the `makeID` in the vPIC Dataset.\n *\n * @async\n * @param {(number|string)} makeId - Vehicle make ID (number)\n * @returns {(Promise<NhtsaResponse<GetVehicleTypesForMakeIdResults>>)} - Api Response object\n */\n\nexport const GetVehicleTypesForMakeId = async (\n  makeId: number | string\n): Promise<NhtsaResponse<GetVehicleTypesForMakeIdResults>> => {\n  const action = 'GetVehicleTypesForMakeId'\n\n  /* Runtime type guards against user provided args*/\n  const typeofMakeId = getTypeof(makeId)\n  if (!makeId || typeofMakeId !== ('number' || 'string')) {\n    return rejectWithError(\n      `${action}, \"makeId\" argument is required and must be of type number or string, got <${typeofMakeId}> ${makeId}`\n    )\n  }\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${makeId}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetVehicleTypesForMakeIdResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetVehicleTypesForMakeId endpoint\n *\n * @alias GetVehicleTypesForMakeIdResults\n */\nexport type GetVehicleTypesForMakeIdResults = {\n  MakeId: number\n  MakeName: string\n  VehicleTypeId: number\n  VehicleTypeName: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport { makeQueryString, rejectWithError, useFetch } from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n  /**\n   * GetVehicleVariableList provides a list of all the Vehicle related variables that are in the vPIC dataset.\n   * - Information on the name, description and the type of the variable is provided.\n *\n * @async\n * @returns {(Promise<NhtsaResponse<GetVehicleVariableListResults>>)} - Api Response object\n */\n\nexport const GetVehicleVariableList = async (): Promise<\n  NhtsaResponse<GetVehicleVariableListResults>\n> => {\n  const action = 'GetVehicleVariableList'\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetVehicleVariableListResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetVehicleVariableList endpoint\n *\n * @alias GetVehicleVariableListResults\n */\nexport type GetVehicleVariableListResults = {\n  DataType: 'decimal' | 'int' | 'lookup' | 'string'\n  Description: string\n  GroupName: string | null\n  ID: number\n  Name: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetVehicleVariableValuesList provides a list of all the accepted values for a given variable that are stored in the vPIC dataset.\n *\n * This only applies to \"Look up\" type of variables\n * - Search parameter (`variableValue`) can either be a:\n *   - Variable Name (ex: \"battery type\"; must use full name, not just part of it),\n *   - or Variable ID (number)\n *\n * @async\n * @param {(number|string)} variableValue - The variable you want to get a values list of\n * @returns {(Promise<NhtsaResponse<GetVehicleVariableValuesListResults>>)} - Api Response object\n */\n\nexport const GetVehicleVariableValuesList = async (\n  variableValue: number | string\n): Promise<NhtsaResponse<GetVehicleVariableValuesListResults>> => {\n  const action = 'GetVehicleVariableValuesList'\n\n  /* Runtime type guards against user provided args*/\n  const typeofVariableValue = getTypeof(variableValue)\n  if (!variableValue || !['number', 'string'].includes(typeofVariableValue)) {\n    return rejectWithError(\n      `${action}, \"variableValue\" argument is required and must be of type number or string, got <${typeofVariableValue}> ${variableValue}`\n    )\n  }\n\n  /* Encode to a valid URI string (space chars, etc.) if variableValue is a string*/\n  variableValue = encodeURI(String(variableValue))\n\n  /* Build the default query string to be appended to the URL ('?format=json') */\n  const queryString = await makeQueryString().catch((err) =>\n    rejectWithError(`${action}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${action}/${variableValue}${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetVehicleVariableValuesListResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${action}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetVehicleVariableValuesList endpoint\n *\n * @alias GetVehicleVariableValuesListResults\n */\nexport type GetVehicleVariableValuesListResults = {\n  ElementName: string\n  Id: number\n  Name: string\n}\n","/* Constants */\nimport { NHTSA_BASE_URL } from '../../constants'\n/* Utility Functions */\nimport {\n  getTypeof,\n  makeQueryString,\n  rejectWithError,\n  useFetch,\n} from '../../utils'\n/* Types */\nimport type { NhtsaResponse } from '../../types'\n\n/**\n * GetWMIsForManufacturer provides information on the World Manufacturer Identifier (WMI) for a specified `manufacturer`.\n * Only WMIs registered in vPICList are displayed\n * - Both `manufacturer` and `params.vehicleType` are optional but at least one must be provided.\n * - If you don't want to provide `manufacturer` and want to only provide `params.vehicleType` - you must provide `undefined` as the first argument.\n *\n * `manufacturer` can be a partial name, or a full name for more specificity, or WMI ID number (e.g., \"Merc\", \"Mercedes Benz\", 987, etc.)\n * - If `manufacturer` is a number - method will do exact match on Manufacturer's Id\n * - If `manufacturer` is a string - it will look for manufacturers whose name is LIKE the provided name (it accepts a partial manufacturer name as an input).\n *   Multiple results are returned in case of multiple matches\n *\n * `params.vehicleType` can be a string or number (e.g., \"car\", 1)\n * - If `params.vehicleType` is a number - method will do exact match on VehicleType's Id\n * - If `params.vehicleType` is a string - it will look for VehicleType whose name is LIKE the provided name (it accepts a partial VehicleType name as an input).\n *   Multiple results are returned in case of multiple matches.\n *\n * @async\n * @param {(number|string)} [manufacturer] - Manufacturer Name, must be included if vehicleType is not provided\n * @param {Object} [params] - Query Search Parameters to append to the URL.\n * @param {(number|string)} [params.vehicleType] - Optional Vehicle Type search parameter, must be included if manufacturer is not provided\n * @returns {(Promise<NhtsaResponse<GetWMIsForManufacturerResults>>)} - Api Response object\n */\n\nexport const GetWMIsForManufacturer = async (\n  manufacturer?: number | string,\n  params?: {\n    vehicleType?: number | string\n  }\n): Promise<NhtsaResponse<GetWMIsForManufacturerResults>> => {\n  const API = 'GetWMIsForManufacturer'\n\n  const vehicleType = params?.vehicleType\n\n  /* Runtime type guards against user provided args*/\n  if (!manufacturer && !vehicleType) {\n    return rejectWithError(\n      `${API}, \"manufacturer\" and \"params.vehicleType\" arguments are optional but at least 1 is required, got: ` +\n        `manufacturer: ${manufacturer} and vehicleType: ${vehicleType}`\n    )\n  }\n\n  const typeofManufacturer = getTypeof(manufacturer)\n  if (manufacturer && !['number', 'string'].includes(typeofManufacturer)) {\n    return rejectWithError(\n      `${API}, \"manufacturer\" must be of type number or string, got <${typeofManufacturer}> ${manufacturer}`\n    )\n  }\n\n  const typeofParams = getTypeof(params)\n  if (params && typeofParams !== 'object') {\n    return rejectWithError(\n      `${API}, \"params\" must be of type object, got: <${typeofParams}> ${params}`\n    )\n  }\n\n  const typeofVehicleType = getTypeof(params?.vehicleType)\n  if (\n    params?.vehicleType &&\n    !['number', 'string'].includes(typeofVehicleType)\n  ) {\n    return rejectWithError(\n      `${API}, \"params.vehicleType\" must be of type number or string, got: <${typeofVehicleType}> ${params.vehicleType}`\n    )\n  }\n\n  /* Build the query string to be appended to the URL*/\n  const queryString = await makeQueryString(params).catch((err) =>\n    rejectWithError(`${API}, error building query string: ${err}`)\n  )\n\n  /* Build the final request URL*/\n  const url = `${NHTSA_BASE_URL}/${API}/${\n    manufacturer ? manufacturer : ''\n  }${queryString}`\n\n  /* Return the result */\n  return await useFetch()\n    .get<GetWMIsForManufacturerResults>(url)\n    .then((response) => response)\n    .catch((err) => rejectWithError(`${API}, error fetching data: ${err}`))\n}\n\n/**\n * Type representing the structure of objects found in the NhtsaResponse 'Results' array for GetWMIsForManufacturer endpoint\n *\n * @alias GetWMIsForManufacturerResults\n */\nexport type GetWMIsForManufacturerResults = {\n  Country: string\n  CreatedOn: string\n  DateAvailableToPublic: string\n  Id: number\n  Name: string\n  UpdatedOn: string\n  VehicleType: string\n  WMI: string\n}\n"],"names":["catchInvalidArguments","args","mode","arg","validateArgument","name","value","required","types","getTypeof","typeofValue","joinedTypes","errorPrepend","errorAppend","NHTSA_BASE_URL","NHTSA_RESPONSE_FORMAT","toString","createQueryString","params","allowEmptyStringValues","staticParams","_params","queryString","key","index","array","validateURI","isError","error","handleError","message","stack","modifiedError","rejectWithError","TRANSLITERATION_TABLE","WEIGHTS_ARRAY","isValidVin","vin","vinArray","checkDigit","checkValue","digit","digitValue","weight","acc","currValue","makeQueryString","defaultParams","entries","paramsLength","isPrepended","queryStringArray","prepend","append","useFetch","url","options","response","jsonTypes","contentType","type","data","DecodeVin","action","modelYear","DecodeVinExtended","typeofVin","typeofParams","typeofModelYear","err","DecodeVinValues","DecodeVinValuesBatch","inputString","typeofInputString","body","DecodeVinValuesExtended","DecodeWMI","WMI","typeofWMI","GetAllMakes","GetAllManufacturers","typeofManufacturerType","typeofPage","GetCanadianVehicleSpecifications","typeofYear","typeofMake","typeofModel","typeofUnits","make","model","units","GetEquipmentPlantCodes","typeofEquipmentType","typeofReportType","GetMakeForManufacturer","manufacturer","typeofManufacturer","GetMakesForManufacturerAndYear","GetMakesForVehicleType","typeName","typeofTypeName","GetManufacturerDetails","GetModelsForMake","makeName","typeofMakeName","GetModelsForMakeId","makeId","typeofMakeId","GetModelsForMakeIdYear","vehicleType","typeofVehicleType","actionUrl","GetModelsForMakeYear","atLeastOneArgs","path","GetParts","fromDate","toDate","page","typeofType","typeoffromDate","typeofToDate","GetVehicleTypesForMake","GetVehicleTypesForMakeId","GetVehicleVariableList","GetVehicleVariableValuesList","variableValue","typeofVariableValue","GetWMIsForManufacturer","API"],"mappings":"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"}