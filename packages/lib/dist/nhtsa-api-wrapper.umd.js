(function(d,T){typeof exports=="object"&&typeof module<"u"?T(exports):typeof define=="function"&&define.amd?define(["exports"],T):(d=typeof globalThis<"u"?globalThis:d||self,T(d.NHTSA={}))})(this,function(d){"use strict";const T=({name:e,value:t,caller:n,required:i,types:c})=>{if(!e||!n)throw new Error("Error validating argument: 'name' and 'caller' must be provided to validateArgument()");if(!i&&!c)throw new Error(`${n}, error validating argument: ${e}, either 'required' or 'types' must be provided to validateArgument()`);const r=$(t),g=c?`<${c.join(" | ")}>`:"",s=`${n}, error validating argument, "${e}" argument`,u=`received value: ${t} - of type: <${r}>`;if(i&&!c&&!t)throw new Error(`${s} is required, ${u}`);if(c&&!i&&!c.includes(r))throw new Error(`${s} must be of type(s) ${g}, ${u}`);if(i&&c&&(!t||!c.includes(r)))throw new Error(`${s} is required and must be of type(s) ${g}, ${u}`)},o=async e=>Promise.reject(Error(e)),$=e=>{const t=Object.prototype.toString.call(e).toLowerCase();return t.slice(8,t.length-1)},m={A:1,B:2,C:3,D:4,E:5,F:6,G:7,H:8,J:1,K:2,L:3,M:4,N:5,P:7,R:9,S:2,T:3,U:4,V:5,W:6,X:7,Y:8,Z:9},G=[8,7,6,5,4,3,2,10,0,9,8,7,6,5,4,3,2];function Y(e){if(typeof e!="string"||e.length!=17)return!1;e=e.toUpperCase();const t=e.split(""),n=t[8];if(isNaN(parseInt(n))&&n!=="X")return!1;const i=n==="X"?10:parseInt(n);return t.map((r,g)=>{let s;isNaN(parseInt(r))?s=m[r]:s=parseInt(r);const u=G[g];return s*u}).reduce((r,g)=>r+g,0)%11===i}const y="https://vpic.nhtsa.dot.gov/api/vehicles",w="json";function l(e,t=!1){const n={format:w};let i={};!e||$(e)!=="object"?i={...n}:i={...e,...n};const c=Object.entries(i),r=c.length;if(r<1)return Promise.resolve("");let g=!1;const s=c.map(([u,a],h)=>{let q="",b="";const M=$(a);if(a&&M==="number"&&(a=a.toString()),(a||t)&&(M==="string"||M==="number"))return g||(q="?",g=!0),h<r-1&&(b="&"),`${q}${u}=${a}${b}`});return Promise.resolve(encodeURI(s.join("")))}const f=()=>({get:async(t,n={})=>await fetch(t,n).then(async c=>{var s;const g=((s=c.headers.get("content-type"))==null?void 0:s.includes("application/json"))?await c.json():null;if(!c.ok){const u=g&&g.Message||c.status;return Promise.reject(u)}return g}).catch(c=>Promise.reject(Error(`Error fetching data: ${c}`)))}),k=async(e,t)=>{const n="DecodeVin",i=$(e);if(!e||i!=="string")return o(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=$(t);if(t&&c!=="object")return o(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=$(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return o(`${n}, "params.modelYear" must be of type string or number, got: <${r}> ${t.modelYear}`);const g=await l(t).catch(u=>o(`${n}, error building query string: ${u}`)),s=`${y}/${n}/${e}${g}`;return await f().get(s).then(u=>u).catch(u=>o(`${n}, error fetching data: ${u}`))},S=async(e,t)=>{const n="DecodeVinExtended",i=$(e);if(!e||i!=="string")return o(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=$(t);if(t&&c!=="object")return o(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=$(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return o(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const g=await l(t).catch(u=>o(`${n}, error building query string: ${u}`)),s=`${y}/${n}/${e}${g}`;return await f().get(s).then(u=>u).catch(u=>o(`${n}, error fetching data: ${u}`))},j=async(e,t)=>{const n="DecodeVinValues",i=$(e);if(!e||i!=="string")return o(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=$(t);if(t&&c!=="object")return o(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=$(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return o(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const g=await l(t).catch(u=>o(`${n}, error building query string: ${u}`)),s=`${y}/${n}/${e}${g}`;return await f().get(s).then(u=>u).catch(u=>o(`${n}, error fetching data: ${u}`))},F=async e=>{const t="DecodeVinValuesBatch",n=$(e);if(!e||n!=="string")return o(`${t}, "inputString" argument is required and must be of type string, got: <${n}> ${e}`);const i=`${y}/${t}/`,c=encodeURI(`DATA=${e}&format=${w}`);return await f().get(i,{method:"POST",headers:{"content-type":"application/x-www-form-urlencoded"},body:c}).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},D=async(e,t)=>{const n="DecodeVinValuesExtended",i=$(e);if(!e||i!=="string")return o(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=$(t);if(t&&c!=="object")return o(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=$(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return o(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const g=await l(t).catch(u=>o(`${n}, error building query string: ${u}`)),s=`${y}/${n}/${e}${g}`;return await f().get(s).then(u=>u).catch(u=>o(`${n}, error fetching data: ${u}`))},P=async e=>{const t="DecodeWMI",n=$(e);if(n!=="string")return o(`${t}, "WMI" argument is required and must be of type string, got <${n}> ${e}`);const i=await l().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${y}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},I=async()=>{const e="GetAllMakes",t=await l().catch(i=>o(`${e}, error building query string: ${i}`)),n=`${y}/${e}${t}`;return await f().get(n).then(i=>i).catch(i=>o(`${e}, error fetching data: ${i}`))},A=async e=>{const t="GetAllManufacturers",n=$(e);if(e&&n!=="object")return o(`${t}, "params" argument must be of type object, got: <${n}> ${e}`);const i=$(e==null?void 0:e.manufacturerType);if(e!=null&&e.manufacturerType&&i!=="string")return o(`${t}, params.manufacturerType" argument must be of type string, got: <${i}> ${e.manufacturerType}`);const c=$(e==null?void 0:e.page);if(e!=null&&e.page&&c!=="number | string")return o(`${t}, "params.page" argument must be of type number or string, got: <${c}> ${e.page}`);const r=await l(e).catch(s=>o(`${t}, error building query string: ${s}`)),g=`${y}/${t}${r}`;return await f().get(g).then(s=>s).catch(s=>o(`${t}, error fetching data: ${s}`))},E=async e=>{const t="GetCanadianVehicleSpecifications",n=$(e);if(!e||e&&n!=="object")return o(`${t}, "params" argument is required and must be of type object, got: <${n}> ${e}`);const i=$(e==null?void 0:e.year);if(!(e!=null&&e.year)||i!=="number")return o(`${t}, "params.year" argument is required and must be of type number or string, got: <${i}> ${e.year}`);const c=$(e.make);if(e!=null&&e.make&&c!=="string")return o(`${t}, "params.make" argument must be of type string, got: <${c}> ${e.make}`);const r=$(e.model);if(e.model&&r!=="string")return o(`${t}, "params.model" argument must be of type string, got: <${r}> ${e.model}`);const g=$(e.units);if(e.units&&g!=="string")return o(`${t}, "params.units" argument must be of type string, got: <${g}> ${e.units}`);const s=e.make||"",u=e.model||"",a=e.units||"",h={year:e.year,make:s,model:u,units:a},q=await l(h,!0).catch(V=>o(`${t}, error building query string: ${V}`)),b=`${y}/${t}/${q}`;return await f().get(b).then(V=>V).catch(V=>o(`${t}, error fetching data: ${V}`))},p=async e=>{const t="GetEquipmentPlantCodes",n=$(e);if(!e||n!=="object")return o(`${t}, "params" argument must be of type object, got: <${n}> ${e}`);const i=$(e.year);if(i!=="number")return o(`${t}, "params.year" argument is required and must be of type number or string, got: <${i}> ${e.year}`);const c=$(e.equipmentType);if(c!=="number")return o(`${t}, "params.equipmentType" argument is required and must be of type number or string, got: <${c}> ${e.equipmentType}`);const r=$(e.reportType);if(r!=="string")return o(`${t}, "params.reportType" argument is required and must be of type string, got: <${r}> ${e.reportType}`);const g=await l(e).catch(u=>o(`${t}, error building query string: ${u}`)),s=`${y}/${t}${g}`;return await f().get(s).then(u=>u).catch(u=>o(`${t}, error fetching data: ${u}`))},v=async e=>{const t="GetMakeForManufacturer",n=$(e);if(!e||n!=="number")return o(`${t}, "manufacturer" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await l().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${y}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},R=async(e,t)=>{const n="GetMakesForManufacturerAndYear",i=$(e);if(!e||i!=="number")return o(`${n}, "manufacturer" argument is required and must be of type number or string, got <${i}> ${e}`);const c=$(t);if(!t||t&&c!=="object")return o(`${n}, "params" argument is required and must be of type object, got: <${c}> ${t}`);const r=$(t.year);if(!t.year||r!=="number")return o(`${n}, "params.year" is required and must be of type number or string, got: <${r}> ${t.year}`);const g=await l(t).catch(u=>o(`${n}, error building query string: ${u}`)),s=`${y}/${n}/${e}${g}`;return await f().get(s).then(u=>u).catch(u=>o(`${n}, error fetching data: ${u}`))},L=async e=>{const t="GetMakesForVehicleType",n=$(e);if(n!=="string")return o(`${t}, "typeName" argument is required and must be of type string, got <${n}> ${e}`);const i=await l().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${y}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},N=async e=>{const t="GetManufacturerDetails",n=$(e);if(!e||n!=="number")return o(`${t}, "manufacturer" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await l().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${y}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},C=async e=>{const t="GetModelsForMake",n=$(e);if(n!=="string")return o(`${t}, "makeName" argument is required and must be of type string, got <${n}> ${e}`);const i=await l().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${y}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},W=async e=>{const t="GetModelsForMakeId",n=$(e);if(!e||n!=="number")return o(`${t}, "makeId" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await l().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${y}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},U=async e=>{const t="GetModelsForMakeIdYear",n=e==null?void 0:e.makeId,i=e==null?void 0:e.modelYear,c=e==null?void 0:e.vehicleType,r=$(e);if(!e||e&&r!=="object")return o(`${t}, "params" argument is required and must be of type object, got: <${r}> ${e}`);const g=$(n);if(!n||g!=="number")return o(`${t}, "params.makeId" is required and must be of type number or string, got: <${g}> ${n}`);if(!i&&!c)return o(`${t}, must provide either "params.modelYear" or "params.vehicleType", got: { modelYear: ${i}, vehicleType: ${c} }`);const s=$(i);if(e!=null&&e.modelYear&&s!=="number")return o(`${t}, "params.modelYear" must be of type number or string, got: <${s}> ${i}`);const u=$(c);if(c&&u!=="string")return o(`${t}, "params.vehicleType" must be of type string, got: <${u}> ${c}`);let a=`${t}/makeId/${n}/`;i&&c?a+=`modelYear/${i}/vehicleType/${c}`:i?a+=`modelYear/${i}`:a+=`vehicleType/${c}`;const h=await l().catch(b=>o(`${t}, error building query string: ${b}`)),q=`${y}/${a}${h}`;return await f().get(q).then(b=>b).catch(b=>o(`${t}, error fetching data: ${b}`))},_=async e=>{const t="GetModelsForMakeYear",n=e==null?void 0:e.make,i=e==null?void 0:e.modelYear,c=e==null?void 0:e.vehicleType;try{T({caller:t,name:"params",required:!0,types:["object"],value:e}),T({caller:t,name:"params.make",required:!0,types:["string"],value:e.make})}catch(h){return o(h.message)}if(!i&&!c)return o(`${t}, must provide either "params.modelYear" or "params.vehicleType" or both, got: { modelYear: ${i}, vehicleType: ${c} }`);const r=$(i);if(e!=null&&e.modelYear&&r!=="number")return o(`${t}, "params.modelYear" must be of type number or string, got: <${r}> ${i}`);const g=$(c);if(c&&g!=="string")return o(`${t}, "params.vehicleType" must be of type string, got: <${g}> ${c}`);let s=`${t}/make/${n}/`;i&&c?s+=`modelYear/${i}/vehicleType/${c}`:i?s+=`modelYear/${i}`:s+=`vehicleType/${c}`;const u=await l().catch(h=>o(`${t}, error building query string: ${h}`)),a=`${y}/${s}${u}`;return await f().get(a).then(h=>h).catch(h=>o(`${t}, error fetching data: ${h}`))},O=async e=>{const t="GetParts",n=e==null?void 0:e.type,i=e==null?void 0:e.fromDate,c=e==null?void 0:e.toDate,r=e==null?void 0:e.page,g=$(e);if(e&&g!=="object")return o(`${t}, "params" argument must be of type object, got: <${g}> ${e}`);const s=$(n);if(n&&s!=="number")return o(`${t}, "params.type" argument must be of type number or string, got: <${s}> ${n}`);const u=$(i);if(i&&u!=="string")return o(`${t}, "params.fromDate" argument must be of type string, got: <${u}> ${i}`);const a=$(c);if(c&&a!=="string")return o(`${t}, "params.toDate" argument must be of type string, got: <${a}> ${c}`);const h=$(r);if(r&&h!=="number")return o(`${t}, "params.page" argument must be of type number or string, got: <${h}> ${r}`);const q=await l(e).catch(M=>o(`${t}, error building query string: ${M}`)),b=`${y}/${t}${q}`;return await f().get(b).then(M=>M).catch(M=>o(`${t}, error fetching data: ${M}`))},B=async e=>{const t="GetVehicleTypesForMake",n=$(e);if(!e||n!=="string")return o(`${t}, "makeName" argument is required and must be of type string, got <${n}> ${e}`);const i=await l().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${y}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},H=async e=>{const t="GetVehicleTypesForMakeId",n=$(e);if(!e||n!=="number")return o(`${t}, "makeId" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await l().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${y}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},J=async()=>{const e="GetVehicleVariableList",t=await l().catch(i=>o(`${e}, error building query string: ${i}`)),n=`${y}/${e}${t}`;return await f().get(n).then(i=>i).catch(i=>o(`${e}, error fetching data: ${i}`))},X=async e=>{const t="GetVehicleVariableValuesList",n=$(e);if(!e||!["number","string"].includes(n))return o(`${t}, "variableValue" argument is required and must be of type number or string, got <${n}> ${e}`);e=encodeURI(String(e));const i=await l().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${y}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},K=async(e,t)=>{const n="GetWMIsForManufacturer",i=t==null?void 0:t.vehicleType;if(!e&&!i)return o(`${n}, "manufacturer" and "params.vehicleType" arguments are optional but at least 1 is required, got: manufacturer: ${e} and vehicleType: ${i}`);const c=$(e);if(e&&!["number","string"].includes(c))return o(`${n}, "manufacturer" must be of type number or string, got <${c}> ${e}`);const r=$(t);if(t&&r!=="object")return o(`${n}, "params" must be of type object, got: <${r}> ${t}`);const g=$(t==null?void 0:t.vehicleType);if(t!=null&&t.vehicleType&&!["number","string"].includes(g))return o(`${n}, "params.vehicleType" must be of type number or string, got: <${g}> ${t.vehicleType}`);const s=await l(t).catch(a=>o(`${n}, error building query string: ${a}`)),u=`${y}/${n}/${e||""}${s}`;return await f().get(u).then(a=>a).catch(a=>o(`${n}, error fetching data: ${a}`))};d.DecodeVin=k,d.DecodeVinExtended=S,d.DecodeVinValues=j,d.DecodeVinValuesBatch=F,d.DecodeVinValuesExtended=D,d.DecodeWMI=P,d.GetAllMakes=I,d.GetAllManufacturers=A,d.GetCanadianVehicleSpecifications=E,d.GetEquipmentPlantCodes=p,d.GetMakeForManufacturer=v,d.GetMakesForManufacturerAndYear=R,d.GetMakesForVehicleType=L,d.GetManufacturerDetails=N,d.GetModelsForMake=C,d.GetModelsForMakeId=W,d.GetModelsForMakeIdYear=U,d.GetModelsForMakeYear=_,d.GetParts=O,d.GetVehicleTypesForMake=B,d.GetVehicleTypesForMakeId=H,d.GetVehicleVariableList=J,d.GetVehicleVariableValuesList=X,d.GetWMIsForManufacturer=K,d.isValidVin=Y,Object.defineProperty(d,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=nhtsa-api-wrapper.umd.js.map
