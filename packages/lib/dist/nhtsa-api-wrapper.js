"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const T=({endpoint:e,argName:t,required:n,types:i,value:c})=>{const r=s(c),$=i.length;let g=!1;const u=i.map((h,l)=>{let b="",q="";if(h)return g||(b="<",g=!0),l<$-1&&(q="|"),l===$-1&&(q=">"),`${b}${h}${q}`}),y=n?"is required and":"",M=`must be of type ${u.join("")}`;return`${e}, ${t} ${y} ${M}, got <${r}> ${c}`},o=async e=>Promise.reject(Error(e)),s=e=>{const t=Object.prototype.toString.call(e).toLowerCase();return t.slice(8,t.length-1)},G={A:1,B:2,C:3,D:4,E:5,F:6,G:7,H:8,J:1,K:2,L:3,M:4,N:5,P:7,R:9,S:2,T:3,U:4,V:5,W:6,X:7,Y:8,Z:9},w=[8,7,6,5,4,3,2,10,0,9,8,7,6,5,4,3,2];function Y(e){if(typeof e!="string"||e.length!=17)return!1;e=e.toUpperCase();const t=e.split(""),n=t[8];if(isNaN(parseInt(n))&&n!=="X")return!1;const i=n==="X"?10:parseInt(n);return t.map((r,$)=>{let g;isNaN(parseInt(r))?g=G[r]:g=parseInt(r);const u=w[$];return g*u}).reduce((r,$)=>r+$,0)%11===i}const d="https://vpic.nhtsa.dot.gov/api/vehicles",V="json";function a(e,t=!1){const n={format:V};let i={};!e||s(e)!=="object"?i={...n}:i={...e,...n};const c=Object.entries(i),r=c.length;if(r<1)return Promise.resolve("");let $=!1;const g=c.map(([u,y],M)=>{let h="",l="";const b=s(y);if(y&&b==="number"&&(y=y.toString()),(y||t)&&(b==="string"||b==="number"))return $||(h="?",$=!0),M<r-1&&(l="&"),`${h}${u}=${y}${l}`});return Promise.resolve(encodeURI(g.join("")))}const f=()=>({get:async(t,n={})=>await fetch(t,n).then(async c=>{var g;const $=((g=c.headers.get("content-type"))==null?void 0:g.includes("application/json"))?await c.json():null;if(!c.ok){const u=$&&$.Message||c.status;return Promise.reject(u)}return $}).catch(c=>Promise.reject(Error(`Error fetching data: ${c}`)))}),p=async(e,t)=>{const n="DecodeVin",i=s(e);if(!e||i!=="string")return o(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=s(t);if(t&&c!=="object")return o(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=s(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return o(`${n}, "params.modelYear" must be of type string or number, got: <${r}> ${t.modelYear}`);const $=await a(t).catch(u=>o(`${n}, error building query string: ${u}`)),g=`${d}/${n}/${e}${$}`;return await f().get(g).then(u=>u).catch(u=>o(`${n}, error fetching data: ${u}`))},k=async(e,t)=>{const n="DecodeVinExtended",i=s(e);if(!e||i!=="string")return o(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=s(t);if(t&&c!=="object")return o(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=s(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return o(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const $=await a(t).catch(u=>o(`${n}, error building query string: ${u}`)),g=`${d}/${n}/${e}${$}`;return await f().get(g).then(u=>u).catch(u=>o(`${n}, error fetching data: ${u}`))},m=async(e,t)=>{const n="DecodeVinValues",i=s(e);if(!e||i!=="string")return o(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=s(t);if(t&&c!=="object")return o(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=s(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return o(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const $=await a(t).catch(u=>o(`${n}, error building query string: ${u}`)),g=`${d}/${n}/${e}${$}`;return await f().get(g).then(u=>u).catch(u=>o(`${n}, error fetching data: ${u}`))},S=async e=>{const t="DecodeVinValuesBatch",n=s(e);if(!e||n!=="string")return o(`${t}, "inputString" argument is required and must be of type string, got: <${n}> ${e}`);const i=`${d}/${t}/`,c=encodeURI(`DATA=${e}&format=${V}`);return await f().get(i,{method:"POST",headers:{"content-type":"application/x-www-form-urlencoded"},body:c}).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},j=async(e,t)=>{const n="DecodeVinValuesExtended",i=s(e);if(!e||i!=="string")return o(`${n}, "vin" argument is required and must be of type string, got: <${i}> ${e}`);const c=s(t);if(t&&c!=="object")return o(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=s(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return o(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const $=await a(t).catch(u=>o(`${n}, error building query string: ${u}`)),g=`${d}/${n}/${e}${$}`;return await f().get(g).then(u=>u).catch(u=>o(`${n}, error fetching data: ${u}`))},F=async e=>{const t="DecodeWMI",n=s(e);if(n!=="string")return o(`${t}, "WMI" argument is required and must be of type string, got <${n}> ${e}`);const i=await a().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${d}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},P=async()=>{const e="GetAllMakes",t=await a().catch(i=>o(`${e}, error building query string: ${i}`)),n=`${d}/${e}${t}`;return await f().get(n).then(i=>i).catch(i=>o(`${e}, error fetching data: ${i}`))},D=async e=>{const t="GetAllManufacturers",n=s(e);if(e&&n!=="object")return o(`${t}, "params" argument must be of type object, got: <${n}> ${e}`);const i=s(e==null?void 0:e.manufacturerType);if(e!=null&&e.manufacturerType&&i!=="string")return o(`${t}, params.manufacturerType" argument must be of type string, got: <${i}> ${e.manufacturerType}`);const c=s(e==null?void 0:e.page);if(e!=null&&e.page&&c!=="number | string")return o(`${t}, "params.page" argument must be of type number or string, got: <${c}> ${e.page}`);const r=await a(e).catch(g=>o(`${t}, error building query string: ${g}`)),$=`${d}/${t}${r}`;return await f().get($).then(g=>g).catch(g=>o(`${t}, error fetching data: ${g}`))},I=async e=>{const t="GetCanadianVehicleSpecifications",n=s(e);if(!e||e&&n!=="object")return o(`${t}, "params" argument is required and must be of type object, got: <${n}> ${e}`);const i=s(e==null?void 0:e.year);if(!(e!=null&&e.year)||i!=="number")return o(`${t}, "params.year" argument is required and must be of type number or string, got: <${i}> ${e.year}`);const c=s(e.make);if(e!=null&&e.make&&c!=="string")return o(`${t}, "params.make" argument must be of type string, got: <${c}> ${e.make}`);const r=s(e.model);if(e.model&&r!=="string")return o(`${t}, "params.model" argument must be of type string, got: <${r}> ${e.model}`);const $=s(e.units);if(e.units&&$!=="string")return o(`${t}, "params.units" argument must be of type string, got: <${$}> ${e.units}`);const g=e.make||"",u=e.model||"",y=e.units||"",M={year:e.year,make:g,model:u,units:y},h=await a(M,!0).catch(q=>o(`${t}, error building query string: ${q}`)),l=`${d}/${t}/${h}`;return await f().get(l).then(q=>q).catch(q=>o(`${t}, error fetching data: ${q}`))},A=async e=>{const t="GetEquipmentPlantCodes",n=s(e);if(!e||n!=="object")return o(`${t}, "params" argument must be of type object, got: <${n}> ${e}`);const i=s(e.year);if(i!=="number")return o(`${t}, "params.year" argument is required and must be of type number or string, got: <${i}> ${e.year}`);const c=s(e.equipmentType);if(c!=="number")return o(`${t}, "params.equipmentType" argument is required and must be of type number or string, got: <${c}> ${e.equipmentType}`);const r=s(e.reportType);if(r!=="string")return o(`${t}, "params.reportType" argument is required and must be of type string, got: <${r}> ${e.reportType}`);const $=await a(e).catch(u=>o(`${t}, error building query string: ${u}`)),g=`${d}/${t}${$}`;return await f().get(g).then(u=>u).catch(u=>o(`${t}, error fetching data: ${u}`))},E=async e=>{const t="GetMakeForManufacturer",n=s(e);if(!e||n!=="number")return o(`${t}, "manufacturer" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await a().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${d}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},R=async(e,t)=>{const n="GetMakesForManufacturerAndYear",i=s(e);if(!e||i!=="number")return o(`${n}, "manufacturer" argument is required and must be of type number or string, got <${i}> ${e}`);const c=s(t);if(!t||t&&c!=="object")return o(`${n}, "params" argument is required and must be of type object, got: <${c}> ${t}`);const r=s(t.year);if(!t.year||r!=="number")return o(`${n}, "params.year" is required and must be of type number or string, got: <${r}> ${t.year}`);const $=await a(t).catch(u=>o(`${n}, error building query string: ${u}`)),g=`${d}/${n}/${e}${$}`;return await f().get(g).then(u=>u).catch(u=>o(`${n}, error fetching data: ${u}`))},L=async e=>{const t="GetMakesForVehicleType",n=s(e);if(n!=="string")return o(`${t}, "typeName" argument is required and must be of type string, got <${n}> ${e}`);const i=await a().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${d}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},N=async e=>{const t="GetManufacturerDetails",n=s(e);if(!e||n!=="number")return o(`${t}, "manufacturer" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await a().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${d}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},v=async e=>{const t="GetModelsForMake",n=s(e);if(n!=="string")return o(`${t}, "makeName" argument is required and must be of type string, got <${n}> ${e}`);const i=await a().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${d}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},C=async e=>{const t="GetModelsForMakeId",n=s(e);if(!e||n!=="number")return o(`${t}, "makeId" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await a().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${d}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},W=async e=>{const t="GetModelsForMakeIdYear",n=e==null?void 0:e.makeId,i=e==null?void 0:e.modelYear,c=e==null?void 0:e.vehicleType,r=s(e);if(!e||e&&r!=="object")return o(`${t}, "params" argument is required and must be of type object, got: <${r}> ${e}`);const $=s(n);if(!n||$!=="number")return o(`${t}, "params.makeId" is required and must be of type number or string, got: <${$}> ${n}`);if(!i&&!c)return o(`${t}, must provide either "params.modelYear" or "params.vehicleType", got: { modelYear: ${i}, vehicleType: ${c} }`);const g=s(i);if(e!=null&&e.modelYear&&g!=="number")return o(`${t}, "params.modelYear" must be of type number or string, got: <${g}> ${i}`);const u=s(c);if(c&&u!=="string")return o(`${t}, "params.vehicleType" must be of type string, got: <${u}> ${c}`);let y=`${t}/makeId/${n}/`;i&&c?y+=`modelYear/${i}/vehicleType/${c}`:i?y+=`modelYear/${i}`:y+=`vehicleType/${c}`;const M=await a().catch(l=>o(`${t}, error building query string: ${l}`)),h=`${d}/${y}${M}`;return await f().get(h).then(l=>l).catch(l=>o(`${t}, error fetching data: ${l}`))},U=async e=>{const t="GetModelsForMakeYear",n=e==null?void 0:e.make,i=e==null?void 0:e.modelYear,c=e==null?void 0:e.vehicleType,r=s(e);if(!e||e&&r!=="object")return o(T({endpoint:t,argName:"params",required:!0,types:["object","string","number"],value:e}));const $=s(n);if(!n||$!=="string")return o(`${t}, "params.make" is required and must be of type string, got: <${$}> ${n}`);if(!i&&!c)return o(`${t}, must provide either "params.modelYear" or "params.vehicleType" or both, got: { modelYear: ${i}, vehicleType: ${c} }`);const g=s(i);if(e!=null&&e.modelYear&&g!=="number")return o(`${t}, "params.modelYear" must be of type number or string, got: <${g}> ${i}`);const u=s(c);if(c&&u!=="string")return o(`${t}, "params.vehicleType" must be of type string, got: <${u}> ${c}`);let y=`${t}/make/${n}/`;i&&c?y+=`modelYear/${i}/vehicleType/${c}`:i?y+=`modelYear/${i}`:y+=`vehicleType/${c}`;const M=await a().catch(l=>o(`${t}, error building query string: ${l}`)),h=`${d}/${y}${M}`;return await f().get(h).then(l=>l).catch(l=>o(`${t}, error fetching data: ${l}`))},_=async e=>{const t="GetParts",n=e==null?void 0:e.type,i=e==null?void 0:e.fromDate,c=e==null?void 0:e.toDate,r=e==null?void 0:e.page,$=s(e);if(e&&$!=="object")return o(`${t}, "params" argument must be of type object, got: <${$}> ${e}`);const g=s(n);if(n&&g!=="number")return o(`${t}, "params.type" argument must be of type number or string, got: <${g}> ${n}`);const u=s(i);if(i&&u!=="string")return o(`${t}, "params.fromDate" argument must be of type string, got: <${u}> ${i}`);const y=s(c);if(c&&y!=="string")return o(`${t}, "params.toDate" argument must be of type string, got: <${y}> ${c}`);const M=s(r);if(r&&M!=="number")return o(`${t}, "params.page" argument must be of type number or string, got: <${M}> ${r}`);const h=await a(e).catch(b=>o(`${t}, error building query string: ${b}`)),l=`${d}/${t}${h}`;return await f().get(l).then(b=>b).catch(b=>o(`${t}, error fetching data: ${b}`))},O=async e=>{const t="GetVehicleTypesForMake",n=s(e);if(!e||n!=="string")return o(`${t}, "makeName" argument is required and must be of type string, got <${n}> ${e}`);const i=await a().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${d}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},x=async e=>{const t="GetVehicleTypesForMakeId",n=s(e);if(!e||n!=="number")return o(`${t}, "makeId" argument is required and must be of type number or string, got <${n}> ${e}`);const i=await a().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${d}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},B=async()=>{const e="GetVehicleVariableList",t=await a().catch(i=>o(`${e}, error building query string: ${i}`)),n=`${d}/${e}${t}`;return await f().get(n).then(i=>i).catch(i=>o(`${e}, error fetching data: ${i}`))},H=async e=>{const t="GetVehicleVariableValuesList",n=s(e);if(!e||!["number","string"].includes(n))return o(`${t}, "variableValue" argument is required and must be of type number or string, got <${n}> ${e}`);e=encodeURI(String(e));const i=await a().catch(r=>o(`${t}, error building query string: ${r}`)),c=`${d}/${t}/${e}${i}`;return await f().get(c).then(r=>r).catch(r=>o(`${t}, error fetching data: ${r}`))},J=async(e,t)=>{const n="GetWMIsForManufacturer",i=t==null?void 0:t.vehicleType;if(!e&&!i)return o(`${n}, "manufacturer" and "params.vehicleType" arguments are optional but at least 1 is required, got: manufacturer: ${e} and vehicleType: ${i}`);const c=s(e);if(e&&!["number","string"].includes(c))return o(`${n}, "manufacturer" must be of type number or string, got <${c}> ${e}`);const r=s(t);if(t&&r!=="object")return o(`${n}, "params" must be of type object, got: <${r}> ${t}`);const $=s(t==null?void 0:t.vehicleType);if(t!=null&&t.vehicleType&&!["number","string"].includes($))return o(`${n}, "params.vehicleType" must be of type number or string, got: <${$}> ${t.vehicleType}`);const g=await a(t).catch(y=>o(`${n}, error building query string: ${y}`)),u=`${d}/${n}/${e||""}${g}`;return await f().get(u).then(y=>y).catch(y=>o(`${n}, error fetching data: ${y}`))};exports.DecodeVin=p;exports.DecodeVinExtended=k;exports.DecodeVinValues=m;exports.DecodeVinValuesBatch=S;exports.DecodeVinValuesExtended=j;exports.DecodeWMI=F;exports.GetAllMakes=P;exports.GetAllManufacturers=D;exports.GetCanadianVehicleSpecifications=I;exports.GetEquipmentPlantCodes=A;exports.GetMakeForManufacturer=E;exports.GetMakesForManufacturerAndYear=R;exports.GetMakesForVehicleType=L;exports.GetManufacturerDetails=N;exports.GetModelsForMake=v;exports.GetModelsForMakeId=C;exports.GetModelsForMakeIdYear=W;exports.GetModelsForMakeYear=U;exports.GetParts=_;exports.GetVehicleTypesForMake=O;exports.GetVehicleTypesForMakeId=x;exports.GetVehicleVariableList=B;exports.GetVehicleVariableValuesList=H;exports.GetWMIsForManufacturer=J;exports.isValidVin=Y;
//# sourceMappingURL=nhtsa-api-wrapper.js.map
