var NHTSA=function(d){"use strict";const V=({args:e,mode:t="default"})=>{if(!e||s(e)!=="array")throw Error('catchInvalidArguments requires "args" that must be an array of IArgToValidate objects');if(t==="default")e.forEach(n=>{T(n)});else if(t==="atLeast"&&!e.find(o=>!!o.value))throw Error(`must provide at least one of the following arguments: ${e.map(o=>o.name).join(", ")}`)},T=({name:e,value:t,required:n,types:o,mode:c="error"})=>{if(s(e)!=="string")throw Error("error validating argument named 'name', is required and must be a string");if(o&&s(o)!=="array")throw Error(`error validating argument named "${e}", 'types' must be an array of strings`);const r=s(t),$=o?`<${o.join(" | ")}>`:"";let a="";const u=`error validating argument named "${e}",`,g=`received value: ${t} - of type: <${r}>`;if(n&&!o?t||(a=`${u} is required, ${g}`):o&&!n?t&&!o.includes(r)&&(a=`${u} must be of type(s) ${$}, ${g}`):n&&o&&(!t||!o.includes(r))&&(a=`${u} is required and must be of type(s) ${$}, ${g}`),a.length){if(c==="boolean")return!1;if(c==="error")throw Error(a)}return!0},f="https://vpic.nhtsa.dot.gov/api/vehicles",w="json",s=e=>{const t=Object.prototype.toString.call(e).toLowerCase();return t.slice(8,t.length-1)},G=(e,t=!1)=>{const n={format:w},o=s(e)==="object"?{...e,...n}:n,c="?"+Object.entries(o).map(([r,$],a,u)=>{const g=s($);return g!=="string"&&g!=="number"?"":(g==="number"&&($=$.toString()),$.length||t&&$===""?`${r}=${$}${a<u.length-1?"&":""}`:"")}).join("");return S(c)},S=e=>{if(e=encodeURI(e),/[^0-9A-Z?&=%]/gi.test(e))throw Error("Invalid characters found in query string. Only characters a-z, 0-9, and ?,&,=,% are allowed.");return e},k=e=>s(e)==="error",Y=e=>{let t="an unknown error occurred.";return k(e)?e:(s(e)==="string"&&(t=e),Error(t))},i=async e=>(k(e)||(e=Y(e)),Promise.reject(e)),j={A:1,B:2,C:3,D:4,E:5,F:6,G:7,H:8,J:1,K:2,L:3,M:4,N:5,P:7,R:9,S:2,T:3,U:4,V:5,W:6,X:7,Y:8,Z:9},I=[8,7,6,5,4,3,2,10,0,9,8,7,6,5,4,3,2];function A(e){if(typeof e!="string"||e.length!=17)return!1;e=e.toUpperCase();const t=e.split(""),n=t[8];if(isNaN(parseInt(n))&&n!=="X")return!1;const o=n==="X"?10:parseInt(n);return t.map((r,$)=>{let a;isNaN(parseInt(r))?a=j[r]:a=parseInt(r);const u=I[$];return a*u}).reduce((r,$)=>r+$,0)%11===o}function l(e,t=!1){const n={format:w};let o={};!e||s(e)!=="object"?o={...n}:o={...e,...n};const c=Object.entries(o),r=c.length;if(r<1)return Promise.resolve("");let $=!1;const a=c.map(([u,g],b)=>{let m="",h="";const q=s(g);if(g&&q==="number"&&(g=g.toString()),(g||t)&&(q==="string"||q==="number"))return $||(m="?",$=!0),b<r-1&&(h="&"),`${m}${u}=${g}${h}`});return Promise.resolve(encodeURI(a.join("")))}const y=()=>({get:async(t,n={})=>await fetch(t,n).then(async c=>{if(!c.ok)throw Error(`${c.status} ${c.url}`);const r=["application/json","text/json"],$=c.headers.get("content-type");if(!r.some(g=>$==null?void 0:$.includes(g)))throw Error(`API response is not in JSON format; got content-type: ${$}, responseStatus: ${c.status}}, responseUrl: ${c.url}`);const u=await c.json();if(!u)throw Error(`API responded but returned no data; got content-type: ${$}, responseStatus: ${c.status}}, responseUrl: ${c.url}`);return u}).catch(c=>(c.message=`API error fetching data: ${c.message}`,i(c)))}),p=async(e,t)=>{const n="DecodeVin",o=t==null?void 0:t.modelYear;try{V({args:[{name:"vin",required:!0,types:["string"],value:e},{name:"params",types:["object"],value:t},{name:"modelYear",types:["number","string"],value:o}]});const r=G(t),$=`${f}/${n}/${e}${r}`;return await y().get($)}catch(c){return i(c)}},P=async(e,t)=>{const n="DecodeVinExtended",o=s(e);if(!e||o!=="string")return i(`${n}, "vin" argument is required and must be of type string, got: <${o}> ${e}`);const c=s(t);if(t&&c!=="object")return i(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=s(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return i(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const $=await l(t).catch(u=>i(`${n}, error building query string: ${u}`)),a=`${f}/${n}/${e}${$}`;return await y().get(a).then(u=>u).catch(u=>i(`${n}, error fetching data: ${u}`))},F=async(e,t)=>{const n="DecodeVinValues",o=s(e);if(!e||o!=="string")return i(`${n}, "vin" argument is required and must be of type string, got: <${o}> ${e}`);const c=s(t);if(t&&c!=="object")return i(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=s(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return i(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const $=await l(t).catch(u=>i(`${n}, error building query string: ${u}`)),a=`${f}/${n}/${e}${$}`;return await y().get(a).then(u=>u).catch(u=>i(`${n}, error fetching data: ${u}`))},D=async e=>{const t="DecodeVinValuesBatch",n=s(e);if(!e||n!=="string")return i(`${t}, "inputString" argument is required and must be of type string, got: <${n}> ${e}`);const o=`${f}/${t}/`,c=encodeURI(`DATA=${e}&format=${w}`);return await y().get(o,{method:"POST",headers:{"content-type":"application/x-www-form-urlencoded"},body:c}).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},E=async(e,t)=>{const n="DecodeVinValuesExtended",o=s(e);if(!e||o!=="string")return i(`${n}, "vin" argument is required and must be of type string, got: <${o}> ${e}`);const c=s(t);if(t&&c!=="object")return i(`${n}, "params" argument must be of type object, got: <${c}> ${t}`);const r=s(t==null?void 0:t.modelYear);if(t!=null&&t.modelYear&&r!=="number")return i(`${n}, "params.modelYear" must be of type number or string, got: <${r}> ${t.modelYear}`);const $=await l(t).catch(u=>i(`${n}, error building query string: ${u}`)),a=`${f}/${n}/${e}${$}`;return await y().get(a).then(u=>u).catch(u=>i(`${n}, error fetching data: ${u}`))},v=async e=>{const t="DecodeWMI",n=s(e);if(n!=="string")return i(`${t}, "WMI" argument is required and must be of type string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},R=async()=>{const e="GetAllMakes",t=await l().catch(o=>i(`${e}, error building query string: ${o}`)),n=`${f}/${e}${t}`;return await y().get(n).then(o=>o).catch(o=>i(`${e}, error fetching data: ${o}`))},L=async e=>{const t="GetAllManufacturers",n=s(e);if(e&&n!=="object")return i(`${t}, "params" argument must be of type object, got: <${n}> ${e}`);const o=s(e==null?void 0:e.manufacturerType);if(e!=null&&e.manufacturerType&&o!=="string")return i(`${t}, params.manufacturerType" argument must be of type string, got: <${o}> ${e.manufacturerType}`);const c=s(e==null?void 0:e.page);if(e!=null&&e.page&&c!=="number | string")return i(`${t}, "params.page" argument must be of type number or string, got: <${c}> ${e.page}`);const r=await l(e).catch(a=>i(`${t}, error building query string: ${a}`)),$=`${f}/${t}${r}`;return await y().get($).then(a=>a).catch(a=>i(`${t}, error fetching data: ${a}`))},N=async e=>{const t="GetCanadianVehicleSpecifications",n=s(e);if(!e||e&&n!=="object")return i(`${t}, "params" argument is required and must be of type object, got: <${n}> ${e}`);const o=s(e==null?void 0:e.year);if(!(e!=null&&e.year)||o!=="number")return i(`${t}, "params.year" argument is required and must be of type number or string, got: <${o}> ${e.year}`);const c=s(e.make);if(e!=null&&e.make&&c!=="string")return i(`${t}, "params.make" argument must be of type string, got: <${c}> ${e.make}`);const r=s(e.model);if(e.model&&r!=="string")return i(`${t}, "params.model" argument must be of type string, got: <${r}> ${e.model}`);const $=s(e.units);if(e.units&&$!=="string")return i(`${t}, "params.units" argument must be of type string, got: <${$}> ${e.units}`);const a=e.make||"",u=e.model||"",g=e.units||"",b={year:e.year,make:a,model:u,units:g},m=await l(b,!0).catch(M=>i(`${t}, error building query string: ${M}`)),h=`${f}/${t}/${m}`;return await y().get(h).then(M=>M).catch(M=>i(`${t}, error fetching data: ${M}`))},U=async e=>{const t="GetEquipmentPlantCodes",n=s(e);if(!e||n!=="object")return i(`${t}, "params" argument must be of type object, got: <${n}> ${e}`);const o=s(e.year);if(o!=="number")return i(`${t}, "params.year" argument is required and must be of type number or string, got: <${o}> ${e.year}`);const c=s(e.equipmentType);if(c!=="number")return i(`${t}, "params.equipmentType" argument is required and must be of type number or string, got: <${c}> ${e.equipmentType}`);const r=s(e.reportType);if(r!=="string")return i(`${t}, "params.reportType" argument is required and must be of type string, got: <${r}> ${e.reportType}`);const $=await l(e).catch(u=>i(`${t}, error building query string: ${u}`)),a=`${f}/${t}${$}`;return await y().get(a).then(u=>u).catch(u=>i(`${t}, error fetching data: ${u}`))},C=async e=>{const t="GetMakeForManufacturer",n=s(e);if(!e||n!=="number")return i(`${t}, "manufacturer" argument is required and must be of type number or string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},O=async(e,t)=>{const n="GetMakesForManufacturerAndYear",o=s(e);if(!e||o!=="number")return i(`${n}, "manufacturer" argument is required and must be of type number or string, got <${o}> ${e}`);const c=s(t);if(!t||t&&c!=="object")return i(`${n}, "params" argument is required and must be of type object, got: <${c}> ${t}`);const r=s(t.year);if(!t.year||r!=="number")return i(`${n}, "params.year" is required and must be of type number or string, got: <${r}> ${t.year}`);const $=await l(t).catch(u=>i(`${n}, error building query string: ${u}`)),a=`${f}/${n}/${e}${$}`;return await y().get(a).then(u=>u).catch(u=>i(`${n}, error fetching data: ${u}`))},W=async e=>{const t="GetMakesForVehicleType",n=s(e);if(n!=="string")return i(`${t}, "typeName" argument is required and must be of type string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},_=async e=>{const t="GetManufacturerDetails",n=s(e);if(!e||n!=="number")return i(`${t}, "manufacturer" argument is required and must be of type number or string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},B=async e=>{const t="GetModelsForMake",n=s(e);if(n!=="string")return i(`${t}, "makeName" argument is required and must be of type string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},H=async e=>{const t="GetModelsForMakeId",n=s(e);if(!e||n!=="number")return i(`${t}, "makeId" argument is required and must be of type number or string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},J=async e=>{const t="GetModelsForMakeIdYear",n=e==null?void 0:e.makeId,o=e==null?void 0:e.modelYear,c=e==null?void 0:e.vehicleType,r=s(e);if(!e||e&&r!=="object")return i(`${t}, "params" argument is required and must be of type object, got: <${r}> ${e}`);const $=s(n);if(!n||$!=="number")return i(`${t}, "params.makeId" is required and must be of type number or string, got: <${$}> ${n}`);if(!o&&!c)return i(`${t}, must provide either "params.modelYear" or "params.vehicleType", got: { modelYear: ${o}, vehicleType: ${c} }`);const a=s(o);if(e!=null&&e.modelYear&&a!=="number")return i(`${t}, "params.modelYear" must be of type number or string, got: <${a}> ${o}`);const u=s(c);if(c&&u!=="string")return i(`${t}, "params.vehicleType" must be of type string, got: <${u}> ${c}`);let g=`${t}/makeId/${n}/`;o&&c?g+=`modelYear/${o}/vehicleType/${c}`:o?g+=`modelYear/${o}`:g+=`vehicleType/${c}`;const b=await l().catch(h=>i(`${t}, error building query string: ${h}`)),m=`${f}/${g}${b}`;return await y().get(m).then(h=>h).catch(h=>i(`${t}, error fetching data: ${h}`))},X=async e=>{const t="GetModelsForMakeYear";try{const n=[{name:"modelYear",types:["number","string"],value:e.modelYear},{name:"vehicleType",types:["string"],value:e.vehicleType}],o=[{name:"params",required:!0,types:["object"],value:e},{name:"make",required:!0,types:["string"],value:e.make},...n];V({args:o}),V({args:n,mode:"atLeast"});const c=Object.entries(e).filter(([,g])=>T({name:"",types:["string","number","boolean"],value:g,mode:"boolean"})).reduce((g,[b,m])=>(g[b]=encodeURIComponent(m),g),{}),{make:r,modelYear:$,vehicleType:a}=c;let u=`${f}/${t}/make/${r}/`;return $&&(u+=`modelYear/${$}`),a&&(u+=`${$?"/":""}vehicleType/${a}`),u+=G(),await y().get(u)}catch(n){return i(n)}},Q=async e=>{const t="GetParts",n=e==null?void 0:e.type,o=e==null?void 0:e.fromDate,c=e==null?void 0:e.toDate,r=e==null?void 0:e.page,$=s(e);if(e&&$!=="object")return i(`${t}, "params" argument must be of type object, got: <${$}> ${e}`);const a=s(n);if(n&&a!=="number")return i(`${t}, "params.type" argument must be of type number or string, got: <${a}> ${n}`);const u=s(o);if(o&&u!=="string")return i(`${t}, "params.fromDate" argument must be of type string, got: <${u}> ${o}`);const g=s(c);if(c&&g!=="string")return i(`${t}, "params.toDate" argument must be of type string, got: <${g}> ${c}`);const b=s(r);if(r&&b!=="number")return i(`${t}, "params.page" argument must be of type number or string, got: <${b}> ${r}`);const m=await l(e).catch(q=>i(`${t}, error building query string: ${q}`)),h=`${f}/${t}${m}`;return await y().get(h).then(q=>q).catch(q=>i(`${t}, error fetching data: ${q}`))},Z=async e=>{const t="GetVehicleTypesForMake",n=s(e);if(!e||n!=="string")return i(`${t}, "makeName" argument is required and must be of type string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},z=async e=>{const t="GetVehicleTypesForMakeId",n=s(e);if(!e||n!=="number")return i(`${t}, "makeId" argument is required and must be of type number or string, got <${n}> ${e}`);const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},K=async()=>{const e="GetVehicleVariableList",t=await l().catch(o=>i(`${e}, error building query string: ${o}`)),n=`${f}/${e}${t}`;return await y().get(n).then(o=>o).catch(o=>i(`${e}, error fetching data: ${o}`))},x=async e=>{const t="GetVehicleVariableValuesList",n=s(e);if(!e||!["number","string"].includes(n))return i(`${t}, "variableValue" argument is required and must be of type number or string, got <${n}> ${e}`);e=encodeURI(String(e));const o=await l().catch(r=>i(`${t}, error building query string: ${r}`)),c=`${f}/${t}/${e}${o}`;return await y().get(c).then(r=>r).catch(r=>i(`${t}, error fetching data: ${r}`))},ee=async(e,t)=>{const n="GetWMIsForManufacturer",o=t==null?void 0:t.vehicleType;if(!e&&!o)return i(`${n}, "manufacturer" and "params.vehicleType" arguments are optional but at least 1 is required, got: manufacturer: ${e} and vehicleType: ${o}`);const c=s(e);if(e&&!["number","string"].includes(c))return i(`${n}, "manufacturer" must be of type number or string, got <${c}> ${e}`);const r=s(t);if(t&&r!=="object")return i(`${n}, "params" must be of type object, got: <${r}> ${t}`);const $=s(t==null?void 0:t.vehicleType);if(t!=null&&t.vehicleType&&!["number","string"].includes($))return i(`${n}, "params.vehicleType" must be of type number or string, got: <${$}> ${t.vehicleType}`);const a=await l(t).catch(g=>i(`${n}, error building query string: ${g}`)),u=`${f}/${n}/${e||""}${a}`;return await y().get(u).then(g=>g).catch(g=>i(`${n}, error fetching data: ${g}`))};return d.DecodeVin=p,d.DecodeVinExtended=P,d.DecodeVinValues=F,d.DecodeVinValuesBatch=D,d.DecodeVinValuesExtended=E,d.DecodeWMI=v,d.GetAllMakes=R,d.GetAllManufacturers=L,d.GetCanadianVehicleSpecifications=N,d.GetEquipmentPlantCodes=U,d.GetMakeForManufacturer=C,d.GetMakesForManufacturerAndYear=O,d.GetMakesForVehicleType=W,d.GetManufacturerDetails=_,d.GetModelsForMake=B,d.GetModelsForMakeId=H,d.GetModelsForMakeIdYear=J,d.GetModelsForMakeYear=X,d.GetParts=Q,d.GetVehicleTypesForMake=Z,d.GetVehicleTypesForMakeId=z,d.GetVehicleVariableList=K,d.GetVehicleVariableValuesList=x,d.GetWMIsForManufacturer=ee,d.isValidVin=A,Object.defineProperty(d,Symbol.toStringTag,{value:"Module"}),d}({});
//# sourceMappingURL=nhtsa-api-wrapper.iife.js.map
